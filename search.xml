<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020-2021 ICPC Brazil比赛</title>
    <url>/2020-2021%20ICPC%20Brazil%E6%AF%94%E8%B5%9B/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2d5bS8xMDI4NjE=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<a id="more"></a>
<h2 id="A-Sticker-Album"><a href="#A-Sticker-Album" class="headerlink" title="A.Sticker Album"></a>A.Sticker Album</h2><p>题目描述：<br>买卡包，每包里有卡片[A,B]张，获得每个卡片的概率都相同，问买多少卡包能组成N张卡片的期望。</p>
<p>题解：<br>细节题。<br>我们令dp[i]表示n-i张卡片所需卡包的期望值。（避免出现下标为负数）<br>对于A!=0有<br>$dp[i]=\frac{\sum_{j=i+A}^{i+B}dp[j]}{R-L+1}+1$</p>
<p>对于A==0有<br>$dp[i]=\frac{\sum_{j=i}^{i+B}dp[j]+dp[i]}{p}+1$</p>
<p>化简可得<br>$dp[i]=\frac{\sum_{j=i}^{i+B}dp[j]+p}{p-1}$</p>
<p>然后就可以线性递推了。</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> dp[N];</span><br><span class="line"><span class="comment">//dp[i]表示n-i的期望卡包数量</span></span><br><span class="line"><span class="keyword">int</span> n,L,R;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;L,&amp;R);</span><br><span class="line">    <span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> p=(<span class="keyword">double</span>)(R-L+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(L)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            dp[i]=sum/p+<span class="number">1</span>;</span><br><span class="line">            sum-=dp[i+R];</span><br><span class="line">            sum+=dp[i+L<span class="number">-1</span>];</span><br><span class="line">        &#125;<span class="built_in">printf</span>(<span class="string">&quot;%.5f\n&quot;</span>,dp[<span class="number">0</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            dp[i]=(sum+p)/(p<span class="number">-1</span>);</span><br><span class="line">            sum-=dp[i+R];</span><br><span class="line">            sum+=dp[i];</span><br><span class="line">        &#125;<span class="built_in">printf</span>(<span class="string">&quot;%.5f\n&quot;</span>,dp[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="B-Battleship"><a href="#B-Battleship" class="headerlink" title="B.Battleship"></a>B.Battleship</h2><p>题目描述：<br>给出若干个船的朝向和初始位置，且网格为10*10，问初始位置是否合理。</p>
<p>题解：<br>水题。直接模拟就行了，将每艘船占据的位置打上标记，以后每一艘进来判断是否已经存在即可。</p>
<details>
    <summary>参考代码</summary>
    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> f[<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ck</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;<span class="number">10</span>||j&lt;<span class="number">1</span>||j&gt;<span class="number">10</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(f[i][j])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> D,R,C,L;</span><br><span class="line">    <span class="keyword">bool</span> g=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;D,&amp;L,&amp;R,&amp;C);</span><br><span class="line">        <span class="keyword">if</span>(!D)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=L;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!ck(R,C+j<span class="number">-1</span>))&#123;</span><br><span class="line">                    g=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;f[R][C+j<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=L;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!ck(R+j<span class="number">-1</span>,C))&#123;</span><br><span class="line">                    g=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;f[R+j<span class="number">-1</span>][C]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">if</span>(g)<span class="built_in">printf</span>(<span class="string">&quot;Y\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;N\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="C-Concatenating-Teams"><a href="#C-Concatenating-Teams" class="headerlink" title="C.Concatenating Teams"></a>C.Concatenating Teams</h2><h2 id="D-Divisibility-Dance"><a href="#D-Divisibility-Dance" class="headerlink" title="D.Divisibility Dance"></a>D.Divisibility Dance</h2><h2 id="E-Party-Company"><a href="#E-Party-Company" class="headerlink" title="E.Party Company"></a>E.Party Company</h2><p>题目描述：<br><del>题面什么东西，看半天没看懂</del></p>
<p>给定一棵树，每个点i有一个权值<script type="math/tex">a_i</script>，现有m次派对<script type="math/tex">(O_j,L_j,R_j)</script>，第j次参加派对的为含O的连通块，且连通块内所有点权值在<script type="math/tex">[L,R]</script>之间(数据保证<script type="math/tex">L_j \leq a_{O_j} \leq R_j</script>)</p>
<h2 id="F-Fastminton"><a href="#F-Fastminton" class="headerlink" title="F.Fastminton"></a>F.Fastminton</h2><h2 id="G-Game-Show"><a href="#G-Game-Show" class="headerlink" title="G.Game Show!"></a>G.Game Show!</h2><p>题目描述：<br>给了你100块钱和n个a[i]，你可以拿前面连续的若干个，问最后最多你还有多少钱。</p>
<p>题解：<br>水题。找出最大的前缀和即可。</p>
<details>
    <summary>参考代码</summary>
    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        ans=max(ans,a[i]+<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="H-SBC’s-Hangar"><a href="#H-SBC’s-Hangar" class="headerlink" title="H.SBC’s Hangar"></a>H.SBC’s Hangar</h2><h2 id="I-Interactivity"><a href="#I-Interactivity" class="headerlink" title="I.Interactivity"></a>I.Interactivity</h2><h2 id="J-Collecting-Data"><a href="#J-Collecting-Data" class="headerlink" title="J.Collecting Data"></a>J.Collecting Data</h2><h2 id="K-Between-Us"><a href="#K-Between-Us" class="headerlink" title="K.Between Us"></a>K.Between Us</h2><h2 id="L-Lavaspar"><a href="#L-Lavaspar" class="headerlink" title="L.Lavaspar"></a>L.Lavaspar</h2><p>题目描述：<br>给你L*C(我用的n*m表示的)的图，每个点有一个字符，给定N个字符串，可以横着、竖着、斜着在图上匹配，只要每个字符出现次数相同即可，问有多少个点可以匹配至少两个字符串。<br><img data-src="https://subdomains.codeforces.ml/espresso/cd90e2adbd43c9079e295c1f91d07f83881d83a5.png" alt=""><br>例如上图，每种颜色框表示不同字符串匹配，黄色代表的是特殊位置即他们至少能匹配两个字符串。</p>
<p>题解：<br>水题。每个字符串找出所有和他匹配的所有点，然后更新每个点可以匹配字符串数目即可。</p>
<details>
<summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">45</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[N][N],now_cnt[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> Q;</span><br><span class="line"><span class="keyword">int</span> py[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">char</span> s[N][N],p[N];</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">30</span>],d[<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ck</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||j&lt;<span class="number">1</span>||i&gt;n||j&gt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Q);</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,p+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> K=<span class="built_in">strlen</span>(p+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=K;++i)</span><br><span class="line">            ++d[p[i]-<span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">        <span class="built_in">memset</span>(now_cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(now_cnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;++k)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x=i,y=j;</span><br><span class="line">                    <span class="keyword">bool</span> is=<span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">memcpy</span>(c,d,<span class="keyword">sizeof</span>(c));</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">1</span>;step&lt;=K;++step)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!ck(x,y))&#123;</span><br><span class="line">                            is=<span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(--c[s[x][y]-<span class="string">&#x27;A&#x27;</span>]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                            is=<span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        x+=py[k][<span class="number">0</span>],y+=py[k][<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(is)&#123;</span><br><span class="line">                        x=i,y=j;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">1</span>;step&lt;=K;++step)&#123;</span><br><span class="line">                            ++now_cnt[x][y];</span><br><span class="line">                            x+=py[k][<span class="number">0</span>],y+=py[k][<span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">                cnt[i][j]+=now_cnt[i][j]&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">            ans+=cnt[i][j]&gt;=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="M-Machine-Gun"><a href="#M-Machine-Gun" class="headerlink" title="M.Machine Gun"></a>M.Machine Gun</h2><h2 id="N-Number-Multiplication"><a href="#N-Number-Multiplication" class="headerlink" title="N.Number Multiplication"></a>N.Number Multiplication</h2><p>题目描述：<br>数学题，自己看描述吧。</p>
<p>题解：<br>因为a是递增的，且我们知道对于$n$最多只存在一个$\sqrt{n}$以上的质因数，因此这题就好做了。</p>
<p>我们找到第一个满足条件的质数a[i]即可开始找a[i+1]，因为如果存在多种满足条件的a[i]，我们只能选择最小的一个，否则最后肯定不满足条件，因为a数组是递增的，如果当前不取最小的，则后面都无法取到。</p>
<p>且我们对于一个质数只用判断一个相连的b[j]是否满足即可，如果我们当前不选prime，则后面无论怎么选都无法满足条件(b[j]总会剩下若干个prime的乘积)。</p>
<p>然后对于大于$10^{7.5}$的a[i]直接令他等于与他相连的b[j]即可，因为最多只存在一个嘛，上面说了的。</p>
<details>
<summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,K;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>,M=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> b[N],a[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> index,d;</span><br><span class="line">    node(<span class="keyword">int</span> a=<span class="number">0</span>,<span class="keyword">int</span> b=<span class="number">0</span>)&#123;index=a,d=b;&#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp;other)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index&lt;other.index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt;q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)s*=a;</span><br><span class="line">        a*=a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="built_in">sqrt</span>(<span class="number">1e15</span>)+<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;K);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;b[i]);</span><br><span class="line">    <span class="keyword">int</span> u,v,d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=K;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;d);</span><br><span class="line">        q[u].push_back(node(v,d));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> Min_pr=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> c=q[i].size();</span><br><span class="line">        <span class="keyword">for</span>(++Min_pr;Min_pr&lt;=Max;++Min_pr)&#123;</span><br><span class="line">            <span class="keyword">bool</span> g=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1</span>;++j)&#123;</span><br><span class="line">                node now=q[i][j];</span><br><span class="line">                <span class="keyword">if</span>(b[now.index]%qpow(Min_pr,now.d))</span><br><span class="line">                    g=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(g)&#123;</span><br><span class="line">                a[i]=Min_pr;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c;++j)&#123;</span><br><span class="line">                    node now=q[i][j];</span><br><span class="line">                    b[now.index]/=qpow(Min_pr,now.d);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Min_pr&gt;Max)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=n;++i)</span><br><span class="line">        a[i]=b[q[i][<span class="number">0</span>].index];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="O-Venusian-Shuttle"><a href="#O-Venusian-Shuttle" class="headerlink" title="O.Venusian Shuttle"></a>O.Venusian Shuttle</h2>]]></content>
      <tags>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 102 (Rated for Div. 2)</title>
    <url>/Educational-Codeforces-Round-102-Rated-for-Div-2/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3My8=">比赛链接<i class="fa fa-external-link-alt"></i></span></p>
<a id="more"></a>
<h2 id="A-Replacing-Elements"><a href="#A-Replacing-Elements" class="headerlink" title="A.Replacing Elements"></a>A.Replacing Elements</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3My9wcm9ibGVtL0E=">题目链接<i class="fa fa-external-link-alt"></i></span><br>题目描述：<br>n个元素的数组，可以任取$(i,j,k)$，令 $a_i=a_j+a_k$，问是否可以使得所有数小于等于给定的数d。</p>
<p>题解：<br>很显然，将n个数从小到大排序后，所有$i\geq 3$的数均可被替换成$a_1+a_2$，则判断$a_1+a_2$是否小于等于d或者$a_n$是否小于等于d即可。</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T,d;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;d);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">1</span>]+a[<span class="number">2</span>]&lt;=d)<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[n]&lt;=d)<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="B-String-LCM"><a href="#B-String-LCM" class="headerlink" title="B.String LCM"></a>B.String LCM</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3My9wcm9ibGVtL0I=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题目描述：<br>见原题。</p>
<p>题解：<br>1.暴力。直接从大到小枚举gcd长度，并且暴力判断是否符合题意，假设gcd长度为l，第一个串长度为n,第二个为m，则将gcd字符串输出$\frac{n*m}{l*l}$次即可。<br/><br>2.某个引理。待填坑。</p>
<h2 id="C-No-More-Inversions"><a href="#C-No-More-Inversions" class="headerlink" title="C.No More Inversions"></a>C.No More Inversions</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3My9wcm9ibGVtL0M=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题目描述：<br>逆序对定义为$i<j,a_i>a_j$。<br/><br>求出一个数组p，令b[i]=p[a[i]]，且要求b的逆序对数小于等于a的逆序对数，并且要最大化b的字典序。</p>
<p>题解：<br>$\because a[k-i]=a[k+i]$<br/><br>$\therefore b[k-i]=b[k+i]$<br/><br>且a数组的逆序对数可以求出来，然后b数组关于k对称，b数组$2*k-n \sim n$的逆序对数也很容易求，即等于a的逆序对数，与p无关。<br>因此b数组前$2*k-n-1$个数不能与任何数形成逆序对，且$2*k-n \sim n$可以任意排列，则前$2*k-n-1$个数从1开始从小到大排，$2*k-n\sim n$从n开始从大到小即可。</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*k-n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Max=k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*k-n;i&lt;=k;++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Max--);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="D-Program"><a href="#D-Program" class="headerlink" title="D.Program"></a>D.Program</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3My9wcm9ibGVtL0Q=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题目描述：<br>初始x是0，给定长度为n的字符串，’+’表示x++，’-‘表示x—，给出m次询问[L,R]，忽略[L,R]，问x有多少种取值。<br>例如： ++—+ 若忽略[2,3]则为+-+，x依次为0，1，0，1，共两个取值。</p>
<p>题解：<br>x的值始终是连续的，则求出x的最大值和最小值即可，即前缀和的最大值和最小值。<br>用重载运算符简化代码。</p>
<details>
    <sumamry>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,M=N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> ch[M][<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s,Min,Max;</span><br><span class="line">    node()&#123;</span><br><span class="line">        s=Min=Max=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node q[M];</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span>+(node a,node b)&#123;</span><br><span class="line">    node c;</span><br><span class="line">    c.Min=min(a.Min,a.s+b.Min);</span><br><span class="line">    c.Max=max(a.Max,a.s+b.Max);</span><br><span class="line">    c.s=a.s+b.s;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> n,m,T;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc ch[x][0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc ch[x][1]</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    x=++cnt;</span><br><span class="line">    <span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">        <span class="keyword">int</span> val=s[L]==<span class="string">&#x27;+&#x27;</span>?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        q[x].Min=min(val,<span class="number">0</span>);</span><br><span class="line">        q[x].Max=max(val,<span class="number">0</span>);</span><br><span class="line">        q[x].s=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">int</span> mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(lc,L,mid);</span><br><span class="line">    build(rc,mid+<span class="number">1</span>,R);</span><br><span class="line">    q[x]=q[lc]+q[rc];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> node <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> ll,<span class="keyword">int</span> rr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll&lt;=L&amp;&amp;R&lt;=rr)<span class="keyword">return</span> q[x];</span><br><span class="line">    <span class="keyword">int</span> mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(rr&lt;=mid)<span class="keyword">return</span> query(lc,L,mid,ll,rr);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ll&gt;mid)<span class="keyword">return</span> query(rc,mid+<span class="number">1</span>,R,ll,rr);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(lc,L,mid,ll,rr)+query(rc,mid+<span class="number">1</span>,R,ll,rr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        build(ch[<span class="number">0</span>][<span class="number">0</span>],<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">int</span> L,R;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;L,&amp;R);</span><br><span class="line">            node x;</span><br><span class="line">            <span class="keyword">if</span>(L!=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(R!=n)x=query(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,L<span class="number">-1</span>)+query(<span class="number">1</span>,<span class="number">1</span>,n,R+<span class="number">1</span>,n);</span><br><span class="line">                <span class="keyword">else</span> x=query(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,L<span class="number">-1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(R!=n)x=query(<span class="number">1</span>,<span class="number">1</span>,n,R+<span class="number">1</span>,n);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,-x.Min+x.Max+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="E、F、G待填坑"><a href="#E、F、G待填坑" class="headerlink" title="E、F、G待填坑"></a>E、F、G待填坑</h2>]]></content>
      <tags>
        <tag>cf比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>HNOI2011 Problem b</title>
    <url>/HNOI2011-Problem-b/</url>
    <content><![CDATA[<ul>
<li>莫比乌斯反演入门题，让刚学莫比乌斯反演的我有了继续学下去的欲望。</li>
</ul>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>n 次询问 $\sum_{i=a}^{b}\sum_{j=c}^{d} [gcd(i,j)==k]$ 。<br><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI1MjI=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>数学题没啥好说的，这题显然的莫比乌斯反演题，把其变为可以莫比乌斯反演的形式即可。<br>并且可以用一个简单地容斥将下限都换成 1 。<br>设 $f(k)=\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)==k]$ ， $F(k)=\sum_{i=1}^{n}\sum_{j=1}^{m}[k|gcd(i,j)]$<br/><br>则有<br>$F(k)=\sum_{k|d}f(d)=\lfloor\frac{n}{k}\rfloor\lfloor\frac{m}{k}\rfloor$<br>前者很显然，后者因为只要求是 k 倍数的gcd，则 i , j 均为 k 的倍数即可。<br>然后我们开始愉快的推式子：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\because F(k)=\sum_{k|d}f(d) \\
&\therefore f(k) =\sum_{k|d}\mu(\frac{d}{k})F(d) \\
\end{aligned}</script><p>即</p>
<script type="math/tex; mode=display">
f(k) = \sum_{k|d}\mu(\frac{d}{k})\lfloor\frac{n}{d}\rfloor \lfloor\frac{m}{d}\rfloor</script><p>再令 $T=\frac{d}{k}$</p>
<script type="math/tex; mode=display">
f(k)=\sum_{T}^{\frac{min(n,m)}{k}}\mu(R)\lfloor\frac{n}{kT}\rfloor \lfloor\frac{m}{kT}\rfloor</script><p>然后整除分块即可。<br>关于整除分块，其实就是将$\frac{n}{kT}\frac{m}{KT}$相同的一起处理<br/><br>比如当$T\in(L,R)$时$\frac{n}{kT}\frac{m}{KT}$相同，则这一部分答案为$\frac{n}{kT}\frac{m}{KT}\sum_{i=L}^{R}\mu(i)$，预处理一下莫比乌斯函数的前缀和就好。</p>
<p>代码如下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N],mu[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N];</span><br><span class="line"><span class="keyword">bool</span> f[N];</span><br><span class="line"><span class="keyword">int</span> a,b,c,d,k;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>,f[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="number">5e4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            prime[++prime[<span class="number">0</span>]]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=prime[<span class="number">0</span>]&amp;&amp;i*prime[j]&lt;=maxn;++j)&#123;</span><br><span class="line">            f[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            mu[i*prime[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;++i)</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+mu[i];</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    n/=k,m/=k;</span><br><span class="line">    <span class="keyword">int</span> maxn=min(n,m);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;l&lt;=maxn;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=min(n/(n/l),m/(m/l));</span><br><span class="line">        ans+=(sum[r]-sum[l<span class="number">-1</span>])*(n/l)*(m/l);</span><br><span class="line">    &#125;<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,F(b,d,k)-F(b,c<span class="number">-1</span>,k)-F(a<span class="number">-1</span>,d,k)+F(a<span class="number">-1</span>,c<span class="number">-1</span>,k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP详解</title>
    <url>/KMP%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>KMP算法的核心，是一个被称为 <strong>部分匹配表(Partial Match Table)</strong> 的数组。我觉得理解KMP的最大障碍就是很多人在看了很多关于KMP的文章之后，仍然搞不懂PMT中的值代表了什么意思。这里我们抛开所有的枝枝蔓蔓，先来解释一下这个数据到底是什么。<br><a id="more"></a><br>对于字符串“abababca”，它的PMT如下表所示:<br><img data-src="https://pic2.zhimg.com/v2-e905ece7e7d8be90afc62fe9595a9b0f_r.jpg?source=1940ef5c" alt=""><br>就像例子中所示的，如果待匹配的模式字符串有8个字符，那么PMT就会有8个值。</p>
<p>我先解释一下字符串的前缀和后缀。<em>如果字符串A和B，存在A=BS，其中S是任意的非空字符串，那就称B为A的前缀</em>。例如，”Harry”的前缀包括{”H”, ”Ha”, ”Har”, ”Harr”}，我们把所有前缀组成的集合，称为字符串的前缀集合。<em>同样可以定义后缀A=SB， 其中S是任意的非空字符串，那就称B为A的后缀</em>，例如，”Potter”的后缀包括{”otter”, ”tter”, ”ter”, ”er”, ”r”}，然后把所有后缀组成的集合，称为字符串的后缀集合。<strong>要注意的是，字符串本身并不是自己的后缀</strong>。</p>
<p>有了这个定义，就可以说明PMT中的值的意义了。<strong>PMT中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度</strong>。例如，对于”aba”，它的前缀集合为{”a”, ”ab”}，后缀 集合为{”ba”, ”a”}。两个集合的交集为{”a”}，那么长度最长的元素就是字符串”a”了，长 度为1，所以对于”aba”而言，它在PMT表中对应的值就是1。再比如，对于字符串”ababa”，它的前缀集合为{”a”, ”ab”, ”aba”, ”abab”}，它的后缀集合为{”baba”, ”aba”, ”ba”, ”a”}， 两个集合的交集为{”a”, ”aba”}，其中最长的元素为”aba”，长度为3。</p>
<p>好了，解释清楚这个表是什么之后，我们再来看如何使用这个表来加速字符串的查找，以及这样用的道理是什么。如图 1.12 所示，要在主字符串”ababababca”中查找模式字符串”abababca”。如果在 j 处字符不匹配，那么由于前边所说的模式字符串 PMT 的性质，主字符串中 i 指针之前的 PMT[j−1] 位就一定与模式字符串的第 0 位至第 PMT[j−1] 位是相同的。这是因为主字符串在 i 位失配，也就意味着主字符串从 i−j 到 i 这一段是与模式字符串的 0 到 j 这一段是完全相同的。而我们上面也解释了，模式字符串从 0 到 j−1 ，在这个例子中就是”ababab”，其前缀集合与后缀集合的交集的最长元素为”abab”， 长度为4。所以就可以断言，主字符串中i指针之前的 4 位一定与模式字符串的第0位至第 4 位是相同的，即长度为 4 的后缀与前缀相同。这样一来，我们就可以将这些字符段的比较省略掉。具体的做法是，保持i指针不动，然后将j指针指向模式字符串的PMT[j−1]位即可。</p>
<p>简言之，以图中的例子来说，在 i 处失配，那么主字符串和模式字符串的前边6位就是相同的。又因为模式字符串的前6位，它的前4位前缀和后4位后缀是相同的，所以我们推知主字符串i之前的4位和模式字符串开头的4位是相同的。就是图中的灰色部分。那这部分就不用再比较了。</p>
<p><img data-src="https://pic4.zhimg.com/80/v2-03a0d005badd0b8e7116d8d07947681c_720w.jpg?source=1940ef5c" alt=""></p>
<p>有了上面的思路，我们就可以使用PMT加速字符串的查找了。我们看到如果是在 j 位 失配，那么影响 j 指针回溯的位置的其实是第 j −1 位的 PMT 值，所以为了编程的方便， 我们不直接使用PMT数组，而是将PMT数组向后偏移一位。我们把新得到的这个数组称为next数组。下面给出根据next数组进行字符串匹配加速的字符串匹配程序。其中要注意的一个技巧是，在把PMT进行向右偏移时，第0位的值，我们将其设成了-1，这只是为了编程的方便，并没有其他的意义。在本节的例子中，next数组如下表所示。</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-40b4885aace7b31499da9b90b7c46ed3_720w.jpg?source=1940ef5c" alt=""></p>
<p>具体的程序如下所示:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span>*s,<span class="keyword">char</span>*p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//s是主串,p是模式串</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s),m=<span class="built_in">strlen</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;n&amp;&amp;j&lt;m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span>||s[i]==p[j])</span><br><span class="line">            ++i,++j;</span><br><span class="line">        <span class="keyword">else</span> j=nxt[j];<span class="comment">//因为next会出现命名冲突,所以用nxt</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(j==m)</span><br><span class="line">        <span class="keyword">return</span> i-j;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>好了，讲到这里，其实KMP算法的主体就已经讲解完了。你会发现，其实KMP算法的动机是很简单的，解决的方案也很简单。远没有很多教材和算法书里所讲的那么乱七八糟，只要搞明白了PMT的意义，其实整个算法都迎刃而解。</p>
<p>现在，我们再看一下如何编程快速求得next数组。其实，求next数组的过程完全可以看成字符串匹配的过程，即以模式字符串为主字符串，以模式字符串的前缀为目标字符串，一旦字符串匹配成功，那么当前的next值就是匹配成功的字符串的长度。</p>
<p>具体来说，就是从模式字符串的第一位(注意，不包括第0位)开始对自身进行匹配运算。 在任一位置，能匹配的最长长度就是当前位置的next值。如下图所示。</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-645f3ec49836d3c680869403e74f7934_720w.jpg?source=1940ef5c" alt=""><br><img data-src="https://pic1.zhimg.com/80/v2-06477b79eadce2d7d22b4410b0d49aba_720w.jpg?source=1940ef5c" alt=""><br><img data-src="https://pic1.zhimg.com/80/v2-8a1a205df5cad7ab2f07498484a54a89_720w.jpg?source=1940ef5c" alt=""><br><img data-src="https://pic2.zhimg.com/80/v2-f2b50c15e7744a7b358154610204cc62_720w.jpg?source=1940ef5c" alt=""><br><img data-src="https://pic2.zhimg.com/80/v2-bd42e34a9266717b63706087a81092ac_720w.jpg?source=1940ef5c" alt=""></p>
<p>求next数组值的程序如下所示:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNxt</span><span class="params">(<span class="keyword">char</span>*s,<span class="keyword">int</span>*nxt)</span></span>&#123;</span><br><span class="line">    nxt[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">-1</span>,n=<span class="built_in">strlen</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span>||s[i]==s[j])</span><br><span class="line">            nxt[++i]=++j;</span><br><span class="line">        <span class="keyword">else</span> j=nxt[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，KMP算法就全部介绍完了。</p>
<blockquote>
<p>转载自 知乎 作者：海纳<br>原文链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIxOTIzMDIxL2Fuc3dlci8yODEzNDY3NDY=">https://www.zhihu.com/question/21923021/answer/281346746<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>FFT详解</title>
    <url>/FFT%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="FFT定义"><a href="#FFT定义" class="headerlink" title="FFT定义"></a>FFT定义</h2><blockquote>
<p>FFT（Fast Fourier Transformation）是离散傅氏变换（DFT）的快速算法。即为快速傅氏变换。它是根据离散傅氏变换的奇、偶、虚、实等特性，对离散傅立叶变换的算法进行改进获得的。<br>(yysy这个定义看着乐呵就好)<br><a id="more"></a></p>
</blockquote>
<h2 id="FFT的用处"><a href="#FFT的用处" class="headerlink" title="FFT的用处"></a>FFT的用处</h2><p>在算法竞赛中会碰到卷积形式的计数，或者说多项式乘法，但是常规的计算复杂度是$O(n^2)$的，当 n 比较大的时候，很显然不能满足我们的要求。<br>而FFT将这个过程的复杂度降低到了$O(nlog n)$。</p>
<h2 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h2><h3 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h3><p>简单来说，形如$a_0+a_1 x+a_2 x^{2}…+a_n a^{n}$的代数表达式叫做多项式，可以记做$f(x)=a_0+a_1 x+a_2 x^{2}…+a_n a^{n}$</p>
<h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>复数形如$a+bi$，其中$i=\sqrt{-1},i*i=-1$<br/><br>a 叫做复数的实部， b 叫做复数的虚部。<br>复数相乘：</p>
<script type="math/tex; mode=display">
(a1+b1i)*(a2+b2i)=(a1*a2-b1*b2)+(a1*b2+a2*b1)i</script><p>复数$c+di$可以用这种方式表示出来：<br><img data-src="https://tu.sunpma.com/imgs/2021/01/f7bce41a38b84035.png" alt=""><br>复数乘法的在复平面中表现为<strong>辐角相加，模长相乘</strong></p>
<h3 id="单位根"><a href="#单位根" class="headerlink" title="单位根"></a>单位根</h3><p>复数 w 满足$w^n=1$，则称 w 是 n 次单位根，下图包含了所有的 8 次方根 （下图中圆的半径是1）<br><img data-src="https://tu.sunpma.com/imgs/2021/01/427fa960f8864b4c.png" alt=""></p>
<p>n 次单位根用 $w_n$ 表示<br/><br>关于单位根有如下性质：<br>1.$w_{2n}^{2}=w_{n}$，因此有$w_{2n}^{2m}=w_{n}^{m}$<br/><br>2.$w_{n}^{\frac{n}{2}}=-1$，因此有$w_{2n}^{m}=-w_{2n}^{m+\frac{n}{2}}$<br/><br>这两个很有用，一定要记住。</p>
<h3 id="多项式的系数表示法"><a href="#多项式的系数表示法" class="headerlink" title="多项式的系数表示法"></a>多项式的系数表示法</h3><p>这是我们常用的表示方法，即$f(x)=a_0+a_1 x+a_2 x^{2}…+a_n a^{n}$的形式，称$A(X)$是多项式$f(x)$的系数表示法。<br/><br>这样多项式乘法是$O(n^2)$</p>
<h3 id="多项式的点值表示法"><a href="#多项式的点值表示法" class="headerlink" title="多项式的点值表示法"></a>多项式的点值表示法</h3><p>即用 n+1 个点表示多项式，可以证明 n+1 个不同的点可以唯一确定一个 n 次多项式。<br>其实就是相当于有 n+1 个方程求 n+1 个未知数（ n 次多项式最高此项是n，最多是 n+1 项）<br>也可以将其理解为解系数矩阵。<br>这样多项式乘法是$O(n)$，因为我们只需要两个多项式分别求出$O(n)$个点，然后相乘即可确定两个多项式相乘后的多项式。<br/></p>
<h2 id="FFT的具体过程"><a href="#FFT的具体过程" class="headerlink" title="FFT的具体过程"></a>FFT的具体过程</h2><p>我们可以看到点值表示法多项式相乘是$O(n)$的，不过要转化为点值相乘却要$O(n^2)$，因此我们要想办法降低这些点值的复杂度。<br/><br>所以FFT即将系数表示法转化为点值表示法再转化回来，其中第一个过程叫 <strong>求值(DFT)</strong>，第二个过程叫 <strong>插值(IDFT)</strong>。</p>
<h3 id="求值"><a href="#求值" class="headerlink" title="求值"></a>求值</h3><p>还记得我们之前提到的单位根吗？回顾一下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&w_{2n}^{2m}=w_{n}^{m}\\
&w_{n}^{m}=-w_{n}^{m+\frac{n}{2}}\\
\end{aligned}</script><p>设$A_0(X)$为$A(X)$（这里设其为n次多项式，共n+1项，n+1为偶数）偶数项的和，设$A_1(X)$为$A(X)$奇数项的和，即</p>
<script type="math/tex; mode=display">
\begin{aligned}
&A_0(X)=a_0+a_2X+...+a_{n-1}X^{\frac{n}{2}}\\
&A_1(X)=a_1+a_3X+...+a_{n}X^{\frac{n}{2}}\\
\end{aligned}</script><p>因为$A(w_{n}^{m})=a_0w_{n}^{0}+a_1w_n^{m}+a_2w_n^{2m}+…+a_{n}w_{n}^{nm}$<br/><br>将此多项式偶数项和奇数项分别提出来可以得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
&a_0w_n^0+a_2w_n^{2m}+a_4w_n^{4m}+...+a_{n-1}w_n^{(n-1)m}\\
&a_1w_n^m+a_3w_n^{3m}+a_5w_n^{5m}+...+a_{n}w_n^{nm}\\
\end{aligned}</script><p>根据之前的性质可以得出</p>
<script type="math/tex; mode=display">
\begin{aligned}
&A_0(w_{\frac{n}{2}}^{m})=A_0({w_n^{2m}})=a_0w_n^0+a_2w_n^{2m}+a_4w_n^{4m}+...+a_{n-1}w_n^{(n-1)m} \\
&A_1(w_{\frac{n}{2}}^{m})=A_1({w_n^{2m}})=a_1w_n^0+a_3w_n^{2m}+a_5w_n^{4m}+...+a_{n}w_n^{(n-1)m}\\
\end{aligned}</script><p>因此有$A(w_n^m)=A_0(w_{\frac{n}{2}}^m)+w_n^m*A_1(w_{\frac{n}{2}}^m)$<br/></p>
<p>且有$A(w_n^{m+\frac{n}{2}})=A_0(w_{\frac{n}{2}}^{m+\frac{n}{2}})+w_{n}^{m+\frac{n}{2}}*A_1(w_{\frac{n}{2}}^{m+\frac{n}{2}})$<br/></p>
<p>$\because w_{\frac{n}{2}}^{m+\frac{n}{2}}=w_{\frac{n}{2}}^{m}，w_{n}^{m+\frac{n}{2}}=-w_{n}^{m}$<br/></p>
<p>$\therefore A(w_n^{m+\frac{n}{2}})=A_0(w_{\frac{n}{2}}^{m})-w_{n}^{m}*A_1(w_{\frac{n}{2}}^{m})$<br/></p>
<p>这样的话，只要知道了$A_0(X)$和$A_1(X)$的点值表示，就可以$O(n)$求出$A(X)$的点值表示。<br/><br>我们将 $2^k$ 次单位根看做是第 k 层，这样我们知道了第 k-1 层的点值表示，就可以推出第 k 层。<br/><br>假设$f(2^k)$是求$2^k$多项式的复杂度，则有$f(2^k)=2*f(2^{k-1})+2^k$，因此复杂度是$O(k*2^k)$，令$n=2^k$，即$O(n log n)$。</p>
<p>因为这个过程一定要求每层都可以分成两大小相等的部分，所以求的点值必须是$2^k(k\in N)$个，则最高次至多为$2^k-1$，项数至多为$2^k$，如果次数不够，可以将高次项设置为0。</p>
<p>于是我们就有了递归写法：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex* a,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    Complex* a0=<span class="keyword">new</span> Complex[len/<span class="number">2</span>];</span><br><span class="line">    Complex* a1=<span class="keyword">new</span> Complex[len/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        a0[i/<span class="number">2</span>]=a[i];</span><br><span class="line">        a1[i/<span class="number">2</span>]=a[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(a0,len/<span class="number">2</span>);FFT(a1,len/<span class="number">2</span>);</span><br><span class="line">    <span class="function">Complex <span class="title">wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span>*Pi/len),<span class="built_in">sin</span>(<span class="number">2</span>*Pi/len))</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(len/<span class="number">2</span>);i++)&#123;</span><br><span class="line">        a[i]=a0[i]+w*a1[i];</span><br><span class="line">        a[i+len/<span class="number">2</span>]=a0[i]-w*a1[i];</span><br><span class="line">        w=w*wn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但递归版的FFT常数巨大，实现起来比较复杂，于是又有了迭代的写法</p>
<p>重新考虑下递归FFT的过程，在第 i 次求解中，我们将所有元素二进制 i 位为 0 的放在了左面，i 位为 1 的放在了右面，事实上，每个元素最终到的是他二进制颠倒过来的位置<br>例如：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>000</th>
<th>001</th>
<th>010</th>
<th>011</th>
<th>100</th>
<th>101</th>
<th>110</th>
<th>111</th>
</tr>
</thead>
<tbody>
<tr>
<td>000</td>
<td>010</td>
<td>100</td>
<td>110</td>
<td>001</td>
<td>011</td>
<td>101</td>
<td>111</td>
</tr>
<tr>
<td>000</td>
<td>100</td>
<td>001</td>
<td>101</td>
<td>010</td>
<td>110</td>
<td>011</td>
<td>111</td>
</tr>
<tr>
<td>000</td>
<td>001</td>
<td>010</td>
<td>011</td>
<td>100</td>
<td>101</td>
<td>110</td>
<td>111</td>
</tr>
</tbody>
</table>
</div>
<p>这样子我们将原数组顺序替换成最下面之后就不用再像递归一样每次把原数组的偶数项放左边，奇数项放右边了。<br>关于如何将二进制反转，其实也不难。<br>假设有个数 x ，我们知道了 x&gt;&gt;1 反转后的数，那么 x 反转后的数和 x&gt;&gt;1 反转后的数就差最高位，而这个最高位是 x 的最低位反转后的，然后就很简单了。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_rev</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">1</span>&lt;&lt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(s<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后我们再看看非递归版该怎么向上合并。<br>我们对应要求的$x$的值列出来</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$w_8^0$</th>
<th>$w_8^1$</th>
<th>$w_8^2$</th>
<th>$w_8^3$</th>
<th>$w_8^4$</th>
<th>$w_8^5$</th>
<th>$w_8^6$</th>
<th>$w_8^7$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$w_4^0$</td>
<td>$w_4^1$</td>
<td>$w_4^2$</td>
<td>$w_4^3$</td>
<td>$w_4^0$</td>
<td>$w_4^1$</td>
<td>$w_4^2$</td>
<td>$w_4^3$</td>
</tr>
<tr>
<td>$w_2^0$</td>
<td>$w_2^1$</td>
<td>$w_2^0$</td>
<td>$w_2^1$</td>
<td>$w_2^0$</td>
<td>$w_2^1$</td>
<td>$w_2^0$</td>
<td>$w_2^1$</td>
</tr>
<tr>
<td>$w_1^0$</td>
<td>$w_1^0$</td>
<td>$w_1^0$</td>
<td>$w_1^0$</td>
<td>$w_1^0$</td>
<td>$w_1^0$</td>
<td>$w_1^0$</td>
<td>$w_1^0$</td>
</tr>
</tbody>
</table>
</div>
<p>首先最下面一层，只用求一个点，这个点只用求$x=w_{1}^{0}=1$的值即可，所以交换后的数组即为最下面一层的初始值。<br>然后从最下面一层慢慢往上推就行了，可以通过手动模拟画图来找到递推的规律。<br>迭代写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DFT</span><span class="params">(Complex*a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i])<span class="comment">//没这个条件的话，交换两次就会恢复原状</span></span><br><span class="line">            swap(a[i],a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,mid=<span class="number">1</span>;i&lt;=n;i&lt;&lt;=<span class="number">1</span>,mid&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function">Complex <span class="title">wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span>*PI/i),<span class="built_in">sin</span>(<span class="number">2</span>*PI/i))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j+=i)&#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;j+mid;++k)&#123;</span><br><span class="line">                Complex x=a[k],y=w*a[k+mid];</span><br><span class="line">                a[k]=x+y,a[k+mid]=x-y;</span><br><span class="line">                w=w*wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><p>刚刚计算的是 $\vec y = DFT_n(\vec a)$，可以将多项式转化成点值表示，现在为了将点值表示转化成系数表示，需要计算 IDFT（Inverse Discrete Fourier Transform），它是 DFT 的逆</p>

<p>这个问题实际上相当于是一个解线性方程组的问题，也就是给出了 $n$ 个线性方程 \(\begin{equation*} \left\{ \begin{array}{ccccccccc} a_0(\omega_n^0)^{0}&amp;+&amp;\cdots&amp;+&amp;a_{n-2}(\omega_n^0)^{n-2}&amp;+&amp;+a_{n-1}(\omega_n^0)^{n-1}&amp;=&amp;A(\omega_n^0) \\ a_0(\omega_n^1)^{0}&amp;+&amp;\cdots&amp;+&amp;a_{n-2}(\omega_n^1)^{n-2}&amp;+&amp;+a_{n-1}(\omega_n^1)^{n-1}&amp;=&amp;A(\omega_n^1) \\ \vdots &amp; &amp; \vdots &amp; &amp;\vdots&amp; &amp; \vdots &amp; &amp; \vdots\\ a_0(\omega_n^{n-1})^{0}&amp;+&amp;\cdots&amp;+&amp;a_{n-2}(\omega_n^{n-1})^{n-2}&amp;+&amp;+a_{n-1}(\omega_n^{n-1})^{n-1}&amp;=&amp;A(\omega_n^{n-1}) \end{array} \right. \end{equation*}\)</p>

<p>写成矩阵方程的形式就是</p>

<p>\begin{equation} \label{IDFT-equation} \begin{bmatrix} (\omega_n^0)^0 &amp; (\omega_n^0)^1 &amp; \cdots &amp; (\omega_n^0)^{n-1} \\ (\omega_n^1)^0 &amp; (\omega_n^1)^1 &amp; \cdots &amp; (\omega_n^1)^{n-1} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ (\omega_n^{n-1})^0 &amp; (\omega_n^{n-1})^1 &amp; \cdots &amp; (\omega_n^{n-1})^{n-1} \end{bmatrix} \begin{bmatrix} a_0 \\ a_1 \\ \vdots \\ a_{n-1} \end{bmatrix} = \begin{bmatrix} A(\omega_n^0) \\ A(\omega_n^1) \\ \vdots \\ A(\omega_n^{n-1}) \end{bmatrix} \end{equation}</p>
<p>记上面的系数矩阵为 $\mathbf V$ 现在考虑下面这个矩阵 $d_{ij}=\omega_n^{-ij}$ </p>
<p>\begin{equation} \mathbf D = \begin{bmatrix} (\omega_n^{-0})^0 &amp; (\omega_n^{-0})^1 &amp; \cdots &amp; (\omega_n^{-0})^{n-1} \\ (\omega_n^{-1})^0 &amp; (\omega_n^{-1})^1 &amp; \cdots &amp; (\omega_n^{-1})^{n-1} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ (\omega_n^{-(n-1)})^0 &amp; (\omega_n^{-(n-1)})^1 &amp; \cdots &amp; (\omega_n^{-(n-1)})^{n-1} \end{bmatrix} \end{equation}</p>
<p>设它们相乘后的结果是 $\mathbf E=\mathbf D \cdot \mathbf V$</p>

<p>\begin{eqnarray} e_{ij} &amp;=&amp; \sum_{k=0}^{n-1} d_{ik} v_{kj} \\ &amp;=&amp; \sum_{k=0}^{n-1} \omega_n^{-ik}\omega_n^{kj} \\ &amp;=&amp; \sum_{k=0}^{n-1} \omega_n^{k(j-i)} \end{eqnarray}</p>
<p>当 $i=j$ 时，$e_{ij}=n$</p>

<p>当 $i\neq j$ 时，</p>

<p>\begin{eqnarray} e_{ij} &amp;=&amp; \sum_{k=0}^{n-1} (\omega_n^{j-i})^k \\ &amp;=&amp; \frac{1-(\omega_n^{j-i})^n}{1-\omega_n^{j-i}}\\ &amp;=&amp; 0 \end{eqnarray}</p>
<p>因此可以知道 $\mathbf I_n=\frac{1}{n}\mathbf E$，所以 $\frac{1}{n}\mathbf D = \mathbf V^{-1}$</p>

<p>将 $\frac{1}{n}\mathbf D$ 在 $\ref{IDFT-equation}$ 左乘就会得到</p>

<p>\begin{equation} \begin{bmatrix} a_0 \\ a_1 \\ \vdots \\ a_{n-1} \end{bmatrix} = \frac{1}{n} \begin{bmatrix} (\omega_n^{-0})^0 &amp; (\omega_n^{-0})^1 &amp; \cdots &amp; (\omega_n^{-0})^{n-1} \\ (\omega_n^{-1})^0 &amp; (\omega_n^{-1})^1 &amp; \cdots &amp; (\omega_n^{-1})^{n-1} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ (\omega_n^{-(n-1)})^0 &amp; (\omega_n^{-(n-1)})^1 &amp; \cdots &amp; (\omega_n^{-(n-1)})^{n-1} \end{bmatrix} \begin{bmatrix} A(\omega_n^0) \\ A(\omega_n^1) \\ \vdots \\ A(\omega_n^{n-1}) \end{bmatrix} \end{equation}</p>
<p>这样，IDFT 就相当于把 DFT 过程中的 $\omega_n^i$ 换成 $\omega_n^{-i}$，然后做一次 DFT，之后结果除以 $n$ 就可以了。</p>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="洛谷P3803-多项式乘法模板题"><a href="#洛谷P3803-多项式乘法模板题" class="headerlink" title="洛谷P3803 多项式乘法模板题"></a>洛谷P3803 多项式乘法模板题</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM4MDM=">多项式乘法模板<i class="fa fa-external-link-alt"></i></span><br>多项式乘法还是有些细节需要注意：<br>1.自带的complex速度不如手写一个Complex，推荐手写一个Complex，并重载运算符。<br>2.注意数组开的大小。<br>3.此题相乘后是最高次是 n+m 次，因此需要至少 n+m+1 个点值。<br>4.因为精度可能出问题，因此最后需要四舍五入。</p>
<p>下面上代码</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;<span class="comment">//实部和虚部</span></span><br><span class="line">    Complex(<span class="keyword">double</span> a=<span class="number">0</span>,<span class="keyword">double</span> b=<span class="number">0</span>)&#123;</span><br><span class="line">        x=a;</span><br><span class="line">        y=b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>+(Complex a,Complex b)&#123;<span class="keyword">return</span> Complex(a.x+b.x,a.y+b.y);&#125;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(Complex a,Complex b)&#123;<span class="keyword">return</span> Complex(a.x-b.x,a.y-b.y);&#125;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>*(Complex a,Complex b)&#123;<span class="keyword">return</span> Complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1</span>&lt;&lt;<span class="number">21</span>|<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> rev[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_rev</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">1</span>&lt;&lt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(s<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex*a,<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;<span class="comment">//p为1即DFT，p为-1即为IDFT</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">            swap(a[i],a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,mid=<span class="number">1</span>;i&lt;=n;i&lt;&lt;=<span class="number">1</span>,mid&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function">Complex <span class="title">wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span>*PI/i),p*<span class="built_in">sin</span>(<span class="number">2</span>*PI/i))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j+=i)&#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;j+mid;++k)&#123;</span><br><span class="line">                Complex x=a[k],y=w*a[k+mid];</span><br><span class="line">                a[k]=x+y,a[k+mid]=x-y;</span><br><span class="line">                w=w*wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)a[i].x/=n;</span><br><span class="line">&#125;<span class="keyword">int</span> n,m;</span><br><span class="line">Complex a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i].x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;b[i].x);</span><br><span class="line">    <span class="keyword">int</span> len=n+m+<span class="number">1</span>,s=<span class="number">1</span>,bit=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s&lt;len)++bit,s&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    get_rev(bit);</span><br><span class="line">    FFT(a,s,<span class="number">1</span>),FFT(b,s,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;++i)a[i]=a[i]*b[i];</span><br><span class="line">    FFT(a,s,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="keyword">int</span>(a[i].x+<span class="number">0.5</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h3 id="牛客挑战赛47-E-路径"><a href="#牛客挑战赛47-E-路径" class="headerlink" title="牛客挑战赛47 E.路径"></a>牛客挑战赛47 E.路径</h3><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA3NDMvRQ==">点分治+FFT<i class="fa fa-external-link-alt"></i></span><br><a href="/牛客挑战赛47E-路径/">题解</a></p>
<blockquote>
<p>参考文章<br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dBRHVhbjIvYXJ0aWNsZS9kZXRhaWxzLzc5NTI5OTAw">FFT算法讲解<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jsb2cubWlza2Nvby5jb20vMjAxNS8wNC9wb2x5bm9taWFsLW11bHRpcGxpY2F0aW9uLWFuZC1mYXN0LWZvdXJpZXItdHJhbnNmb3JtI21qeC1lcW4tSURGVC1lcXVhdGlvbg==">从多项式乘法到快速傅里叶变换<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>第一篇讲的是针不戳，就是有些细节有点问题，本文已经处理过了（<del>不保证修bug一定不出新bug qwq</del>）</p>
]]></content>
      <tags>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round#695 Div.2</title>
    <url>/CodeforcesR695/</url>
    <content><![CDATA[<h2 id="A-Wizard-of-Orz"><a href="#A-Wizard-of-Orz" class="headerlink" title="A. Wizard of Orz"></a>A. Wizard of Orz</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ2Ny9wcm9ibGVtL0E=">题目链接<i class="fa fa-external-link-alt"></i></span><br><a id="more"></a><br>题意：长度为n的数组，选择某一位为任意0~9，从其开始至左右两端逐渐递增（依然在0~9之间），问最大的数。<br>题解：<br>此题有坑，可能会想到第一位为9然后一直递减下去，但这样并不是最大的。<br>如果n&gt;2，则第三位是7，但是如果选第二位是8，则第一位都为9且第三位是9，因此当n&gt;2时选第二位为8即可。</p>
<h2 id="B-Hills-And-Valleys"><a href="#B-Hills-And-Valleys" class="headerlink" title="B. Hills And Valleys"></a>B. Hills And Valleys</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ2Ny9wcm9ibGVtL0I=">题目链接<i class="fa fa-external-link-alt"></i></span><br>题意：给定长度为n的数组，定义山峰为比左右两边都大的数，山谷为比左右两边都小的，可以修改一个数，问最小的山峰山谷数。<br>题解：<br>挺简单的，先求出初始的山峰+山谷数量，然后依次枚举每个数，将其修改为其左边、右边的数然后取最小即可。<br>因为只修改了一个数最多影响三个位置的状态。</p>
<h2 id="C-Three-Bags"><a href="#C-Three-Bags" class="headerlink" title="C. Three Bags"></a>C. Three Bags</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ2Ny9wcm9ibGVtL0M=">题目链接<i class="fa fa-external-link-alt"></i></span><br>题意：给了三组数，每次给以从两个非空数组中各选出一个数，假设先从一个取出A,后一个取出B，则将A-B放入取出A的数组，问最后能得到的最大值。<br>题解：<br>挺不错的思维题。<br>首先如果某一个数被合并了偶数次，那么他是它本身，否则是相反数。<br>能想到这一步基本就做出来了。<br>1.一个数组的情况，如果没有不同的数组的限制，那么想要最大，我们可以让大部分数都合并两次，最小的数合并一次。<br>我们随便取一个除了最小的数之外的数，然后将其他所有的非最小数合并到最小数上，再将最小的数合并到之前那个随便取的数，这样就是最大的，只减去了一个最小的数。<br>2.如果是两个数组，还是假设最后合并的数在第一个数组，则第二个数组无论如何合并都是奇数次，第一个数组无论如何都是偶数次，所以即减去第二个数组的和。<br>3.如果是三个数组，还是假设最后合并的数在第一个数组。<br>我们不妨将第二个数组除了最小的数都合并到第三个数组的最小的数，第三个数组除了最小的数都合并到第二个数组最小的数上。<br>这样再合并到第一个数组大部分数都是合并了偶数次，会比较优。<br>接下来会有两种情况，一种是将这两个数组最小的数都合并到第一个数组，即答案为sum-2*(min[2]+min[3])(sum为所有数总和，min[i]表示第i个数组的最小的数)<br>一种是将其中一个数组的最小的数再合并到另一个最小数上，再合并到第一个数组，这样其实最后答案就是减去了其中一个数组。</p>
<p>然后枚举最后的数所在的数组，再在两种情况中取最大即可。</p>
<p>D E 没做了，打了一半去休息了，以后填坑。（<del>以后你还记得个鬼</del>）</p>
]]></content>
      <tags>
        <tag>cf比赛</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>SCOI2005最大子矩阵</title>
    <url>/SCOI2005%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>这里有一个n*m的矩阵，请你选出其中k个子矩阵，使得这个k个子矩阵分值之和最大。<br>注意：选出的k个子矩阵 不能相互重叠。</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL3Byb2JsZW0vMjAyNDI=">题目链接<i class="fa fa-external-link-alt"></i></span><br><a id="more"></a></p>
<p>题解：<br>题目范围很重要，$m\leq 2$，当m为1时即简单的数组中取k段连续和的最大值，令dp[i][j]表示前i个取j个子矩阵的最大值即可。<br>当m=2时，即将上述的二维dp改为三维dp即可，令dp[i][j][k]表示第一列前i个，第二列前j个中取k个子矩阵的最大值。<br>dp[i][j][k]初始为max(dp[i-1][j][k],dp[i][j-1][k])，表示不取的转移。<br>1.如果是当前取一个一列的矩阵，则分别在两列进行转移：</p>
<script type="math/tex; mode=display">
\begin{aligned}
dp[i][j][k]=max\{dp[p][j][k-1]+s1[i]-s1[p]\}\\
dp[i][j][k]=max\{dp[i][p][k-1]+s2[i]-s2[p]\}
\end{aligned}</script><p>2.如果是取一个两列的矩阵，则只能在i=j时进行转移：</p>
<script type="math/tex; mode=display">
\begin{aligned}
dp[i][i][k]=max\{dp[p][p][k-1]+s1[i]+s2[i]-s1[p]-s2[p]\}
\end{aligned}</script><p>其中s1表示第一列前缀和，s2表示第二列前缀和。</p>
<p>不过后来我发现这样做还是有些问题的，如果m=1并且第一列全为负数，这样第二列当做0算，这样取的k个子矩阵可能有第二列的，但这是非法的，因此需要考虑将m=1和m=2分开来做或者是第二列前缀和进行修改。<br>因为数据范围并不大，因此对第二列前缀和修改即可，而且此题貌似数据也很弱，不考虑也能过。</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>][<span class="number">12</span>],s[<span class="number">105</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">105</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0xf3</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">            s[i][j]=s[i<span class="number">-1</span>][j]+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;++j)</span><br><span class="line">            dp[i][j][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            s[i][<span class="number">2</span>]=-i*<span class="number">1e7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=k;++p)<span class="comment">//取p个子矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="comment">//第一列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;<span class="comment">//第二列</span></span><br><span class="line">                dp[i][j][p]=max(dp[i<span class="number">-1</span>][j][p],dp[i][j<span class="number">-1</span>][p]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;i;++l)</span><br><span class="line">                    dp[i][j][p]=max(dp[i][j][p],dp[l][j][p<span class="number">-1</span>]+s[i][<span class="number">1</span>]-s[l][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;j;++l)</span><br><span class="line">                    dp[i][j][p]=max(dp[i][j][p],dp[i][l][p<span class="number">-1</span>]+s[j][<span class="number">2</span>]-s[l][<span class="number">2</span>]);</span><br><span class="line">                <span class="keyword">if</span>(i==j)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;i;++l)</span><br><span class="line">                        dp[i][j][p]=max(dp[i][j][p],dp[l][l][p<span class="number">-1</span>]+s[i][<span class="number">1</span>]+s[i][<span class="number">2</span>]-s[l][<span class="number">1</span>]-s[l][<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[n][n][k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
]]></content>
      <tags>
        <tag>DP</tag>
        <tag>牛客每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round#682 (Div.2) A~D</title>
    <url>/CodeforcesR682/</url>
    <content><![CDATA[<div id="cnblogs_post_body" class="blogpost-body">
    <p>（<span style="text-decoration: line-through">题外话：本来要上紫了的,结果unrated...</span>）</p>

<a id="more"></a>
<h2>A. Specific Tastes of Andre</h2>
<p><span style="font-size: 18px"><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQzOC9wcm9ibGVtL0E=">题目链接<i class="fa fa-external-link-alt"></i></span></span></p>
<p><span style="font-size: 18px">题目大意：让你构造一个长度为n的数组，其所有元素之和为n的倍数</span></p>
<p><span style="font-size: 18px">题解：直接输出n个1即可</span></p>
<h2>B. Valerii Against Everyone</h2>
<p><span style="font-size: 18px"><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQzOC9wcm9ibGVtL0I=">题目链接<i class="fa fa-external-link-alt"></i></span></span></p>
<p><span style="font-size: 18px">题目大意：给定数组 b ,a<sub>i</sub>=2<sup>b<sub>i</sub></sup><sub>&nbsp;</sub>,问<strong>是否存在两个不相同的a的子数组和相同</strong></span></p>
<p><span style="font-size: 18px">题解：</span></p>
<ul>
<li><span style="font-size: 18px">对于b数组若存在 (i,j) 使得 b<sub>i&nbsp;</sub>= b<sub>j</sub>，则必定存在。</span></li>
<li><span style="font-size: 18px">若b数组互不相同，则从二进制来看，则不同的a的子数组至少有一位二进制不同，所以必定不存在（每一位仅有一个a可以取得，若两个数相同，则子数组必相等）</span></li>
</ul>
<p><span style="font-size: 18px">故题目转化为<strong>判断b数组是否有相同的数</strong>。</span></p>
<h2>C. Engineer Artem</h2>
<p><span style="font-size: 18px"><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQzOC9wcm9ibGVtL0M=">题目链接<i class="fa fa-external-link-alt"></i></span></span></p>
<p><span style="font-size: 18px">题目大意：给定一个n*m的二维数组，第 i 行第 j 列是 a[i][j] ，请你构造出二维数组 b , b[i][j] = a[i][j] or a[i][j] + 1 ,<strong>并且相邻的数不相同</strong></span></p>
<p><span style="font-size: 18px">题解：</span></p>
<p><em><span style="font-size: 18px">类似于二分图染色</span></em></p>
<p><em><span style="font-size: 18px">对于 (i+j)%2 的点必定互不相邻</span></em></p>
<p><span style="font-size: 18px">我们对于所有 a[i][j] = x 的数，将 (i+j+x)%2 为 0 的数 + 1，因为对于 a[i][j] = x + 1 的数 (i+j+x+1)%2 为 0 的 +1 ，则只剩下 (i+j+x)%2 为 0 的，那么 x+1 只存在 (i+j+x)%2 为 0 的，必定不相邻</span></p>
<p><span style="font-size: 18px">根据数学归纳，可以得知所有的数如此操作后必定能满足条件。</span></p>
<h2>D. Powerful Ksenia</h2>
<p><span style="font-size: 18px"><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQzOC9wcm9ibGVtL0Q=">题目链接<i class="fa fa-external-link-alt"></i></span></span></p>
<p><span style="font-size: 18px">题目大意：给定长度为n的数组，每次可以选择 (i,j,k) ，令 a<sub>i&nbsp;</sub>= a<sub>j&nbsp;</sub>= a<sub>k&nbsp;</sub>= a<sub>i</sub>^a<sub>j</sub>^a<sub>k&nbsp;&nbsp;</sub>，在最多n次操作内使得所有数相同</span></p>
<p><span style="font-size: 18px">题解：</span></p>
<ul>
<li><em><span style="font-size: 18px">对于任意三个数，可以通过一次操作使其变成相同</span></em></li>
<li><em><span style="font-size: 18px">对于两个相同的数和 x ，可以通过一次操作使其变为 x&nbsp;</span></em></li>
<li><span style="font-size: 18px"><em>操作并不改变异或和</em></span></li>
</ul>
<p><span style="font-size: 18px">然后我们<strong>考虑令所有数 = a<sub>1</sub>^a<sub>2</sub>^...^a<sub>n</sub></strong>（<span style="text-decoration: line-through">常用套路</span>）</span></p>
<p><span style="font-size: 18px"><strong>首先将前三个数变为相同</strong>，接着后面每两个数((4,5),(6,7)....)和前面一个数进行一次操作</span></p>
<p><span style="font-size: 18px">这样因为前三个数是 a<sub>1</sub>^a<sub>2</sub>^a<sub>3&nbsp;</sub>,第三个和第四个第五个异或成 a<sub>1</sub>^a<sub>2</sub>^a<sub>3</sub>^a<sub>4</sub>^a<sub>5&nbsp;</sub></span></p>
<p><span style="font-size: 18px">后面同理</span></p>
<p><span style="font-size: 18px"><strong>如果 (n-3)%2 为 0</strong> ，则 a<sub>n&nbsp;</sub>即为 a<sub>1</sub>^a<sub>2</sub>^...^a<sub>n&nbsp;</sub>，且前面均为两个一组的相同的数，每次操作将两个一组的相同的数和n进行异或</span></p>
<p><span style="font-size: 18px"><strong>如果 (n-3)%2 不为 0</strong> ，则还剩一个数 a<sub>n&nbsp;</sub>，这里我们证明下为什么这种情况 a<sub>1</sub>^a<sub>2</sub>^...^a<sub>n&nbsp;</sub>不为 0 的时候无解，若 (n-3)%2==1 ，则 n=3+2k+1=4+2k 为偶数</span></p>
<p><span style="font-size: 18px">对于相同的数如果有 k 个，可以将其化简为 k%2 个，因为 2 个相同的数一定可以和 x 变为 x ，所以可以等价为每个数最多只有一个，且仍然是偶数个</span></p>
<p><span style="font-size: 18px">若最后可以化为所有数相同，则所有数异或和为 0 ，<strong>因为操作并不会导致异或和改变，因此这种情况当且仅当所有数异或和为 0 有解。</strong></span></p>
<p><span style="font-size: 18px">当有解时同第一种情况一样做就行了。</span></p>
<p>操作次数为很显然符合题意</p>
<h2>E.Yurii Can Do Everything</h2>
<p>我不会qwq</p>
</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">


</div>
]]></content>
      <tags>
        <tag>cf比赛</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>Steps to One</title>
    <url>/Steps-to-One/</url>
    <content><![CDATA[<p>这一题质量是真的不错，做了很久才做出来（初学莫比乌斯反演，别骂了<br><a id="more"></a></p>
<p>题目描述：<br>每次随机选出 $1\sim m$中的一个数，当已有的数的 gcd 为 1 时停止，问停止时的期望次数。<br/><br><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL3Byb2JsZW0vMTEzNTUy">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题解：</p>
<ul>
<li>看到的一个<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLm5vd2NvZGVyLm5ldC9uLzQ2YTU2YjYwMTlkMzRlYjM5OWE4MmM1NmJjZWQyZjJj">神仙题解<i class="fa fa-external-link-alt"></i></span>，复杂度是O(m)。</li>
<li>我的题解<br>假设$F_i$是 gcd 为 i 时变成 1 的期望次数，则不难得出$F_i=1+\frac{1}{m}\sum_{j=1}^{m}F_{gcd(i,j)}$<br/><br>这个$gcd(i,j)$下标不好处理，我们将其变为枚举 $gcd(i,j)$，则可以得到：<br/><script type="math/tex; mode=display">
F_{i}=1+\frac{1}{m}\sum_{d|i}F_{d}\sum_{j=1}^{m}[gcd(i,j)==d]</script>内层循环是可以进一步化简的，我们设$g(d)=\sum_{i=1}^{m}[gcd(i,n)==d],G(d)=\sum_{i=1}^{m}[d|gcd(i,n)]$<br/><br>可以得出<script type="math/tex; mode=display">
\begin{aligned}
&G(d)=\sum_{d|k}g(k)=\lfloor\frac{m}{d}\rfloor[n\%d==0] \\
&g(d)=\sum_{d|k}\mu(\frac{k}{d})G(k)=\sum_{d|k}\mu(\frac{k}{d})\lfloor\frac{m}{k}\rfloor[n\%k==0]
\end{aligned}</script>然后可以将原式稍微变形，并将上式代入：<script type="math/tex; mode=display">
\sum_{j=1}^{m}[gcd(i,j)==d]=\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(\frac{i}{d},j)==1]</script>代入 g(1) ，得<script type="math/tex; mode=display">
\begin{aligned}
\sum_{k}\mu(k)\lfloor\frac{m}{dk}\rfloor[\frac{i}{d}\%k==0]=\sum_{k|\frac{i}{d}}\mu(k)\lfloor\frac{m}{dk}\rfloor
\end{aligned}</script>令 $T=dk$ <script type="math/tex; mode=display">
\sum_{T|i}\mu(\frac{T}{d})\lfloor\frac{m}{T}\rfloor</script>代入原式<script type="math/tex; mode=display">
\begin{aligned}
F_i&=1+\frac{1}{m}\sum_{d|i}F_d\sum_{T|i}\mu(\frac{T}{d})\lfloor\frac{m}{T}\rfloor \\
&=1+\frac{1}{m}\sum_{T|i}\lfloor\frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})F_d
\end{aligned}</script>内层循环与 i 无关，因此可以进行处理，在求 F 的同时进行更新。<br>注意到左右两边均存在 $F_i$ ，将右边的 $F_i$提出并合并到左边即可<script type="math/tex; mode=display">
\begin{aligned}
F_i&=1+\frac{1}{m}\sum_{T|i}\lfloor\frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})F_d \\
&=1+\frac{1}{m}\sum_{T|i}\lfloor\frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})F_d[d\neq i]+\frac{1}{m}\lfloor\frac{m}{i}\rfloor\mu(1)F_i \\
&=1+\frac{1}{m}\sum_{T|i}\lfloor\frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})F_d[d\neq i]+\frac{1}{m}\lfloor\frac{m}{i}\rfloor F_i \\
F_{i}&=\frac{m+\sum_{T|i}\lfloor\frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})F_d[d\neq i]}{m-\lfloor\frac{m}{i}\rfloor}
\end{aligned}</script>记$g_T=\sum_{d|T}\mu(\frac{T}{d})F_d[d\neq i]$即可，每次求出$F_i$后更新 g ，因为 $g_T$在求出 $F_T$后被更新，因此求$F_T$时不需要特判$T\neq i$。<br/></li>
</ul>
<p>代码如下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">1e5</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a+b&gt;=mod?a+b-mod:a+b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a-b+mod:a-b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a*<span class="number">1ll</span>*b%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)s=mul(s,a);</span><br><span class="line">        a=mul(a,a);</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> prime[N],mu[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;q[N];</span><br><span class="line"><span class="keyword">bool</span> f[N];</span><br><span class="line"><span class="keyword">int</span> F[N],g[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="literal">true</span>,mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=M;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            prime[++prime[<span class="number">0</span>]]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=prime[<span class="number">0</span>]&amp;&amp;i*prime[j]&lt;=M;++j)&#123;</span><br><span class="line">            f[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            mu[i*prime[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)</span><br><span class="line">        mu[i]=mu[i]&lt;<span class="number">0</span>?mu[i]+mod:mu[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=M;j+=i)</span><br><span class="line">            q[j].push_back(i);</span><br><span class="line">    F[<span class="number">1</span>]=<span class="number">0</span>,g[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=q[i].size()<span class="number">-1</span>;~j;--j)</span><br><span class="line">            F[i]=add(F[i],mul(m/q[i][j],g[q[i][j]]));</span><br><span class="line">        F[i]=add(F[i],m);</span><br><span class="line">        F[i]=mul(F[i],qpow(m-m/i,mod<span class="number">-2</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=m;j+=i)</span><br><span class="line">            g[j]=add(g[j],mul(F[i],mu[j/i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        ans=add(ans,F[i]);</span><br><span class="line">    ans=add(<span class="number">1</span>,mul(ans,qpow(m,mod<span class="number">-2</span>)));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>DP</tag>
        <tag>牛客每日一题</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>WC2008游览计划</title>
    <url>/WC2008%E6%B8%B8%E8%A7%88%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这题我居然觉得难点是回溯…</p>
<a id="more"></a>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题其实和最小斯坦纳树模板很像，只是将边权改为了点权，而斯坦纳树通过 dp 方式转移的时候根节点 i 的点权会被算两次，因此减去一次即可。<br>然后就是套最小斯坦纳树板子了，不过这个回溯着实坑死我了…<br>其实就是记下每个 dp 状态是由什么转移过来的即可，最后从终止状态慢慢往回推，只要是回溯到的点都打上标记，代表这个位置安排了志愿者。</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">11</span>, M = <span class="number">1</span> &lt;&lt; <span class="number">10</span>, inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, c;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, s;</span><br><span class="line">    node(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        s = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;pre[N * N][M];</span><br><span class="line"><span class="keyword">int</span> d[N * N], nxt[N * N * <span class="number">4</span>], to[N * N * <span class="number">4</span>], w[N * N], id[N * N], tot;</span><br><span class="line"><span class="keyword">int</span> maxn, cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    to[++tot] = b;</span><br><span class="line">    nxt[tot] = d[a];</span><br><span class="line">    d[a] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[N * N][M], dis[N * N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="keyword">bool</span> in[N * N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++i) &#123;</span><br><span class="line">        dis[i] = dp[i][s];</span><br><span class="line">        <span class="keyword">if</span> (dis[i] &lt; inf)in[i] = <span class="number">1</span>, q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        in[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = to[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[u] &gt; dis[x] + w[u]) &#123;</span><br><span class="line">                dis[u] = dis[x] + w[u];</span><br><span class="line">                pre[u][s] = node(x, s);</span><br><span class="line">                <span class="keyword">if</span> (!in[u])in[u] = <span class="number">1</span>, q.push(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++i)dp[i][s] = dis[i];</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    maxn = <span class="number">1</span> &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++i)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> S = <span class="number">1</span>; S &lt; maxn; ++S) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> T = (S - <span class="number">1</span>) &amp; S; T; T = (T - <span class="number">1</span>) &amp; S) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = dp[i][T] + dp[i][S ^ T] - w[i];</span><br><span class="line">                <span class="keyword">if</span> (v &lt; dp[i][S]) &#123;</span><br><span class="line">                    dp[i][S] = v;</span><br><span class="line">                    pre[i][S] = node(i, T);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        spfa(S);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">int</span> py[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i - <span class="number">1</span>) * m + j; &#125;</span><br><span class="line"><span class="keyword">bool</span> ans[N * N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x)<span class="keyword">return</span>;</span><br><span class="line">    ans[x] = <span class="literal">true</span>;</span><br><span class="line">    node p = pre[x][s];</span><br><span class="line">    dfs(p.x, p.s);</span><br><span class="line">    <span class="keyword">if</span> (p.x == x)dfs(p.x, p.s ^ s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">int</span> root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = ++c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p);</span><br><span class="line">            w[x] = p;</span><br><span class="line">            <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">                id[x] = cnt++;</span><br><span class="line">                dp[x][<span class="number">1</span> &lt;&lt; id[x]] = <span class="number">0</span>;</span><br><span class="line">                root = x;</span><br><span class="line">                pre[x][<span class="number">1</span> &lt;&lt; id[x]] = node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                id[x] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = i + py[k][<span class="number">0</span>], y = j + py[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x&lt;<span class="number">1</span> || y&lt;<span class="number">1</span> || x&gt;n || y&gt;m)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> a = get(i, j), b = get(x, y);</span><br><span class="line">                ins(a, b);</span><br><span class="line">            &#125;</span><br><span class="line">    work();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[root][maxn - <span class="number">1</span>]);</span><br><span class="line">    dfs(root, maxn - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = get(i, j);</span><br><span class="line">            <span class="keyword">if</span> (id[x] == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans[x])<span class="built_in">printf</span>(<span class="string">&quot;o&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>最小斯坦纳树</tag>
      </tags>
  </entry>
  <entry>
    <title>YY的GCD</title>
    <url>/YY%E7%9A%84GCD/</url>
    <content><![CDATA[<p>入门级别的题（不过貌似我一开始想复杂了<br><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIyNTc=">题目链接<i class="fa fa-external-link-alt"></i></span><br><a id="more"></a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 $N, M$，求 $1 \leq x \leq N$，$1 \leq y \leq M$ 且 $\gcd(x, y)$ 为质数的 $(x, y)$ 有多少对。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>直接上柿子</p>
<script type="math/tex; mode=display">
Ans=\sum_{k\in prime}\sum_{i=1}^{N}\sum_{j=1}^{M}[gcd(i,j)==k]</script><p>如果莫比乌斯反演做了个几道题，就会知道要化简后面那个式子<br>我们令$f(k)=\sum_{i=1}^{N}\sum_{j=1}^{M}[gcd(i,j)==k],F(k)=\sum_{i=1}^{N}\sum_{j=1}^{M}[k|gcd(i,j)]$<br/><br>然后可以得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
&F(k)=\sum_{k|d}f(d)=\lfloor\frac{N}{k}\rfloor\lfloor\frac{M}{k}\rfloor \\
\therefore &f(k)=\sum_{k|d}\mu(\frac{d}{k})F(d)=\sum_{k|d}\mu(\frac{d}{k})\lfloor\frac{N}{d}\rfloor\lfloor\frac{M}{d}\rfloor
\end{aligned}</script><p>代入到 Ans 中，可以得到</p>
<script type="math/tex; mode=display">
Ans=\sum_{k\in prime}\sum_{k|d}\mu(\frac{d}{k})\lfloor\frac{N}{d}\rfloor\lfloor\frac{M}{d}\rfloor</script><p>这题因为是多组询问，如果我们将$\lfloor\frac{N}{d}\rfloor\lfloor\frac{M}{d}\rfloor$放在内层的话不好进行整数分块，因此要想办法将其放到外层<br/><br>因此我们外层枚举 d ：</p>
<script type="math/tex; mode=display">
Ans=\sum_{d=1}^{min(n,m)}\lfloor\frac{N}{d}\rfloor\lfloor\frac{M}{d}\rfloor(\sum_{k|d,k\in prime}\mu(\frac{d}{k}))</script><p>内层的这个与 N 和 M 无关，因此是可以预处理出其前缀和的，之后就可以进行整除分块了。</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e7</span>+<span class="number">10</span>,M=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> mu[N],prime[M];</span><br><span class="line"><span class="keyword">bool</span> f[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="literal">true</span>,mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="number">1e7</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            prime[++prime[<span class="number">0</span>]]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=prime[<span class="number">0</span>]&amp;&amp;i*prime[j]&lt;=maxn;++j)&#123;</span><br><span class="line">            f[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            mu[i*prime[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=prime[<span class="number">0</span>];++j)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*prime[j]&lt;=maxn;++i)</span><br><span class="line">            sum[i*prime[j]]+=mu[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;++i)</span><br><span class="line">        sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxn=min(n,m);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;l&lt;=maxn;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=min(n/(n/l),m/(m/l));</span><br><span class="line">        ans+=(sum[r]-sum[l<span class="number">-1</span>])*(n/l)*(m/l);</span><br><span class="line">    &#125;<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,n,m;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,F(n,m));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces Round 698(Div.2)</title>
    <url>/codeforcesR698/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>（其实是吐槽<br>昨天比赛刚开始换了三次网，换了两次镜像网站才勉强能看到题…<br>游戏体验极差，而且最后还掉了一点分。</p>
<a id="more"></a>
<h2 id="A-Nezzar-and-Colorful-Balls"><a href="#A-Nezzar-and-Colorful-Balls" class="headerlink" title="A.Nezzar and Colorful Balls"></a>A.Nezzar and Colorful Balls</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3OC9wcm9ibGVtL0E=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定 n 个球，每个球上有一个数字 a ，现在为每个球染色，要使得相同颜色球上的数组 a 是严格递增的，且 a 数组是递增的，求最小颜色数。</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>其实即 a 数组中出现次数最多的次数。<br>证明、代码略。</p>
<h2 id="B-Nezzar-and-Lucky-Number"><a href="#B-Nezzar-and-Lucky-Number" class="headerlink" title="B.Nezzar and Lucky Number"></a>B.Nezzar and Lucky Number</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3OC9wcm9ibGVtL0I=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个整数 $d(d\in[1,9])$ ，称一个数字为幸运数字当且仅当这个数字是正整数且至少有一位是 d ，给出 n 个数，对于每个数如果能由若干个幸运数字相加得到，则输出”YES”，否则输出”NO”。</p>
<h3 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h3><p>我是真没想到这又是一场猜结论场…<br>（是我很菜，所以不能及时推出结论…</p>
<ul>
<li>若 $x \geq 10*d$ ，则一定是 YES<br/><br>如果$x\in[10*d,11*d)$，则是 YES<br/><br>如果$x\geq 11*d$，则减去若干个 d 后必定能得到$x’\in[10*d,11*d)$，则是 YES <br/></li>
<li>若 $x &lt; 10* d$<br>此时暴力判断即可，最简单的判断方式就是 x 减去若干个 d ，判断个位是否为 0 ，因为十位可以任取所以可以不管，如果个位为 0 则一定可以。</li>
</ul>
<p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> q,d;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;q,&amp;d);</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">10</span>*d)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">bool</span> f=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(x&gt;=j*d&amp;&amp;((x-j*d)%<span class="number">10</span>==<span class="number">0</span>))&#123;</span><br><span class="line">                        f=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(f)<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="C-Nezzar-and-Symmetric-Array"><a href="#C-Nezzar-and-Symmetric-Array" class="headerlink" title="C.Nezzar and Symmetric Array"></a>C.Nezzar and Symmetric Array</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3OC9wcm9ibGVtL0M=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>某数组有 2*n 个互不相同的数，每个数都能在数组中找到一个相反数。<br>令$d_i=\sum_{j=1}^{2n}|a_i-a_j|$，现在给了你数组 d ，试判断是否存在至少一种可能的原数组 a 。</p>
<h3 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h3><p>前四题三个数学题…<br>首先互不相同且能找出相反数，可以得到不能有 0 ，如果仅存在一个 0 ，则 必定有一个数在原数组中无相反数。<br>然后我们将 a 数组从大到小排序，则前 n 个是正数，后 n 个是负数，并且因为从大到小排序，可以得到：</p>
<script type="math/tex; mode=display">
d_{i}=(a_1-a_i)+(a_2-a_i)+...+(a_i-a_i)+(a_i-a_{i+1})+(a_i-a_{i+2})...+(a_i-a_{2n})</script><p>然后根据相反数的条件，继续化简得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
d_{i}&=(a_1-a_i)+...+(a_i-a_i)+(a_i-a_{i+1})...+(a_i-a_{n})+(a_i+a_{n})+(a_i+a_{n-1})...+(a_i+a_1) \\
&=2(a_1+a_2+...+a_i)+(2n-2i)a_i
\end{aligned}</script><p>因为原数组从大到小排序了，则 d 应该是先递减后递增，且$d_{i}=d_{2<em>n-i+1}$<br/><br>为了方便，直接将 d 从小到大排序或者从大到小排序然后每两个判断下是否相同，即初步判断是否合法。<br>然后根据上述的式子推出原数组即可，例如 $2n\</em>a_1=d_1$ ，然后后面的做差即可求出。<br>我当时脑子有点乱，所以代码写的有点乱…<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[N],a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;d[i]);</span><br><span class="line">        sort(d+<span class="number">1</span>,d+<span class="number">2</span>*n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">bool</span> f=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i]!=d[i+<span class="number">1</span>])&#123;</span><br><span class="line">                f=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(d[<span class="number">2</span>*n]%(<span class="number">2</span>*n)!=<span class="number">0</span>||d[<span class="number">2</span>*n]==<span class="number">0</span>)f=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[n]=d[<span class="number">2</span>*n]/(<span class="number">2</span>*n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=n-i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> p=(<span class="number">2</span>*n<span class="number">-2</span>*j+<span class="number">2</span>)*a[i+<span class="number">1</span>]+d[<span class="number">2</span>*i]-d[<span class="number">2</span>*(i+<span class="number">1</span>)];</span><br><span class="line">            <span class="keyword">if</span>(p%(<span class="number">2</span>*n<span class="number">-2</span>*j+<span class="number">2</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">                f=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a[i]=p/(<span class="number">2</span>*n<span class="number">-2</span>*j+<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(!a[i]||a[i]==a[i+<span class="number">1</span>]||a[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                f=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="D-Nezzar-and-Board"><a href="#D-Nezzar-and-Board" class="headerlink" title="D.Nezzar and Board"></a>D.Nezzar and Board</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3OC9wcm9ibGVtL0Q=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给出 n 个数，每次任选两个数 x , y ，并向数组中加一个数 2x - y ，问是否能得到 k </p>
<h3 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h3><ol>
<li>若 n = 2 ，则可以得到的数是 x + k ( x - y ) ，即得到的数相差均为 ( x - y ) 的倍数，并且 x 和 y 均在得到的数中（这不是废话么</li>
<li>若 n = 3 ，任意取一个前两个数能得到的数 o ，则可以得到所有和 o 相差 x - y 和 z - o （z为第三个数）的数，然后这些数相差最小为 gcd( x - y , z - o )，既可以得到所有和 o 相差 gcd( x - y , z - o )的数<br>然后 o 随便取都行，只要是前两个数能得到的数即可，反正最后不会影响 gcd 的取值</li>
<li>n 无限制，即求出查分数组的 gcd ，然后判断 gcd 是否能整除 $k-a_1$即可。</li>
</ol>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;<span class="keyword">return</span> !b?a:gcd(b,a%b);&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;n ,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> GCD=<span class="built_in">abs</span>(a[<span class="number">2</span>]-a[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;++i)</span><br><span class="line">            GCD=gcd(GCD,<span class="built_in">abs</span>(a[i]-a[i<span class="number">-1</span>]));</span><br><span class="line">        <span class="keyword">if</span>((k-a[<span class="number">1</span>])%GCD==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>cf比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces美化</title>
    <url>/codeforces%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<p>谷歌浏览器的codeforces美化方法。</p>
<a id="more"></a>
<p>点击谷歌浏览器右上角自定义及控制（竖着的三个点）<br><img data-src="https://tu.sunpma.com/imgs/2021/01/f4e7104bfe4762d7.png" alt=""><br>点击更多工具并进入扩展程序<br><img data-src="https://tu.sunpma.com/imgs/2021/01/17a05f81538ff962.png" alt=""><br>点击左上角扩展程序并点击弹出的窗口下面的“打开Chrome网上商店”<br><img data-src="https://tu.sunpma.com/imgs/2021/01/f3265b52ed36e54c.png" alt=""><br><img data-src="https://tu.sunpma.com/imgs/2021/01/649074f270b6af0f.png" alt=""><br>在搜索框内搜索stylus<br><img data-src="https://tu.sunpma.com/imgs/2021/01/ab28eb144e5d21e1.png" alt=""><br>点击第一个并添加到Chrome</p>
<p><span class="exturl" data-url="aHR0cHM6Ly91c2Vyc3R5bGVzLm9yZy9zdHlsZXMvMTkxNjY1L2NvZGVmb3JjZXM=">下载codeforces美化脚本<i class="fa fa-external-link-alt"></i></span></p>
<p>(可能会比较慢)</p>
<p>脚本有一个开启/关闭顶栏动画可选。</p>
<p>Customize Settings中选择turn off即可关闭顶栏动画。（顶栏动画为动态）</p>
<p>这里还有个wusoj的美化脚本（wustoj是武汉科技大学的OJ）<br><span class="exturl" data-url="aHR0cHM6Ly91c2Vyc3R5bGVzLm9yZy9zdHlsZXMvMTkwNDcxL3d1c3Rvag==">wustoj美化脚本<i class="fa fa-external-link-alt"></i></span></p>
<p>为了方便起见，可以固定该扩展<br><img data-src="https://tu.sunpma.com/imgs/2021/01/c86897a69b90d969.png" alt=""></p>
<p>如果想取消某个网站的所有脚本<br><img data-src="https://tu.sunpma.com/imgs/2021/01/3614a2eda352e992.png" alt=""></p>
<p>如果想更换脚本或者更新脚本请在管理样式界面操作。</p>
]]></content>
      <tags>
        <tag>网站美化</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 99</title>
    <url>/codeforcesECR99/</url>
    <content><![CDATA[<h2 id="A-Strange-Functions"><a href="#A-Strange-Functions" class="headerlink" title="A. Strange Functions"></a>A. Strange Functions</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ1NS9wcm9ibGVtL0E=">题目链接<i class="fa fa-external-link-alt"></i></span><br>题意:g(x)定义为$\frac{x}{f(f(x))}$(f(x)表示将x翻转后的数),例如f(10)=1,对于给定的n求出1~n中有多少不同的g(x)<br>题解:<br>即n的长度数<br><a id="more"></a></p>
<h2 id="B-Jumps"><a href="#B-Jumps" class="headerlink" title="B. Jumps"></a>B. Jumps</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ1NS9wcm9ibGVtL0I=">题目链接<i class="fa fa-external-link-alt"></i></span><br>题意:初始在0,第k次可以选择+k或者-1,问到达n的最小次数<br>题解:<br>对于<script type="math/tex">\frac{n*(n+1)}{2}</script>,即为n次<br><br>对于这n次中任意一次变成-1,可以得到<script type="math/tex">\frac{(n-1)*n}{2}-1\sim\frac{n*(n+1)}{2}-1</script><br><br>令<script type="math/tex">F_{k}=\frac{k*(k+1)}{2}</script><br><br>则对于<script type="math/tex">n=F_{k}</script>,最小次数为k<br><br>对于<script type="math/tex">F_{k-1}\leq n\leq F_{k}-1</script>,最小次数为k<br><br>对于<script type="math/tex">n=F_{k}-1</script>,最小次数为k+1<br></p>
<h2 id="C-Ping-pong"><a href="#C-Ping-pong" class="headerlink" title="C. Ping-pong"></a>C. Ping-pong</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ1NS9wcm9ibGVtL0M=">题目链接<i class="fa fa-external-link-alt"></i></span><br>题意:详见题目<br>题解:<br>因为只是最大化自己的获胜次数<br>因此如果是Alice先手,Alice赢,则Bob必定不回球<br>如果是Alice先手,Bob赢,若Alice还能回球,则必定能降低Bob的获胜次数,因此这种情况不会发生<br>因此若输入为(n,m),输出(n-1,m)即可</p>
<h2 id="D-Sequence-and-Swaps"><a href="#D-Sequence-and-Swaps" class="headerlink" title="D.Sequence and Swaps"></a>D.Sequence and Swaps</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ1NS9wcm9ibGVtL0Q=">题目链接<i class="fa fa-external-link-alt"></i></span><br>题意:详见题目<br>题解:<br>否则对于<script type="math/tex">a_{i},a_{j}>x</script>,如果先把<script type="math/tex">a_{j}</script>替换成x,则<script type="math/tex">a_{i}</script>永远不可能小于等于x,因此每次都交换第一个符合的即可。<br>如果本身就是有序,则输出0<br>如果在交换若干次变成有序,则break并输出<br>如果交换后并非非递减,则break并输出-1即可</p>
<h2 id="E-F待填坑"><a href="#E-F待填坑" class="headerlink" title="E,F待填坑"></a>E,F待填坑</h2>]]></content>
      <tags>
        <tag>cf比赛</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 103 (Rated for Div. 2)</title>
    <url>/eduRound103/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我居然能在B题上因为 long long 和向上取整错四次…（人才<br>好在之后几题比较顺<br><a id="more"></a></p>
<h2 id="A-K-divisible-Sum"><a href="#A-K-divisible-Sum" class="headerlink" title="A. K-divisible Sum"></a>A. K-divisible Sum</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE0NzYvcHJvYmxlbS9B">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给出 n 和 k ，你要构造一个 n 个元素的数组 a ，a 所有元素的和可以被 k 整除，求出 a 最大元素最小可能是多少。</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>假设 a 中最大元素是 MAX ，则可以得到的数是 $MAX+n-1\sim n*MAX$<br/></p>
<ul>
<li>$k\geq n$时，找到最小的MAX使得$n*MAX\geq k$即可，即$\lceil\frac{k}{n}\rceil$<br/></li>
<li>$k &lt; n$时，如果$n\%k=0$则 MAX = 1 即可满足题意，如果$n\%k\neq 0$，当 MAX = 2 时，可以得到$n+1 \sim 2n$，必定存在一个数能被 k 整除。</li>
</ul>
<p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x,T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(n&gt;x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%x==<span class="number">0</span>)</span><br><span class="line">            	<span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            	<span class="built_in">printf</span>(<span class="string">&quot;2\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x%n==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x/n);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x/n+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="B-Inflation"><a href="#B-Inflation" class="headerlink" title="B. Inflation"></a>B. Inflation</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE0NzYvcHJvYmxlbS9C">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个数组$p_0,p_1…p_{n-1}$，可以令每个$p_i$加上一个非负整数$a_i$，使得$\frac{p_i}{p_0+p_1+…+p_{i-1}}\leq k\%$，要求$\sum_{i=0}^{n-1}a_i$的最小值。</p>
<h3 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h3><p>这题我花了23分钟，还错了4次…<br>这题是贪心，结论其实可以直接猜出来。<br>我们从前往后处理每个数，如果$\frac{p_i}{p_0+p_1+…+p_{i-1}} &gt; k\%$，则将$p_i$加到使得$\frac{p_i}{p_0+p_1+…+p_{i-1}} \leq k\%$，顺便更新答案即可。<br/><br>这样我们确实前面的是最小化了，但是能否保证后面也能最小化答案呢？<br>如果 $\frac{x}{y}=\frac{k}{100}$ ，则当 y 变化 100 时， x 只变化 k <br/><br>我们假设我们贪心到 i 有 $\frac{p_i+a_i}{p_0+p_1+…+p_{i-1}+x}=\frac{k}{100}$ ，如果分母增大，则分子减少的小于等于分母增加的，因此不会更优，往后处理时均如此。<br/><br>因此这个贪心策略是正确的。</p>
<p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span>  T,n,k;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">105</span>],d[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> s=a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]*<span class="number">100ll</span>&gt;k*s)&#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> x=<span class="built_in">ceil</span>((<span class="number">100ll</span>*a[i]-k*s)*<span class="number">1.0</span>/k);</span><br><span class="line">                ans+=x;</span><br><span class="line">                s+=x;</span><br><span class="line">            &#125;</span><br><span class="line">            s+=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>那个向上取整其实可以用更好的写法，即$long long x=(100ll*a[i]+k-1)/k-s;$，这样避免了精度问题。</p>
<h2 id="C-Longest-Simple-Cycle"><a href="#C-Longest-Simple-Cycle" class="headerlink" title="C. Longest Simple Cycle"></a>C. Longest Simple Cycle</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE0NzYvcHJvYmxlbS9D">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给出 n 条链，每条链的首、尾与上一条链的两个点相连，请求出最大的简单环。<br><img data-src="https://espresso.codeforces.com/f5b742ef7ad02ab00141f54a6dda3eb9bc79d4d3.png" alt=""></p>
<h3 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h3><p>其实真的很简单。<br>我们设$dp_i$表示第 i 条链和在其之前的链构成的最大简单环的长度，则很显然第 i 条链要么通过与上一条链连接的两个点以及自己构成一个简单环，要么是通过与上一条链构成的最大简单环构成一个新的最大简单环（需要减去重复部分）<br>因此顺着这样求就行了，我为了简便书写就改了一点变量（感觉貌似更复杂了，服了我自己</p>
<p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T,n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,inf=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N],c[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">        dp[<span class="number">1</span>]=-inf;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            dp[i]=<span class="number">2</span>+<span class="built_in">abs</span>(a[i]-b[i]);</span><br><span class="line">            <span class="keyword">int</span> L=min(a[i],b[i]),R=max(a[i],b[i]);</span><br><span class="line">            <span class="keyword">if</span>(a[i]!=b[i])</span><br><span class="line">                dp[i]=max(dp[i],<span class="number">2</span>+dp[i<span class="number">-1</span>]+L<span class="number">-1</span>+c[i<span class="number">-1</span>]-R);</span><br><span class="line">            ans=max(ans,dp[i]+c[i]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="D-Journey"><a href="#D-Journey" class="headerlink" title="D. Journey"></a>D. Journey</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE0NzYvcHJvYmxlbS9E">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h3><p>n + 1 个城市，从 $0\sim n$<br/><br>给出一个长度为 n 的字符串，如果第 i 位是 L ，表示有一条从 i 到 i-1 的有向边；如果是 R ，表示有一条从 i-1 到 i 的有向边。<br>且每次经过一条边后所有边的朝向改变，对于每一个城市，求出以其为初始位置时能经过的最多城市数。</p>
<h3 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h3><p>每次朝向会改变，我想都没想直接以时间点为奇数/偶数拆点建图了，初始时间为 0 。<br>然后把样例手模一下，发现一个简单的并查集就能做了，因为每条边都是双向边，并且连接着的是相邻且时间奇偶性不同的连个点，这样一来既不会有一个城市既能在偶数时间点被访问又在奇数时间点被访问，而且因为双向可以互相到达。<br>那么其实缩点也可以做到，不过我这里为了代码书写起来简单直接写了个并查集，其他方法没想过了，反正我觉得拆点后可以秒出。</p>
<p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> fa[N&lt;&lt;<span class="number">1</span>],siz[N&lt;&lt;<span class="number">1</span>],T,n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=get(fa[x]);&#125;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x=get(x),y=get(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span>;</span><br><span class="line">    fa[x]=y;</span><br><span class="line">    siz[y]+=siz[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> c=<span class="number">2</span>*(n+<span class="number">1</span>),S=n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=c;++i)</span><br><span class="line">            fa[i]=i,siz[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">                link(i+<span class="number">1</span>,i+S);</span><br><span class="line">            <span class="keyword">else</span> link(i,i+<span class="number">1</span>+S);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=S;++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,siz[get(i)]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="E-Pattern-Matching"><a href="#E-Pattern-Matching" class="headerlink" title="E. Pattern Matching"></a>E. Pattern Matching</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE0NzYvcHJvYmxlbS9F">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="题目描述：-4"><a href="#题目描述：-4" class="headerlink" title="题目描述："></a>题目描述：</h3><p>见题目。</p>
<h3 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h3><p>想清楚就不难，但就是想不清楚，想出来后又觉得我当时为啥这么蠢。</p>
<p>其实每个字符串最多能匹配$2^4$个模式串，利用拓扑排序的方式即可，如果字符串能匹配 mt 模式串，则将 mt 模式串与其他所有该字符串能匹配的模式串连有向边（起点是 mt ）；如果不能匹配则说明无解。<br>之后拓扑排序即可的出答案。<br>然后就要考虑如何快速得到字符串能匹配到的所有模式串了，可以字典树或者map，具体就不细讲了。</p>
<p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> ch[N&lt;&lt;<span class="number">2</span>][<span class="number">27</span>],val[N&lt;&lt;<span class="number">2</span>],cnt;</span><br><span class="line"><span class="keyword">int</span> d[N&lt;&lt;<span class="number">1</span>],nxt[N&lt;&lt;<span class="number">4</span>],to[N&lt;&lt;<span class="number">4</span>],tot;</span><br><span class="line"><span class="keyword">int</span> deg[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="keyword">int</span> ans[N&lt;&lt;<span class="number">1</span>],ans2[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    to[++tot]=b;</span><br><span class="line">    nxt[tot]=d[a];</span><br><span class="line">    d[a]=tot;</span><br><span class="line">    ++deg[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>*s,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;_&#x27;</span>)j=<span class="number">26</span>;</span><br><span class="line">        <span class="keyword">else</span> j=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ch[p][j])ch[p][j]=++cnt;</span><br><span class="line">        p=ch[p][j];</span><br><span class="line">    &#125;</span><br><span class="line">    val[p]=id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> f;</span><br><span class="line"><span class="keyword">bool</span> g;</span><br><span class="line"><span class="keyword">int</span> num,mt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">char</span>*s,<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(now&gt;k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(val[p]==mt)&#123;</span><br><span class="line">            g=<span class="literal">true</span>;</span><br><span class="line">            ins(mt,num+n);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ins(num+n,val[p]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    work(ch[p][s[now]-<span class="string">&#x27;a&#x27;</span>],s,now+<span class="number">1</span>);</span><br><span class="line">    work(ch[p][<span class="number">26</span>],s,now+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>),insert(s,i);</span><br><span class="line">    f=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        num=i;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,s+<span class="number">1</span>,&amp;mt);</span><br><span class="line">        g=<span class="literal">false</span>;</span><br><span class="line">        work(<span class="number">1</span>,s,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!g)f=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!deg[i])</span><br><span class="line">            q.push(i);</span><br><span class="line">    &#125;<span class="keyword">int</span> Tim=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=n)</span><br><span class="line">            ans[x]=++Tim;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=d[x];i;i=nxt[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> u=to[i];</span><br><span class="line">            <span class="keyword">if</span>(--deg[u]==<span class="number">0</span>)q.push(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(deg[i])&#123;</span><br><span class="line">            f=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(!ans[i])</span><br><span class="line">            ans[i]=++Tim;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        ans2[ans[i]]=i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans2[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>cf比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round#694 (Div. 2)</title>
    <url>/codeforcesR694/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3MQ==">比赛链接<i class="fa fa-external-link-alt"></i></span></p>
<a id="more"></a>
<h2 id="A-Strange-Partition"><a href="#A-Strange-Partition" class="headerlink" title="A.Strange Partition"></a>A.Strange Partition</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3MS9wcm9ibGVtL0E=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题目描述：给定长度为n的数组，可以任意次合并相邻元素，假设合并后长度为k，求$\sum_{i=1}^{k}{\lceil\frac{a_i}{k}\rceil}$的最小值和最大值。</p>
<p>题解：<br>简单的贪心。<br>很显然，当不合并时最大，当所有的合并时最小，这是因为可以证明任意合并两个变成一个后一定不会比不合并的更大，因此得证。</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> T,n,x;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s1,s2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        s1=s2=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;x);</span><br><span class="line">        <span class="keyword">int</span> p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p);</span><br><span class="line">            <span class="keyword">if</span>(p%x==<span class="number">0</span>)</span><br><span class="line">                s1+=p/x;</span><br><span class="line">            <span class="keyword">else</span> s1+=p/x+<span class="number">1</span>;</span><br><span class="line">            s2+=p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s2%x==<span class="number">0</span>)s2/=x;</span><br><span class="line">        <span class="keyword">else</span> s2=s2/x+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>,s2,s1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="B-Strange-List"><a href="#B-Strange-List" class="headerlink" title="B.Strange List"></a>B.Strange List</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3MS9wcm9ibGVtL0E=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题目描述：<br>给定n个元素的数组，从左到右，假设当前元素是q，如果x可以整除q，则在数组末尾增加x个$\frac{q}{x}$，如果x不可以整除q，则停止。<br/><br>问最终所有元素的和。</p>
<p>题解：<br>实际上如果q可以被x整除，则总和加上q，且如果$\frac{q}{x}$可以被x整除，总和仍然是加上q。<br>因此就简单了，因为x至少为2，则每个数最多被加上$log_{2}{n}$，这样纯模拟就行了，不过也可以稍作优化。<br>即记下每个数最多可以整除x的多少次方，取所有中最小的，假设都能被$x^k$整除，则接下来只有模拟至多n次。<br>复杂度就可以从$O(nlogn)$降低到$O(n)$</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,x;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> cnt[N],a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;x);</span><br><span class="line">        cnt[<span class="number">0</span>]=<span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">            <span class="keyword">int</span> p=a[i];</span><br><span class="line">            cnt[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(p%x==<span class="number">0</span>)&#123;</span><br><span class="line">                ++cnt[i];</span><br><span class="line">                p/=x;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[i]=min(cnt[i],cnt[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            cnt[i]=min(cnt[i],cnt[n]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            ans+=a[i]*<span class="number">1ll</span>*cnt[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="C-Strange-Birthday-Party"><a href="#C-Strange-Birthday-Party" class="headerlink" title="C.Strange Birthday Party"></a>C.Strange Birthday Party</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3MS9wcm9ibGVtL0M=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题目描述：<br>略。</p>
<p>题解：<br>题目中有个很关键的条件，<del>结果我半天没看到</del></p>
<p>考虑 ( i , j ) ，假设 i 选的是$c_a$， j 选的是$c_b$，且$b\geq a$，$a\leq k_i,b\leq k_j$<br/><br>$\because c_1\leq c_2\leq c_3…\leq c_n$<br/><br>1.当$b\leq k_i$时，$c_a+c_b \leq c_b+c_a$，即交换后不变。<br/><br>2.当$b&gt; k_i$时，且$k_i$内还有未选的时，将$c_b$换成$k_i$内未选的更优，此时情况转化为第一种。<br/><br>3.当$b&gt; k_i$时，且$k_i$内已满时，将$c_b$换成$c_a$，将$c_a$换成$c_{k_i}$更优。<br/><br>因此可以得到一个贪心策略，即序号大的优先选择较小的 c ，且必定从c的第一个开始连续取，否则总能变得更优。<br>可能说的不是很清楚，看代码吧。</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> T,n,m;</span><br><span class="line"><span class="keyword">int</span> k[N];</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&gt;b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]);</span><br><span class="line">        sort(k+<span class="number">1</span>,k+<span class="number">1</span>+n,cmp);</span><br><span class="line">        <span class="keyword">int</span> fir=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k[i]&gt;=fir)</span><br><span class="line">                ans+=c[fir++];</span><br><span class="line">            <span class="keyword">else</span> ans+=c[k[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

]]></content>
      <tags>
        <tag>cf比赛</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>wust菜鸟杯题目&amp;题解</title>
    <url>/wust%E8%8F%9C%E9%B8%9F%E6%9D%AF%E9%A2%98%E7%9B%AE-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>如果有想看详细题目却没有纸质文件的，可以找有纸质文件的人。</p>
<h2 id="A-mqy爱回文串"><a href="#A-mqy爱回文串" class="headerlink" title="A.mqy爱回文串"></a>A.mqy爱回文串</h2><p>题目描述：<br>给定<script type="math/tex">T</script>个长度为<script type="math/tex">n</script>的字符串，要求你判断是否为回文串（从左到右和从右到左相同的字符串），若是则输出<script type="math/tex">1</script>，否则输出<script type="math/tex">0</script>。</p>
<a id="more"></a>
<p>题解：<br>签到题。你可以就直接比较从左到右和从右到左的这两个字符串是否相同，当然这个可以不同新建一个字符串实现，只要判断从左到右的第<script type="math/tex">i</script>个字符是否等于从右到左的第<script type="math/tex">i</script>个字符即可，如果全部相同则是，否则不是。</p>
<p>对于回文串，其实只用比较一半的长度即可，当长度为偶数时很显然，当长度为奇数时中间一个字符就等于它本身。</p>
<h2 id="B-拳王mqy"><a href="#B-拳王mqy" class="headerlink" title="B.拳王mqy"></a>B.拳王mqy</h2><p>题目描述：<br>给定<script type="math/tex">N</script>个数<script type="math/tex">a_1,a_2...a_N</script>，<script type="math/tex">Q</script>组询问<script type="math/tex">[L,R]</script>,求<script type="math/tex">a_{L}+a_{L+1}+...+a_{R}</script>。</p>
<script type="math/tex; mode=display">1\leq N,Q\leq 1000000</script><p>题解：<br>我估计很多人是超时了，超时的人大多是没学过时间复杂度吧，关于时间复杂度的详细解读请看下图（源自数据结构与算法分析，这本书较难，不要轻易尝试），后面会涉及到复杂度，不会再做解释，建议仔细看看这里的详解。<br><img data-src="https://s3.ax1x.com/2020/12/06/DjO7zd.md.jpg" alt=""><br><img data-src="https://s3.ax1x.com/2020/12/06/DjO7zd.md.jpg" alt=""><br>计算机每秒计算次数在<script type="math/tex">10^8\sim 5*10^8</script>之间。<br>超时的人，你们可以算算自己的最坏时间复杂度为多少，会不会超时。<br>正解是维护前缀和。前缀和很常用的，适用于静态的不会改变的求区间问题。<br>例如这题，求<script type="math/tex">a_{L}+a_{L+1}+...+a_{R}</script>，那么我只需要用<script type="math/tex">(a_{1}+a_{2}+...a_{R})-(a_1+a_2+...a_{L-1})</script>，我令<script type="math/tex">s[i]=a_1+a_2+...+a_i</script>，这样每次答案就是输出<script type="math/tex">s_R-s_{L-1}</script>。<br>但是如果我能修改其中的数呢？这样子每次修改一个<script type="math/tex">a_i</script>会修改很多的<script type="math/tex">s</script>，前缀和就不使用了，就需要用到树状数组或者线段树，感兴趣的可以学学前缀和做几道题后再学学树状数组、线段树。</p>
<h2 id="C-mqy的女装"><a href="#C-mqy的女装" class="headerlink" title="C.mqy的女装"></a>C.mqy的女装</h2><p>题目描述：<br>有一个村庄的村民不能相互交流，也看不到自己的着装，但每一天早晨，他们都能看到<strong>除自己外</strong>的其他人的着装。<br>有一天有个旅行家告诉他们有人穿了女装，但没说多少人，也没指出是谁就走了。<br>该村村民都很聪明，如果他们能根据已有线索推出自己穿着女装，他们就会在当天下午脱下女装。<br>如果将旅行家来的第一天当做第一天，mqy想知道自己是哪一天脱下的女装。<br>输入n,m分别为村民个数和女装大佬个数。<br>题解：<br>注意到在任何一个女装大佬眼里看到的都一样，因此如果有一个人判断出了自己就是，那么应该所有女装的都能判断出来。<br>假设我现在就是其中一个女装大佬，我看到有k个人女装了。<br>我现在如果认为我不是女装大佬，并且k个人女装应该在第f(k)天全部脱下女装，如果在第f(k)+1天我看到他们均没有脱下女装，那么这与我不是相违背，即我能判断出我一定是一个女装大佬。<br>事实上村民个数无关紧要，如果m=1，那么答案很简单就是1，因为唯一的那个看到别人都不是，那么自己肯定是。<br>如果m=2,因为mqy只看到1个女装，但是那个人第二天还在穿女装(女装只有1次和无数次！)，那么说明肯定自己也是。<br>同理m=3,因为mqy看到3个女装，如果自己不是，应该第三天就都不是女装了，但实际不然，所以可以判断自己是女装。<br>因此我们可以得出结论，输出m即可。<br>思维题，比较有趣。</p>
<h2 id="D-mqy与地下城"><a href="#D-mqy与地下城" class="headerlink" title="D.mqy与地下城"></a>D.mqy与地下城</h2><p>题目描述：<br>输入一个<script type="math/tex">n</script>，判断是否是素数。</p>
<p>题解：<br>这题<script type="math/tex">n<10^6</script>,因此暴力<script type="math/tex">2\sim i</script>都可以过，如果存在<script type="math/tex">n\%i==0</script>，说明不是素数，否则是素数。<br>拓展：考试确实要以最快的方法优先，怎样你觉得写得快并且能过就怎样写，但是考完了就要想是否能有更好的方法？<br>我们如果对于n分解质因数，那么实际上n的最大质因数超过<script type="math/tex">\sqrt{n}</script>的不会超过1个，如果超过了1个，则乘起来必定大于n。<br>如果n是素数，那么分解除的素数就是n本身;如果n不是素数，则分解出来的素数个数至少是2个，且因为超过<script type="math/tex">\sqrt{n}</script>的至多一个，则我们必定能在<script type="math/tex">2\sim \sqrt{n}</script>之内找到一个数能整除n<br>因此我们只用判断<script type="math/tex">\sqrt{n}</script>以内的即可。(注意：不要从1开始，且1，2要特判)<br>这样时间复杂度是<script type="math/tex">O(\sqrt{n})</script><br>下次即便将n开到<script type="math/tex">10^{12}</script>你都可以过。</p>
<h2 id="E-mqy去军训"><a href="#E-mqy去军训" class="headerlink" title="E.mqy去军训"></a>E.mqy去军训</h2><p>题目描述：<br>给定一个字符串，求出其中有多少个<script type="math/tex">"MQY"</script>(这里的MQY不一定需要连续，只要是M出现在Q前，Y出现在Q后即可)</p>
<p>题解：<br>还记得第二题的前缀和吗，因为只要M在Q前，Y在Q后即可，那么我们不妨对于每一个Q，找出他前面的所有的M个数为q，他后面所有的Y为w，则ans+=q*w即可。<br>另一种做法（此方法不要求掌握，但能理解更好）就是我记一个二维数组<script type="math/tex">dp[i][j]</script>，<script type="math/tex">dp[i][0]</script>表示前i个字符中空串的个数(实际上一直为1)，<script type="math/tex">dp[i][1]</script>表示前<script type="math/tex">i</script>个字符中<script type="math/tex">"M"</script>出现个数，<script type="math/tex">dp[i][2]</script>表示前i个字符中<script type="math/tex">"MQ"</script>出现个数,<script type="math/tex">dp[i][3]</script>表示前i个字符中<script type="math/tex">"MQY"</script>出现个数。</p>
<p>对于第i个位置，有</p>
<script type="math/tex; mode=display">
dp[i][0]=dp[i-1][0],dp[i][1]=dp[i-1][1],
dp[i][2]=dp[i-1][2],dp[i][3]=dp[i-1][3]</script><p>即不考虑当前字符时答案。</p>
<p>之后考虑当前位置的字符，如果是‘M’,前面的空串加上’M’构成了”M”，则<script type="math/tex">dp[i][1]+=dp[i-1][0]</script>；如果是’Q’，前面的”M”加上’Q’变成”MQ”，则<script type="math/tex">dp[i][2]+=dp[i-1][1]</script>；如果是’Y’，前面的”MQ”加上’Y’变成”MQY”，则<script type="math/tex">dp[i][3]+=dp[i-1][2]</script>。<br>最后答案显然就是<script type="math/tex">dp[n][3]</script>。在这样递推前注意<script type="math/tex">dp[0][0]=1,dp[0][1]=dp[0][2]=dp[0][3]=0</script> 这个根据定义不难解释。</p>
<h2 id="F-mqy拯救世界"><a href="#F-mqy拯救世界" class="headerlink" title="F.mqy拯救世界"></a>F.mqy拯救世界</h2><p>题目描述：<br>$A\sim J$表示$0\sim 9$，给定一个由$A\sim J$构成的字符串，设number为这个字符串代表的数字，求[1,number]中所有数字代表的字符串中H出现的次数。</p>
<p>题解：<br>题目听迷惑人的，什么字符串转数字啊，数字转字符串啊，实际上这题很友好，是十进制，就比较好做了，不妨求出number先(这个不用讲吧)</p>
<p>然后就是找出[1,number]中所有数字7出现的次数嘛。</p>
<h2 id="G-mqy开运动会"><a href="#G-mqy开运动会" class="headerlink" title="G.mqy开运动会"></a>G.mqy开运动会</h2><p>题目描述：<br>计院要派出4个人参加4*100m接力赛，其中2人只跑直道，另外2人只跑弯道，先给出n个人每个人跑直道和弯道的速度(单位:m/s)</p>
<script type="math/tex; mode=display">n\leq 100</script><p>题解：<br>注意到n很小，我们直接从100个人出取出4个人即可，这样总共<script type="math/tex">C(n,4)</script>次，然后选出4人要计算4次，这样绝对是不会超时的。（dfs或者四层for都行）</p>
<p>但是这种做法在n=1000或者更大就会超时了，毕竟<script type="math/tex">n^4</script>就是<script type="math/tex">10^{12}</script>了。</p>
<p>假如我们只需要选出4个直道，那么我们按照直道速度从大到小排序，选出其中4个即可；弯道同理。<br>对于选出两个直道，两个弯道，我们不妨将直道前4和弯道前4选出来，我们可以证明最优解不会是既不是直道前4又不是弯道前4的。<br>假设存在这样一个人wjr是既不是直道前4，又不是弯道前4，则直道和弯道中至少都剩下一个人可以选，当且仅当其余三个人都是直道和弯道前4时是直道和弯道都剩1个人可以选，其余情况都会有更多可以选的。<br>如果wjr是直道的，直道还剩下至少一人可以选，我们不妨将wjr换成那个可以选的；弯道同理。<br>因此这样就可以把题目变成在直道前4<strong>或者</strong>弯道前4的最多8个人中选4个出来(既是直道前4又是弯道前4算一人)<br>然后n就算很大也可以很快做出来。</p>
<h2 id="H-mqy和DP"><a href="#H-mqy和DP" class="headerlink" title="H.mqy和DP"></a>H.mqy和DP</h2><p>题目描述：<br>mqy给了你一段代码，让你帮他求出结果。</p>
<p>题解：<br>注意到原代码复杂度是<script type="math/tex">O(T*n^2)</script>，直接将代码交上去肯定是过不了的，我们要想出更快的方法来做。<br>我们假设考虑每个<script type="math/tex">dp[i][j]</script>对答案的贡献(常用思想)</p>
<script type="math/tex; mode=display">dp[n][1]:1</script><script type="math/tex; mode=display">dp[n-1][1]:1\ dp[n-1][2]:1</script><script type="math/tex; mode=display">dp[n-2][1]:1\ dp[n-2][2]:2\ dp[n-2][3]:1</script><script type="math/tex; mode=display">dp[n-3][1]:1\ dp[n-3][2]:3\ dp[n-3][3]:3\ dp[n-3][4]:1</script><p>…</p>
<p>这个是怎么算出来的呢？我们考虑dp[i][j]会被哪些数加起来，可以发现<script type="math/tex">dp[i+1][j]=dp[i][j]+dp[i][j+1],dp[i+1][j-1]=dp[i][j-1]+dp[i][j]</script></p>
<p>设<script type="math/tex">dp[i][j]</script>被加了<script type="math/tex">f[i][j]</script>次</p>
<p>这样<script type="math/tex">dp[i][j]</script>在<script type="math/tex">dp[i+1][j]</script>和<script type="math/tex">dp[i+1][j-1]</script>都被算了一次，即<script type="math/tex">dp[i][j]</script>算了<script type="math/tex">f[i+1][j-1]+f[i+1][j]</script>次，即<script type="math/tex">f[i][j]=f[i+1][j-1]+f[i+1][j]</script><br>这个式子看着和<script type="math/tex">C(i,j)=C(i-1,j-1)+C(i-1,j)</script>很像吧？<br>其实最后很容易就能求出来<script type="math/tex">f[1][1]=C(n-1,1),f[1][2]=C(n-1,2),f[1][i]=C(n-1,i)</script><br>最后就是求<script type="math/tex">(\sum_{i=1}^{n}A[i]*f[1][i]) \% 2</script></p>
<p><script type="math/tex">C(n,i)=\frac{n!}{i!(n-i)!}</script>，这样我们不妨求出<script type="math/tex">pr2[i]</script>表示i分解质因数后有多少个2，如果<script type="math/tex">pr2[n]-pr2[i]-pr2[n-i]==0</script>说明<script type="math/tex">C(n,i)</script>是奇数，否则就是偶数，这样对2取模后也能知道为多少。</p>
<p>预处理下<script type="math/tex">pr2</script>，然后对于每组询问<script type="math/tex">O(n)</script>，总时间复杂度为<script type="math/tex">O(T*n)</script>。</p>
<h2 id="I-mqy劝你耗子尾汁"><a href="#I-mqy劝你耗子尾汁" class="headerlink" title="I.mqy劝你耗子尾汁"></a>I.mqy劝你耗子尾汁</h2><p>题目描述：<br>出题人不讲武德，来骗，来偷袭。逆序输出害死多少人。 </p>
<p>这题就是给了十个问题，让你逆序输出答案。<br>题解：<br>无</p>
<h2 id="J-mqy和高木同学"><a href="#J-mqy和高木同学" class="headerlink" title="J.mqy和高木同学"></a>J.mqy和高木同学</h2><p>题目描述：<br>mqy又双叒叕被高木骗了，他现在要点5个菜，每个菜有一个上菜时间，并且他只能在10的倍数分钟(如0，10，20，30…)点菜，请问这5个菜最早上完的时间。</p>
<p>题解：<br>因为只能在10的倍数分钟点菜，假设点的菜上菜时间为x，当前是在10*k分钟点菜<br>1.x是10的倍数，则下次是10*k+x分钟才能点菜，间隔了x分钟。<br>2.x不是10的倍数，则下次是10*k+int(x/10+1)*10分钟才能点菜，间隔int(x/10+1)*10分钟。</p>
<p>当且仅当最后一次点菜时，间隔时间始终是x，非最后一次点菜，下一次点菜与这一次间隔时间是个定值，，所以其实我只要最后一次点的菜%10最小就行了。(说白了前4个菜无论啥顺序时间都一样)</p>
<h2 id="K-mqy爱数数"><a href="#K-mqy爱数数" class="headerlink" title="K.mqy爱数数"></a>K.mqy爱数数</h2><p>题目描述：<br>给了一个’#’构成的WUSTACM图样，求图中’#’个数对(11/(45-1)*4)取模的结果。</p>
<p>题解：<br>这题hhh，有多少人是没注意到模数是1就数了的，有的举个爪。(我第一次看也是看成这样了，然后果然跳了)<br>任何整数对1取模都是0，然后输出0就行。</p>
<p>什么？你问如果模数不是1咋办？<del>那就数呗，分数不要白不要</del>。<br>其实你可以将这个图读入进来(复制粘贴)，然后你自己写个数’#’的，这样肯定比你数快一些吧(这次我没试过，不知道行不行，反正大多数情况这种题就是这样吧)</p>
<h2 id="L-欢乐时光开始了"><a href="#L-欢乐时光开始了" class="headerlink" title="L.欢乐时光开始了"></a>L.欢乐时光开始了</h2><p>题目描述：<br>输出”Hello WUST’ACM”</p>
<p>题解：<br><del>你送分的样子很帅，但你把这题放到最后的样子真的很狼狈</del></p>
<p>题外话：评论区资瓷 昵称输入QQ号自动变成QQ昵称和QQ头像，以及资瓷500个左右的b站表情包，欢迎评论！</p>
]]></content>
  </entry>
  <entry>
    <title>二维hash</title>
    <url>/%E4%BA%8C%E7%BB%B4hash/</url>
    <content><![CDATA[<p>设sum[i][j]表示左上角为(1,1)，右下角为(i,j)的hash值，mod为模数。<br><a id="more"></a><br>则</p>
<script type="math/tex; mode=display">sum[i][j]=(a[i][j]+sum[i-1][j-1]*base1*base2+sum[i-1][j]*base1+sum[i][j-1]*base2)\%mod</script><p>即可。<br>求左上角为(A,B)，右下角为(C,D)的hash值：</p>
<script type="math/tex; mode=display">
return (sum[C][D]+sum[A][B]*base1^{C-A}*base2^{D-B}-sum[A][D]*base1^{C-A}-sum[C][B]*base2^{D-B}+mod)\%mod;</script><p>和二维前缀和及其相似。<br>细节未处理，比如可能会溢出。<br>mod可以取1e9+7,base1和base2可以取孪生素数。</p>
]]></content>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>合并回文子串</title>
    <url>/%E5%90%88%E5%B9%B6%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>经典的回文串相关的 DP 题，理解了如何用$O(n^2)$求解回文串，这题会比较简单。</p>
<a id="more"></a>
<p>对于求解最长回文串，可以用复杂度为$O(n)$的 Manacher 算法，或者回文自动机，但是此题只需要 DP 即可。<br>对于 DP 求解回文串，记 dp[i][j] 为 i 到 j 是否是回文串即可，转移很简单，当 s[i] == s[j] 时 dp[i][j] = dp[i+1][j-1] 即可<br>如果 i+1 到 j-1 是回文串，则 i 到 j 也是回文串，反之则不是。</p>
<p>此题有两个字符串，但其实 DP 只用略微修改即可<br>因为合并出的字符串中连续的一段必定是原来的分别来自两个字符串中连续的一段合并而来的（可以为空）<br>这样的话用个四维 dp 即可，记 dp[i][j][k][l] 表示第一个串 i 到 j 和第二个串 k 到 l 构成的串是否能是回文串<br>此时注意，转移有四种，转移：</p>
<script type="math/tex; mode=display">
\begin{aligned}
dp[i][j][k][l]|=dp[i+1][j-1][k][l]\;(s[i]==s[j]) \\
dp[i][j][k][l]|=dp[i+1][j][k][l-1]\;(s[i]==g[l]) \\
dp[i][j][k][l]|=dp[i][j-1][k+1][l]\;(s[j]==g[k]) \\
dp[i][j][k][l]|=dp[i][j][k+1][l-1]\;(g[k]==g[l])
\end{aligned}</script><p>若某个 dp[i][j][k][l] 为 1 ，则说明这是一个回文串，更新下答案即可。</p>
<p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">52</span>;</span><br><span class="line"><span class="keyword">char</span> s[N], g[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][N][N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s + <span class="number">1</span>, g + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), m = <span class="built_in">strlen</span>(g + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l + i - <span class="number">1</span> &lt;= n; ++l) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = l + i - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">1</span>; L + j - <span class="number">1</span> &lt;= m; ++L) &#123;</span><br><span class="line">                        <span class="keyword">int</span> R = L + j - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (i + j &lt;= <span class="number">1</span>)</span><br><span class="line">                            dp[l][r][L][R] = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            dp[l][r][L][R] = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">if</span> (s[l] == s[r])dp[l][r][L][R] |= dp[l + <span class="number">1</span>][r - <span class="number">1</span>][L][R];</span><br><span class="line">                            <span class="keyword">if</span> (s[l] == g[R])dp[l][r][L][R] |= dp[l + <span class="number">1</span>][r][L][R - <span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span> (g[L] == s[r])dp[l][r][L][R] |= dp[l][r - <span class="number">1</span>][L + <span class="number">1</span>][R];</span><br><span class="line">                            <span class="keyword">if</span> (g[L] == g[R])dp[l][r][L][R] |= dp[l][r][L + <span class="number">1</span>][R - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (dp[l][r][L][R])ans = max(ans, i + j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘录</title>
    <url>/%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<h2 id="加密博文格式可能会出现问题"><a href="#加密博文格式可能会出现问题" class="headerlink" title="加密博文格式可能会出现问题"></a>加密博文格式可能会出现问题</h2><p>出现问题需要刷新几次。</p>
<a id="more"></a>
<h2 id="嵌入b站视频的方法"><a href="#嵌入b站视频的方法" class="headerlink" title="嵌入b站视频的方法"></a>嵌入b站视频的方法</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: relative; padding: 0% 0%;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">style</span>=<span class="string">&quot;position: absolute; width: 100%; </span></span></span><br><span class="line"><span class="tag"><span class="string">height: 100%; left: 0; top: 0;&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=52516662&amp;bvid=BV1o4411E7xW</span></span></span><br><span class="line"><span class="tag"><span class="string">&amp;cid=91907659&amp;page=1&amp;as_wide=1&amp;high_quality=1&amp;danmaku=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<div style="position: relative; padding: 0% 0%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="//player.bilibili.com/player.html?aid=52516662&bvid=BV1o4411E7xW&cid=91907659&page=1&as_wide=1&high_quality=1&danmaku=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>
</div>


<h2 id="加密格式"><a href="#加密格式" class="headerlink" title="加密格式"></a>加密格式</h2><p>encrypt: true<br>enc_pwd: 密码</p>
<h2 id="图片出现403"><a href="#图片出现403" class="headerlink" title="图片出现403"></a>图片出现403</h2><p>尝试在文章开头加上<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;referrer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-referrer&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>失衡天平</title>
    <url>/%E5%A4%B1%E8%A1%A1%E5%A4%A9%E5%B9%B3/</url>
    <content><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给了 n 个武器，每个武器有一个重量 a ，并且给了一个天平，现在你每次都可以从这些武器中选择若干个武器并放到天平上，但是只有天平两边重量相差 m 以内你才能拿走，并且拿走的武器不能再放到天平上，问你最多能拿走的武器总重量。</p>
<a id="more"></a>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>实际上如果答案最优，则拿若干次一定不优于拿一次。<br>假设拿的第一次左右两边相差 x ，第二次左右两边相差 y ，则一定有 $|x-y|\leq m$（第二次重的一边放到第一次轻的一边），所以其实无论拿多少次都可以变成只拿一次。<br/><br>这样就是个简单 dp 了。<br>设 $dp[i][j]$ 表示前 i 个武器天平重量相差 j 能拿走的最大武器重量<br/><br>转移：</p>
<script type="math/tex; mode=display">
dp[i][j]=max(dp[i-1][j],dp[i-1][j+a[i]],dp[i-1][|j-a[i]|])</script><p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][N*N],a[N];<span class="comment">//dp[i][j]表示前i个左右两边相差j的最大重量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>,las=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0xf3</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        now^=<span class="number">1</span>,las^=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">10000</span>;++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            x=<span class="built_in">abs</span>(j-a[i]);</span><br><span class="line">            dp[now][j]=dp[las][j];</span><br><span class="line">            dp[now][j]=max(dp[now][j],dp[las][x]+a[i]);</span><br><span class="line">            x=j+a[i];</span><br><span class="line">            <span class="keyword">if</span>(x&lt;=<span class="number">10000</span>)</span><br><span class="line">                dp[now][j]=max(dp[now][j],dp[las][x]+a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i)</span><br><span class="line">        ans=max(ans,dp[now][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>用了下滚动数组优化。</p>
]]></content>
      <tags>
        <tag>DP</tag>
        <tag>牛客每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入b站视频</title>
    <url>/%E5%B5%8C%E5%85%A5b%E7%AB%99%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<p>嵌入b站视频的方法<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div style=<span class="string">&quot;position: relative; padding: 0% 0%;&quot;</span>&gt;</span><br><span class="line">&lt;iframe style=<span class="string">&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;</span> src=<span class="string">&quot;//player.bilibili.com/player.html?aid=52516662&amp;bvid=BV1o4411E7xW&amp;cid=91907659&amp;page=1&amp;as_wide=1&amp;high_quality=1&amp;danmaku=1&quot;</span> scrolling=<span class="string">&quot;no&quot;</span> border=<span class="string">&quot;0&quot;</span> frameborder=<span class="string">&quot;no&quot;</span> framespacing=<span class="string">&quot;0&quot;</span> allowfullscreen=<span class="string">&quot;true&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><br>效果如下</p>
<div style="position: relative; padding: 0% 0%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="//player.bilibili.com/player.html?aid=52516662&bvid=BV1o4411E7xW&cid=91907659&page=1&as_wide=1&high_quality=1&danmaku=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>
</div>

]]></content>
  </entry>
  <entry>
    <title>常用markdown介绍</title>
    <url>/%E5%B8%B8%E7%94%A8markdown%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p> 效果如下：</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h2><p><img data-src="https://tu.sunpma.com/imgs/2021/01/36de521bd3107ef2.png" align='left'><br><br/><br><br/><br><br/><br>效果如下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>此处以C++为例，```后面是代码语言。</p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**我是sb** （粗体）</span><br><span class="line">*tql* （斜体）</span><br><span class="line">~~啊这~~ （划线）</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><strong>我是sb</strong> （粗体）<br><em>tql</em> （斜体）<br><del>啊这</del> （划线）</p>
<h2 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[链接文本](链接地址)</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><a href="https://wjr-z.com/">myblog</a></p>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片文字描述](图片地址)</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><img data-src="https://tu.sunpma.com/imgs/2021/01/dce480b807f1e9fe.webp" alt="我和德狗贴贴"></p>
<p>若觉得图片位置或者大小不太适合，可以尝试用html语言设置高度和宽以及位置等。</p>
<h2 id="插入引用"><a href="#插入引用" class="headerlink" title="插入引用"></a>插入引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 啊这</span><br></pre></td></tr></table></figure>
<blockquote>
<p>啊这</p>
</blockquote>
<h2 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|name|age|address|</span><br><span class="line">|---|:----:|---:|</span><br><span class="line">|zhang|18|beijing|</span><br><span class="line">|wang|22|shandong|</span><br></pre></td></tr></table></figure>
<blockquote>
<p>居中 <code>:------</code><br>局左 <code>-------</code> 或 <code>:-----:</code><br>居右 <code>------:</code></p>
</blockquote>
<p>效果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>name</th>
<th style="text-align:center">age</th>
<th style="text-align:right">address</th>
</tr>
</thead>
<tbody>
<tr>
<td>zhang</td>
<td style="text-align:center">18</td>
<td style="text-align:right">beijing</td>
</tr>
<tr>
<td>wang</td>
<td style="text-align:center">22</td>
<td style="text-align:right">shandong</td>
</tr>
</tbody>
</table>
</div>
<h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>两个空格一个回车</p>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LCT</span><br><span class="line"></span><br><span class="line">--- </span><br><span class="line">splay</span><br></pre></td></tr></table></figure>
<p>效果如下：<br>LCT</p>
<hr>
<p>splay</p>
<p>(yysy这个分割线好丑，以后改一下样式)</p>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- a</span><br><span class="line">- b</span><br><span class="line">- c</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<ul>
<li>a</li>
<li>b</li>
<li>c</li>
</ul>
<blockquote>
<p>参考文章  <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vemhhbmdqaW56aGUvcC84MjUyODkzLmh0bWw=">常用Markdown语法归纳<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>寒假学习计划</title>
    <url>/%E5%AF%92%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p>知识点：<br><a id="more"></a><br>1.线性基<br>2.最小斯坦纳树<br>3.bitset<br>4.点分治<br>5.边分治<br>6.莫比乌斯反演<br>7.杜教筛<br>8.DP<br>9.SAM<br>10.序列自动机<br>11.splay<br>12.替罪羊树<br>13.LCT<br>14.treap及可持久化<br>15.主席树<br>16.线段树合并<br>17.启发式合并<br>18.可撤销并查集<br>19.整体二分<br>20.2-SAT<br>21.欧拉回路<br>22.哈密顿回路<br>23.哈夫曼树<br>24.最大流最小割<br>25.次小生成树<br>26.k小生成树<br>27.差分约束<br>28.中国剩余定理<br>29.欧拉函数<br>30.欧几里得定理<br>31.扩展欧几里得<br>32.容斥原理<br>33.Ploya<br>34.Burnside<br>35.斯特林数<br>36.Min-25筛<br>37.凸包<br>38.半平面交<br>39.FFT<br>40.NTT<br>未完待续…</p>
]]></content>
  </entry>
  <entry>
    <title>明日方舟抽卡概率计算</title>
    <url>/%E6%98%8E%E6%97%A5%E6%96%B9%E8%88%9F%E6%8A%BD%E5%8D%A1%E6%A6%82%E7%8E%87%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<p>明日方舟抽卡概率计算。<br><a id="more"></a><br>我们定义$dp[i][j]$表示抽卡到第$j$次时出了第$i$次货的概率，则有</p>
<script type="math/tex; mode=display">
dp[i][j]=\sum_{k=i-1}^{j-1}{dp[i-1][k]*dp[1][j-k]}(i>1)</script><p>预处理$dp[1][i]$即可。</p>
<p>上代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> dp[<span class="number">12</span>][N],s[N],f[N];</span><br><span class="line"><span class="comment">//dp[i][j]表示抽卡第j次时第i次出货的概率</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> p=<span class="number">0.02</span>,q=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">50</span>)</span><br><span class="line">            p+=<span class="number">0.02</span>;</span><br><span class="line">        dp[<span class="number">1</span>][i]=q*p;</span><br><span class="line">        q*=(<span class="number">1</span>-p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第%d次时第一次出货的概率为%.10Lf\n&quot;</span>,i,dp[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="comment">//这里均指第一次出货。</span></span><br><span class="line">    <span class="keyword">double</span> E_dp=<span class="number">0</span>;<span class="comment">//期望出货所需抽卡次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;++i)</span><br><span class="line">        E_dp+=i*dp[<span class="number">1</span>][i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;期望出货一次所需抽卡次数:%.10Lf\n&quot;</span>,E_dp);</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;++i)&#123;</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+dp[<span class="number">1</span>][i];</span><br><span class="line">        f[i]=<span class="number">1</span>-s[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出货一次&lt;=%d抽卡次数的概率%.10Lf\n&quot;</span>,i,s[i]);<span class="comment">//即dp[1][1]+...+dp[1][i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">10</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">1000</span>;++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i<span class="number">-1</span>;k&lt;j;++k)</span><br><span class="line">                dp[i][j]+=dp[i<span class="number">-1</span>][k]*dp[<span class="number">1</span>][j-k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> X=<span class="number">700</span>,ans_id=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=X<span class="number">-100</span>;i&lt;=X;++i)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> z_ans=dp[<span class="number">10</span>][i]*f[X-i];</span><br><span class="line">        <span class="keyword">if</span>(z_ans&gt;ans)&#123;</span><br><span class="line">            ans=z_ans;</span><br><span class="line">            ans_id=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当第%d次出货第10次且总抽卡次数为%d时的最大概率为%.14Lf\n&quot;</span>,ans_id,X,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：上面代码的q指的是前面均为出货的概率，p代表当前出货率。</p>
<p>接下来我们对此进行分析。<br>代码运行结果显示，期望出货抽卡次数为35次。<br>35次内出货概率约为50%，50次内出货概率约为63.5%，70次内出货概率99.84%，88次内<strong>不出货</strong>概率约为$ 2*10^{-8}\\%$</p>
<p>这是什么概念呢？</p>
<p>十连中出五个六星的概率是$0.02^{5}*0.98 ^{5} * C(10,5)$约为$7*10^{-5} \\% $</p>
<p>好家伙，你88次还不出货的概率比十连中出五星概率小几千倍。<br>接下来考虑平均出货。<br>有的人说自己80级平均70次出一个六星？<br>我们假设他抽了700次10个六星吧，设这个概率最大为$ans$，则有</p>
<script type="math/tex; mode=display">
ans=max\{dp[10][i]*f[700-i]\}(600\leq i\leq 700,其中f[i]表示i发不出的概率)</script><p>我们可以得到当第640次出第10次且后60次不出货的概率是最大的，即700次平均70次1六星的最大概率，其约为$9.15*10^{-10}\\%$<br><br>当然，这只是700次出了10次的概率，如果是出了&lt;=10次的概率求到的仍约为$9.15*10^{-10}\\%$，因为&lt;=9次的远小于=10次的<br><br>这个概率极其的小，比十连出五个六星概率小的多得多，然而我们总是能看到说自己什么90发出货，什么高等级平均70次一个之类的，却很少见到有十连四个，五个六星的，这原因相信不说也应该懂了吧…<br><br>且根据期望的相关性质，出货k次的期望抽卡次数为35*k。<br>如有错误，请留言指出！</p>
]]></content>
      <tags>
        <tag>明日方舟</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2178品酒大会</title>
    <url>/%E6%B4%9B%E8%B0%B7P2178%E5%93%81%E9%85%92%E5%A4%A7%E4%BC%9A/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIxNzg=">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<a id="more"></a>
<p>字符串好题啊！</p>
<p>题目描述见原题。</p>
<p>这题可以用后缀数组SA做。</p>
<p>我们先常规的后缀数组求出sa、height、rk数组，然后按照rank的顺序从1到n跑。</p>
<p>我们不妨求出对于每个点i，相似度为height[i]的所有点对，这样其实就是找到一个rank比rank[i]小的height比height[i]小的最大的位置，和找到一个rank比rank[i]大的height比height[i]小的位置。</p>
<p>这样对于其中所有$(j,k),rank[j]\leq i,i&lt;rank[k]$的点对都是相似度为0~height[i]的，然后用差分即可，这样很容易就能求出任意相似度的点对数，并且可以通过预处理然后RMQ求出最大美味度。<br>不过这个方法呢，需要找到每个点比他height小的两个点，多了一个log n，这题时间卡的还比较紧…(貌似可以用队列优化吧)</p>
<p>第二种方法就是按照rank从小到大跑，考虑用一个队列存相似度相同(为与当前点的相似度)的每一段，每一段记录这一段长度和这一段a的最大和最小值</p>
<p>现在考虑答案贡献问题：</p>
<p>我们从rank从小到大跑，当前到了i，我们将所有相似度不小于height[i]的进行答案计算，设这一段为[L,R]，和i-1相似度为k，则[L,R]中所有点到[R+1,i-1]所有点相似度最大为k，通过差分更新第一个答案，通过记下[R+1,i-1]中a的最大和最小值更新第二个答案。</p>
<p>对于加入第i个点，首先就是为了符合相似度递增，更新下，然后加入第i个点到队列即可。</p>
<p>注意些细节！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> sa[N],tax[N],rk[N],tp[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> he[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">suffix_sort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(tax+<span class="number">1</span>,<span class="number">0</span>,m&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)++tax[rk[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)tax[i]+=tax[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i)sa[tax[rk[tp[i]]]--]=tp[i];</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m=<span class="number">26</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)rk[i]=s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>,tp[i]=i;</span><br><span class="line">    suffix_sort();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,p=<span class="number">0</span>;p&lt;n;m=p,i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;++j)tp[++p]=n-i+j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span>(sa[j]&gt;i)</span><br><span class="line">                tp[++p]=sa[j]-i;</span><br><span class="line">        suffix_sort(),swap(tp,rk);</span><br><span class="line">        rk[sa[<span class="number">1</span>]]=p=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=n;++j)rk[sa[j]]=(tp[sa[j]]==tp[sa[j<span class="number">-1</span>]]&amp;&amp;tp[sa[j]+i]==tp[sa[j<span class="number">-1</span>]+i])?p:++p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_height</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k)--k;</span><br><span class="line">        j=sa[rk[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(s[i+k]==s[j+k])++k;</span><br><span class="line">        he[rk[i]]=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;qsort();get_height();&#125;</span><br><span class="line"><span class="keyword">int</span> maxn[N],minn[N],stk[N],len[N],a[N],top;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N],Max[N];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INF=<span class="number">1e18</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h=he[pos],cnt=<span class="number">0</span>,H,p=-inf,q=inf;</span><br><span class="line">    <span class="keyword">int</span> now,v=a[sa[pos]];</span><br><span class="line">    <span class="keyword">while</span>(top&amp;&amp;(now=stk[top])&gt;=h)&#123; </span><br><span class="line">        cnt+=len[top];</span><br><span class="line">        <span class="keyword">if</span>(now^inf)sum[now+<span class="number">1</span>]+=len[top]*<span class="number">1ll</span>*(n-pos+<span class="number">1</span>),Max[now]=max(Max[now],max(maxn[top]*<span class="number">1ll</span>*p,minn[top]*<span class="number">1ll</span>*q));</span><br><span class="line">        <span class="keyword">else</span> sum[<span class="number">0</span>]+=len[top]*<span class="number">1ll</span>*(n-pos+<span class="number">1</span>);</span><br><span class="line">        p=max(p,maxn[top]),q=min(q,minn[top]);</span><br><span class="line">        --top;</span><br><span class="line">    &#125;<span class="keyword">if</span>(cnt)&#123;</span><br><span class="line">        stk[++top]=he[pos];len[top]=cnt;maxn[top]=p,minn[top]=q;</span><br><span class="line">        sum[h+<span class="number">1</span>]-=len[top]*<span class="number">1ll</span>*(n-pos+<span class="number">1</span>);Max[h]=max(Max[h],max(v*<span class="number">1ll</span>*maxn[top],v*<span class="number">1ll</span>*minn[top]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;n,s+<span class="number">1</span>);</span><br><span class="line">    init();</span><br><span class="line">    Max[<span class="number">0</span>]=-INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),Max[i]=-INF;</span><br><span class="line">    he[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i)&#123;</span><br><span class="line">        insert(i);</span><br><span class="line">        stk[++top]=inf;</span><br><span class="line">        len[top]=<span class="number">1</span>;</span><br><span class="line">        maxn[top]=minn[top]=a[sa[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        Max[i]=max(Max[i],Max[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,sum[i]);</span><br><span class="line">        <span class="keyword">if</span>(Max[i]!=-INF)<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,Max[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>SA</tag>
      </tags>
  </entry>
  <entry>
    <title>最小斯坦纳树详解</title>
    <url>/%E6%9C%80%E5%B0%8F%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>转载自:<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc3FydHl6L3AvMTM0Mjc4NjguaHRtbA==">https://www.cnblogs.com/sqrtyz/p/13427868.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>摘自百度百科的定义：<br>斯坦纳树问题是组合优化问题，与 最小生成树相似 ，是最短网络的一种。最小生成树是在给定的点集和边中寻求最短网络使所有点连通。而最小斯坦纳树允许在给定点外增加额外的点，使生成的最短网络开销最小。</p>
</blockquote>
<a id="more"></a>
<p>可以这么理解：一个图的生成树是构造一棵树把所有点给联通，而斯坦纳树则是构造一棵树把给定的几个点联通。如同生成树有最小的一棵，斯坦纳树也有最小的。如何求最小斯坦纳树，是我们今天要探讨的话题。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>例题：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDYxOTI=">Luogu P6192【模板】最小斯坦纳树<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<blockquote>
<p><div>给定一个包含 $n$ 个结点和 $m$ 条带权边的无向连通图 $G=(V,E)$。<br/><br>再给定包含 $k$ 个结点的点集 $S$，选出 $G$ 的子图 $G&#039;=(V&#039;,E&#039;)$，使得：<br/></p>
<ol>
<li>$S\subseteq V&#039;$；<br/></li>
<li>$G&#039;$ 为连通图；<br/></li>
<li>$E&#039;$ 中所有边的权值和最小。<br/><br>你只需要求出 $E&#039;$ 中所有边的权值和。&lt;/div&gt; <br/></li>
</ol>
</blockquote>
<p>求最小斯坦纳树，我们使用的是 <strong>状压DP</strong>。</p>
<p>首先非常显然的是，这个选出来的子图 <span class="math inline">\(G'\)</span> 一定是个树。</p>
<p>令 <span class="math inline">\(f_{i,S}\)</span> 表示当前这个树的根为 <span class="math inline">\(i\)</span>，选出的点的集合为 <span class="math inline">\(S\)</span>（注意这里选出的点专指那 <span class="math inline">\(k\)</span> 个点中的点），这里的 <span class="math inline">\(S\)</span> 在 dp 中是被状压的。</p>

<ul>
<li>第一种转移方式：</li>
</ul>

<p></p><div class="math display">\[f_{i,S} = f_{i,T} + f_{i,S-T} \ \ \ (T \subseteq S)
\]</div><p></p><p>这种转移方式意义在于把一个根可能会连出多棵 <span class="math inline">\(S\)</span> 互不相交的树，该方程可以合并它们。此时这个根的度数 <span class="math inline">\(\geq 1\)</span>。以下是一个示意图，其中 <span class="math inline">\(5,6,7\)</span> 三个点属于目标的那 <span class="math inline">\(k\)</span> 个点，<span class="math inline">\(3\)</span> 是目前的 <span class="math inline">\(i\)</span>。</p>
<p><img data-src="https://cdn.luogu.com.cn/upload/image_hosting/mqaufgz2.png" alt="" loading="lazy"></p>

<ul>
<li>第二种转移方式：</li>
</ul>

<p><p></p><div class="math display">\[f_{i,S} = f_{j,S} + w(i,j)
\]</div><p></p><p>这种转移方式意义在于把一个根的状态转移到与他相邻的一个根上。此时根 <span class="math inline">\(i\)</span> 的度数 <span class="math inline">\(=1\)</span>。示意图如下，其中 <span class="math inline">\(i = 1，j=3\)</span>，<span class="math inline">\(S=\{5,6\}\)</span>，橙色虚线代表待扩展的边 <span class="math inline">\((i,j)\)</span>。</p></p>
<p><p><img data-src="https://cdn.luogu.com.cn/upload/image_hosting/kpoebt6x.png" alt="" loading="lazy"></p></p>
<p><p>考虑 dp 顺序，显然 <span class="math inline">\(S\)</span> 从小到大枚举即可。</p></p>
<p><p>对于第一种转移方式，只需枚举 <span class="math inline">\(S\)</span> 的子集 <span class="math inline">\(T\)</span>。对于第二种转移方式，注意到这玩意儿是个 <strong>三角不等式</strong>，联想到最短路也是如此——没错，用最短路跑一遍就行了。</p></p>
<h3 id="参考代码">参考代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, k, f[Maxn][<span class="number">1</span> &lt;&lt; Maxk];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, dis;</span><br><span class="line">&#125;</span><br><span class="line">edge[Maxm * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[Maxn], edge_num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dis)</span> </span>&#123;</span><br><span class="line">    edge[++edge_num].next = head[from];</span><br><span class="line">    edge[edge_num].to = to;</span><br><span class="line">    edge[edge_num].dis = dis;</span><br><span class="line">    head[from] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; Q; <span class="keyword">int</span> dist[Maxn]; <span class="keyword">bool</span> inq[Maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(inq, <span class="number">0</span>, <span class="keyword">sizeof</span>(inq));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        dist[i] = f[i][S];</span><br><span class="line">        <span class="keyword">if</span>(dist[i] != <span class="number">1061109567</span>) Q.push(i), inq[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(Q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        inq[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dist[v] &gt; dist[u] + edge[i].dis) &#123;</span><br><span class="line">                dist[v] = dist[u] + edge[i].dis;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v]) &#123;</span><br><span class="line">                    inq[v] = <span class="number">1</span>;</span><br><span class="line">                    Q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i][S] = dist[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(); m = read(); k = read();</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        u = read(); v = read(); w = read();</span><br><span class="line">        add_edge(u, v, w);</span><br><span class="line">        add_edge(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">63</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        u = read();</span><br><span class="line">        f[u][<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>)] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; k); ++S) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> T = S &amp; (S - <span class="number">1</span>); T; T = S &amp; (T - <span class="number">1</span>))</span><br><span class="line">                f[i][S] = min(f[i][S], f[i][T] + f[i][T ^ S]);</span><br><span class="line">        SPFA(S);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans = min(ans, f[i][(<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例题">例题</h3>

<ul>
<li>[WC2008] 游览计划</li>
</ul>

<p><p>考虑把每个方格当成一个点，最小斯坦纳树搞它就完了。</p></p>
<p><p>需要注意的是，由于这道题从边权变成了点权，因此需要把第一种转移方式改成</p></p>
<p><p></p><div class="math display">\[f_{i,S} = f_{i,T} + f_{i,S-T} - w_i\ \ \ (T \subseteq S)
\]</div><p></p><p>原因显然，因为合并状态时 <span class="math inline">\(i\)</span> 的点权被算了两次，需要减去一次。</p></p>
<p><p>另外，这道题需要输出方案。一个解决方法是记录前驱、回溯解决。怎么 dp 过来，就怎么找回去，如果某个状态和上个状态满足 dp 方程，说明这个状态是从上个状态转移过来的，从而可以计算出哪些点是选了的。具体请参见代码的 dfs 部分。</p></p>
<p><p>代码：</p><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> w, h, n, cnt, root, val[Maxn], dp[Maxn][<span class="number">1</span> &lt;&lt; Maxk], pre[Maxn][<span class="number">1</span> &lt;&lt; Maxk];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to;</span><br><span class="line">&#125;</span><br><span class="line">edge[Maxm];</span><br><span class="line"><span class="keyword">int</span> head[Maxn], edge_num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    edge[++edge_num].next = head[from];</span><br><span class="line">    edge[edge_num].to = to;</span><br><span class="line">    head[from] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h * (i - <span class="number">1</span>) + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; Q; <span class="keyword">bool</span> inq[Maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span>(dp[i][S] != <span class="number">1061109567</span>) Q.push(i), inq[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(Q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        inq[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(rg <span class="keyword">int</span> i = head[u]; i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dp[v][S] &gt; dp[u][S] + val[v]) &#123;</span><br><span class="line">                dp[v][S] = dp[u][S] + val[v];</span><br><span class="line">                pre[v][S] = u;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v]) inq[v] = <span class="number">1</span>, Q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ans[Maxn], vis[Maxn][<span class="number">1</span> &lt;&lt; Maxk];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!S || vis[u][S]) <span class="keyword">return</span>;</span><br><span class="line">    vis[u][S] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pre[u][S] &amp;&amp; dp[pre[u][S]][S] + val[u] == dp[u][S]) dfs(pre[u][S], S), ans[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rg <span class="keyword">int</span> T = S &amp; (S - <span class="number">1</span>); T; T = S &amp; (T - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span>(dp[u][T] + dp[u][S ^ T] - val[u] == dp[u][S]) dfs(u, T), dfs(u, S ^ T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    w = read(); h = read(); n = w * h;</span><br><span class="line">    <span class="keyword">for</span>(rg <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= w; ++i)</span><br><span class="line">        <span class="keyword">for</span>(rg <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= h; ++j) &#123;</span><br><span class="line">            val[f(i, j)] = read();</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span>) add_edge(f(i, j), f(i - <span class="number">1</span>, j));</span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">1</span>) add_edge(f(i, j), f(i, j - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(i &lt; w) add_edge(f(i, j), f(i + <span class="number">1</span>, j));</span><br><span class="line">            <span class="keyword">if</span>(j &lt; h) add_edge(f(i, j), f(i, j + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(rg <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!val[i]) dp[i][<span class="number">1</span> &lt;&lt; (cnt++)] = <span class="number">0</span>, root = i;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rg <span class="keyword">int</span> S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; cnt); ++S) &#123;</span><br><span class="line">        <span class="keyword">for</span>(rg <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(rg <span class="keyword">int</span> T = S &amp; (S - <span class="number">1</span>); T; T = S &amp; (T - <span class="number">1</span>))</span><br><span class="line">                dp[i][S] = min(dp[i][S], dp[i][T] + dp[i][S ^ T] - val[i]);</span><br><span class="line">        SPFA(S);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root, (<span class="number">1</span> &lt;&lt; cnt) - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[root][(<span class="number">1</span> &lt;&lt; cnt) - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(rg <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= w; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(rg <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= h; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = f(i, j);</span><br><span class="line">            <span class="keyword">if</span>(!val[pos]) <span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ans[pos]) <span class="built_in">printf</span>(<span class="string">&quot;o&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>最小斯坦纳树</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P4151最大XOR路径</title>
    <url>/%E6%B4%9B%E8%B0%B7P4151%E6%9C%80%E5%A4%A7XOR%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个无向图，让你求从 1 到 n 的路径最大异或和。<br><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQxNTE=">题目链接<i class="fa fa-external-link-alt"></i></span><br><a id="more"></a></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一条边如果经过偶数次则这条边对答案无影响，如果经过奇数次则有影响。<br>不难发现任意两条路径异或后其实都是若干个环，证明省略。<br>接下来考虑如何找到所有的环。<br>因为异或的性质，因此我们并非需要真的找到所有的环，实际上要找的环十分有限。<br>我们用dfs，每搜到一个点打上 vis 标记，如果下一个点已经 vis 过了，则这个环的异或和丢进线性基，否则继续深搜。<br>这样为什么是对的呢？<br>事实上这样很多的环套环是搜不到的。<br>当我们找到一个环后，这个环因为其所有点均 vis 过，因此包含此环一部分的其他环无法被找到。<br>不过所有的环其实均为若干个简单环异或而成，此处简单环指不可能与其他若干环异或的到新环，而简单环我们可以证明一定都能被找到，加入存在某简单环未在dfs中找到，则说明必定存在环上P，在找到该环前访问过该环上的某点Q，则P，Q之间必定至少存在一个环，说明该环不是简单环，因此可以证明所有简单环一定是能被找到的。<br>然后所有的环都能由若干个简单环异或而成，用线性基便可以得到所有可能异或出的值。<br>再回到最初说的两条路径异或和都是若干个环，这样的话最优路径和我们随便找的一条路径只相差若干个环，将所有的简单环的异或值丢进线性基，然后随便用一个1 到 n 的路径异或和找到异或最大值即可。</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50010</span>,M=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">70</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>(x&amp;(<span class="number">1ll</span>&lt;&lt;i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i])x^=f[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                f[i]=x;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> d[N],nxt[M&lt;&lt;<span class="number">1</span>],to[M&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> cost[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">long</span> <span class="keyword">long</span> c)</span></span>&#123;</span><br><span class="line">    to[++tot]=b;</span><br><span class="line">    nxt[tot]=d[a];</span><br><span class="line">    d[a]=tot;</span><br><span class="line">    cost[tot]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">long</span> <span class="keyword">long</span> v)</span></span>&#123;</span><br><span class="line">    dis[x]=v;vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=d[x];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> u=to[i];</span><br><span class="line">        <span class="keyword">if</span>(!vis[u])dfs(u,v^cost[i]);</span><br><span class="line">        <span class="keyword">else</span> insert(v^dis[u]^cost[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Max</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>((ans^f[i])&gt;ans)ans^=f[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        ins(u,v,w);</span><br><span class="line">        ins(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,Max(dis[n]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
]]></content>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>NC18386字符串</title>
    <url>/%E7%89%9B%E5%AE%A2-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>基础中的基础题。</p>
<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL3Byb2JsZW0vMTgzODY=">题目链接<i class="fa fa-external-link-alt"></i></span><br>给出一个长度为 n 的仅由小写字母构成的字符串，求出包含了所有的小写字母子串的最小长度。</p>
<a id="more"></a>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>很显然是用尺取法<br>对于每一个右端点，求出最大的左端点并且能满足条件即可，这样的话，当右端点往右移动时，显然这样的左端点也是往右移动的<br>对于快速求出是否符合条件只需要用桶存每个字母出现次数即可，每次移动右端点后，将左端点移动到最后一个使得所有字母都出现过的位置，这个位置也是第一个至少一个字母未出现的位置的左边一个。</p>
<p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">30</span>],res;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(++num[s[x]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">1</span>)--res;</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(--num[s[x]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>)++res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    res=<span class="number">26</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> L=<span class="number">1</span>,R=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (R &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">while</span>(R&lt;=n&amp;&amp;res)add(++R);</span><br><span class="line">        <span class="keyword">if</span>(R&gt;n)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span>(!res)del(L++);</span><br><span class="line">        ans=min(ans,R-L+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>尺取法</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客挑战赛47</title>
    <url>/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B47/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA3NDM=">比赛链接<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2Rpc2N1c3MvNTg3MjgzP3R5cGU9MTAx">官方题解<i class="fa fa-external-link-alt"></i></span></p>
<a id="more"></a>
<h2 id="A-一道GCD问题"><a href="#A-一道GCD问题" class="headerlink" title="A.一道GCD问题"></a>A.一道GCD问题</h2><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA3NDMvQQ==">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题目描述：<br>给定一个数组a，求每个数加上k后能得到的最大gcd，并求出最小的非负整数k。</p>
<p>题解：<br>假设最大的gcd值为GCD，则<br>a[1]+k=GCD*b[1]<br>a[2]+k=GCD*b[2]<br>a[3]+k=GCD*b[3]<br>…<br>做个差分，可以发现与k无关了，GCD为查分数组的gcd，然后就做出来了。</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> !b?a:gcd(b,a%b);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">int</span> GCD=<span class="built_in">abs</span>(a[<span class="number">2</span>]-a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        GCD=gcd(GCD,<span class="built_in">abs</span>(a[i]-a[i<span class="number">-1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">1</span>]%GCD==<span class="number">0</span>)k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> k=GCD-a[<span class="number">1</span>]%GCD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,GCD,k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="B-又一道-GCD-问题"><a href="#B-又一道-GCD-问题" class="headerlink" title="B.又一道 GCD 问题"></a>B.又一道 GCD 问题</h2><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA3NDMvQg==">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题目描述：略。</p>
<p>题解：<br>经典套路题。将比较难直接求的问题转化为求可行性。<br>假设i+1个gcd为x，则必定有大于等于i+1个a是x的倍数。<br>因为求最大的gcd，则求出一个ans，有大于等于i+1个是ans的倍数，且ans最大化即可。</p>
<p>我们令s[i]表示可以整除i的个数，令ans[i]表示s[x]=i的所有x的最大值。<br>这样ans[i]即表示恰好有i个是ans[i]的倍数，且ans[i]最大化。</p>
<p>最后因为需要求的是大于等于而非等于，从后往前ans[i]=max(ans[i],ans[i+1])即可。</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> s[N],ans[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> x,m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x),++a[x],m=max(m,x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=m;j+=i)</span><br><span class="line">            s[i]+=a[j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        ans[s[i]]=max(ans[s[i]],i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i)ans[i]=max(ans[i],ans[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="C-条件"><a href="#C-条件" class="headerlink" title="C.条件"></a>C.条件</h2><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA3NDMvQw==">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题目描述：略。</p>
<p>题解：<br>给定若干有向边，判断x是否能到达y，并且询问次数q大，n较大，一般是用floyd进行预处理。<br>但是floyd复杂度是$O(n^3)$，显然是过不了的。<br>因为此题只是判断是否能否到达，并否最短路什么的，因此可以用bitset优化，复杂度$O(n^3/w)$。(w为32/64)<br>将两种情况的边用两个bitset存起来，一个是所有一定存在的边，一个是一定和可能存在的边，其他就和普通floyd差不多了。</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m1,m2,q;</span><br><span class="line"><span class="built_in">bitset</span>&lt;N&gt;a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m1,&amp;m2,&amp;q);</span><br><span class="line">    <span class="comment">//a[i]表示所有一定存在的边可以到达的点</span></span><br><span class="line">    <span class="comment">//b[i]表示所有可能和一定存在的边可以到达的点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            b[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i==j)a[i][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m1;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        a[x][y]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!a[j][i])<span class="keyword">continue</span>;</span><br><span class="line">            a[j]|=a[i];</span><br><span class="line">            <span class="comment">//如果j可以到达i，则j可以到达的点包含i可以到达的点</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m2;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        b[x][y]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!b[j][i])<span class="keyword">continue</span>;</span><br><span class="line">            b[j]|=b[i];</span><br><span class="line">            <span class="comment">//如果j可以到达i，则j可以到达的点包含i可以到达的点</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(a[x][y])<span class="built_in">printf</span>(<span class="string">&quot;Yes &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(b[x][y])<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="D-Lots-of-Edges"><a href="#D-Lots-of-Edges" class="headerlink" title="D.Lots of Edges"></a>D.Lots of Edges</h2><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA3NDMvRA==">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题目描述：<br>有n个点，每个点有点权<script type="math/tex">a_{1}\sim a_{n}</script>，若 $ a_{i} \&amp; a_{j}=0$（指二进制按位与），则在i,j间连一条边权为1的边。<br>求 S 到$1\sim n$的最短路。</p>
<p>输入描述：<br>第一行两个正整数 n,S 。<br>接下来一行 n 个非负整数，第 i 个为 $a_i$ 。<br/><br>对于所有数据，$1\le S\le n\le 10^5$，$0\le a_i\le 131071$。</p>
<p>输出描述:<br>一行 n 个整数，第 i 个为 S 到 i 的最短路长度。不能到达输出 -1。</p>
<p>题解：<br>1.<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2Rpc2N1c3MvNTg3MjgzP3R5cGU9MTAx">常规题解<i class="fa fa-external-link-alt"></i></span><br>2.优化建图题解。<br>常规做法复杂度很高，不过因为此题可能不想考优化建图，因此并没有卡复杂度，常规做法复杂度为$O(n^{1.587})$。<br/><br>此题可以优化建图，对于值x只向其二进制表示中少某一位1的值y建边权为0的单向边即可，例如101(2)-&gt;001(2),101(2)-&gt;100(2)，但是不向000(2)建边。<br>然后将所有存在的值x（即a中有的）向x^W($W=2^k-1$，且W大于等于a的最大值)建边权为1的单向边。<br/><br>建边后跑dijkstra，起点需要从a[S]^W开始，且此点初始距离设置为1，具体细节可以自行思考。<br>该方法复杂度为$O(nlogn)$</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> W=<span class="number">131071</span>,N=W+<span class="number">100</span>,M=<span class="number">2e6</span>,inf=<span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> d[N],nxt[M],to[M],val[M],tot;</span><br><span class="line"><span class="keyword">int</span> dis[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id,dis;</span><br><span class="line">    node (<span class="keyword">int</span> a=<span class="number">0</span>,<span class="keyword">int</span> b=<span class="number">0</span>)&#123;</span><br><span class="line">        id=a;</span><br><span class="line">        dis=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp;other)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis&gt;other.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;node&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to[++tot]=b;</span><br><span class="line">    nxt[tot]=d[a];</span><br><span class="line">    d[a]=tot;</span><br><span class="line">    val[tot]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,S;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="keyword">int</span> start=a[S]^W;</span><br><span class="line">    dis[start]=<span class="number">1</span>;</span><br><span class="line">    q.push(node(start,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        node tmp=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[tmp.id])<span class="keyword">continue</span>;</span><br><span class="line">        vis[tmp.id]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=d[tmp.id];i;i=nxt[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> u=to[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[u]&gt;tmp.dis+val[i])&#123;</span><br><span class="line">                dis[u]=tmp.dis+val[i];</span><br><span class="line">                q.push(node(u,dis[u]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(x) x&amp;-x</span></span><br><span class="line"><span class="keyword">bool</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=W;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> p,q;</span><br><span class="line">        p=i;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            q=lb(p);</span><br><span class="line">            ins(i,i^q,<span class="number">0</span>);</span><br><span class="line">            p-=q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=W;++i)</span><br><span class="line">        <span class="keyword">if</span>(f[i])ins(i,i^W,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;S);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),f[a[i]]=<span class="number">1</span>;</span><br><span class="line">    build();</span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==S)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0 &quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dis[a[i]]&lt;=inf)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,dis[a[i]]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="E-路径"><a href="#E-路径" class="headerlink" title="E. 路径"></a>E. 路径</h2><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA3NDMvRQ==">题目链接<i class="fa fa-external-link-alt"></i></span><br>这题比较有趣（<del>指码量</del>），我单独写了一篇题解<br><a href="">题解</a></p>
]]></content>
      <tags>
        <tag>牛客比赛</tag>
        <tag>bitset</tag>
        <tag>图论</tag>
        <tag>优化建图</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客挑战赛47E.路径</title>
    <url>/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B47E-%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵树，求所有经过点数大于等于2的无向路径中长度第k小的。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA3NDMvRQ==">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<a id="more"></a>
<p>用点分治先预处理出长度为 i 的路径数 ans[i] 。<br>假设当前层重心是 x ，设 a[i] 表示当前已经处理的所有子树到 x 路径长度为 i 的路径数，b[i] 表示正在处理的子树到 x 路径长度为 i 的路径数，则有</p>
<script type="math/tex; mode=display">
ans[i]=\sum_{j=0}^{i}a[j]*b[i-j]</script><p>然后将当前处理子树合并到已处理子树上，两数组相加即可。<br>关于求这个卷积，如果暴力求，很可能会TLE，如果没有TLE说明数据比较水，反正复杂度肯定是不行的。<br>可以用FFT或者NTT来求这个卷积。<br>不过就算这样了其实还是很可能会TLE。<br>假设当前根有 n-1 棵子树，每颗子树仅一个点，且第一个子树和当前根节点连的边为 100000 ，这样的话会被卡到 $O(n* z)$。<br/><br>因此需要将当前根节点的所有子树按照其最长路径从小到大排序后再依次合并，类似于启发式合并，复杂度会降低到$O(z\,logz\,logn)$<br/><br>算上点分治复杂度，总复杂度为 $O(z\,logz\,logn+n\,logn)$<br/><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Complex(<span class="keyword">double</span> a = <span class="number">0</span>, <span class="keyword">double</span> b = <span class="number">0</span>) &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>+(Complex a, Complex b) &#123; <span class="keyword">return</span> Complex(a.x + b.x, a.y + b.y); &#125;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(Complex a, Complex b) &#123; <span class="keyword">return</span> Complex(a.x - b.x, a.y - b.y); &#125;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>*(Complex a, Complex b) &#123; <span class="keyword">return</span> Complex(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> rev[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_rev</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span> &lt;&lt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (s - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i])</span><br><span class="line">            swap(a[i], a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, mid = <span class="number">1</span>; i &lt;= n; i &lt;&lt;= <span class="number">1</span>, mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">Complex <span class="title">wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span> * PI / i), p * <span class="built_in">sin</span>(<span class="number">2</span> * PI / i))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += i) &#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) &#123;</span><br><span class="line">                Complex x = a[k], y = w * a[k + mid];</span><br><span class="line">                a[k] = x + y, a[k + mid] = x - y;</span><br><span class="line">                w = w * wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            a[i].x /= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5e4</span> + <span class="number">10</span>, H = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[H];</span><br><span class="line">Complex F[N], G[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = n + m, bit = <span class="number">0</span>, s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (s &lt;= len)++bit, s &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; ++i)</span><br><span class="line">        F[i].x = a[i], G[i].x = b[i], F[i].y = G[i].y = <span class="number">0</span>;</span><br><span class="line">    get_rev(bit);</span><br><span class="line">    FFT(F, s, <span class="number">1</span>), FFT(G, s, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; ++i)</span><br><span class="line">        F[i] = F[i] * G[i];</span><br><span class="line">    FFT(F, s, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; ++i)</span><br><span class="line">        ans[i] += (<span class="keyword">int</span>)(F[i].x + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[M], siz[M], d[M], nxt[M &lt;&lt; <span class="number">1</span>], to[M &lt;&lt; <span class="number">1</span>], cost[M &lt;&lt; <span class="number">1</span>], tot;</span><br><span class="line"><span class="keyword">bool</span> vis[M];</span><br><span class="line"><span class="keyword">int</span> Siz, rot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    to[++tot] = b;</span><br><span class="line">    nxt[tot] = d[a];</span><br><span class="line">    d[a] = tot;</span><br><span class="line">    cost[tot] = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_rt</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    siz[x] = <span class="number">1</span>; dp[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (u == f || vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        get_rt(u, x);</span><br><span class="line">        siz[x] += siz[u];</span><br><span class="line">        dp[x] = max(dp[x], siz[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[x] = max(dp[x], Siz - siz[x]);</span><br><span class="line">    <span class="keyword">if</span> (dp[x] &lt; dp[rot])rot = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> al, bl;</span><br><span class="line"><span class="keyword">int</span> stk[M], top;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    ++b[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (u == f || vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        dfs(u, x, v + cost[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Max;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, max_dep, cost;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; other)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> max_dep &lt; other.max_dep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;st[M];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_dep</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = dep;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (u == f || vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        c = max(c, get_dep(u, x, dep + cost[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>; al = <span class="number">0</span>;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">        st[cnt].x = u, st[cnt].max_dep = get_dep(u, x, cost[i]);</span><br><span class="line">        st[cnt].cost = cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(st + <span class="number">1</span>, st + <span class="number">1</span> + cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = st[i].x;</span><br><span class="line">        bl = st[i].max_dep;</span><br><span class="line">        dfs(u, x, st[i].cost);</span><br><span class="line">        Merge(a, b, al, bl);</span><br><span class="line">        Max = max(Max, al + bl);</span><br><span class="line">        al = max(al, bl);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= al; ++j)</span><br><span class="line">            a[j] += b[j], b[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= al; ++i)</span><br><span class="line">        a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    rot = <span class="number">0</span>; Siz = s;</span><br><span class="line">    get_rt(x, <span class="number">0</span>);</span><br><span class="line">    x = rot;</span><br><span class="line">    vis[x] = <span class="number">1</span>; calc(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        solve(u, siz[u] &lt; siz[x] ? siz[u] : s - siz[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    dp[<span class="number">0</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        ins(u, v, w);</span><br><span class="line">        ins(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    solve(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Max; ++i)</span><br><span class="line">        ans[i] += ans[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> k;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;k);</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = Max, Ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = L + R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans[mid] &lt; k)L = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> R = mid - <span class="number">1</span>, Ans = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>FFT</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客挑战赛76D.魔物消灭计划</title>
    <url>/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B76D-%E9%AD%94%E7%89%A9%E6%B6%88%E7%81%AD%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA4NDUvRA==">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<a id="more"></a>
<p>这题其实就是最小斯坦纳树的模板题…<br>真的，只要会最小斯坦纳树，这题基本秒解。<br>将所有相同宝石当做一个点，然后将x,y也算作必选即可。<br>之后就是套最小斯坦纳树模板了。<br>不过其实也可以不用这样啦，直接将所有相同宝石的点连一个对应宝石的新增点，边权为0，然后初始化的时候，第i个点如果宝石种类是p，令f[i][1&lt;&lt;(p-1)]=0即可。</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">120</span>,M=<span class="number">1</span>&lt;&lt;<span class="number">10</span>,inf=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> d[N],nxt[M+<span class="number">2</span>*N],to[M+<span class="number">2</span>*N],cost[M+<span class="number">2</span>*N],tot;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> x,y,cnt;</span><br><span class="line"><span class="keyword">int</span> f[N][M],dis[N];</span><br><span class="line"><span class="keyword">bool</span> in[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    to[++tot]=b;</span><br><span class="line">    nxt[tot]=d[a];</span><br><span class="line">    d[a]=tot;</span><br><span class="line">    cost[tot]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        dis[i]=f[i][S];</span><br><span class="line">        <span class="keyword">if</span>(dis[i]&lt;inf)q.push(i),in[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        in[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=d[x];i;i=nxt[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> u=to[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[u]&gt;dis[x]+cost[i])&#123;</span><br><span class="line">                dis[u]=dis[x]+cost[i];</span><br><span class="line">                <span class="keyword">if</span>(!in[u])in[u]=<span class="number">1</span>,q.push(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)f[i][S]=dis[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Stenier</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt=<span class="number">1</span>&lt;&lt;(k+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)f[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S=<span class="number">0</span>;S&lt;cnt;++S)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> T=S&amp;(S<span class="number">-1</span>);T;T=(T<span class="number">-1</span>)&amp;S)</span><br><span class="line">                f[i][S]=min(f[i][S],f[i][T]+f[i][S^T]);</span><br><span class="line">        spfa(S);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k,&amp;x,&amp;y);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p);</span><br><span class="line">        <span class="keyword">if</span>(i==x)f[i][<span class="number">1</span>&lt;&lt;k]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==y)f[i][<span class="number">1</span>&lt;&lt;(k+<span class="number">1</span>)]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!p)<span class="keyword">continue</span>;</span><br><span class="line">            f[i][<span class="number">1</span>&lt;&lt;(p<span class="number">-1</span>)]=<span class="number">0</span>;</span><br><span class="line">            ins(i,n+p,<span class="number">0</span>);</span><br><span class="line">            ins(n+p,i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;n+=k;</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        <span class="keyword">if</span>(u==v)<span class="keyword">continue</span>;</span><br><span class="line">        ins(u,v,w),ins(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    Stenier();</span><br><span class="line">    <span class="keyword">int</span> ans=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)ans=min(ans,f[i][cnt<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<p>感觉这样子的话如果去掉相同宝石可以传送，然后去掉建额外边，好像也是可以的？<br>因为其实求最小斯坦纳树除了初始化之外，之后与那k个点无关了。</p>
]]></content>
      <tags>
        <tag>最小斯坦纳树</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客挑战赛46C-排列</title>
    <url>/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B46C-%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvOTUxMC9D">题目链接<i class="fa fa-external-link-alt"></i></span></p>
<a id="more"></a>
<p>题目描述：<br>有个1$\sim$n的随机排列的数组，且其含k个超级逆序对，问你能猜对该数组的概率是多少。</p>
<p>数据范围：<br>$n,k\leq 500$</p>
<p>题解：<br>一道DP题，不算难。<br>考虑设$dp[i][j][p]$为$1\sim i$，且i在第p位，有j个超级逆序对的方案数。<br>则若加入i，除了i-1，其余的只要在i后均能形成超级逆序对，且不存在在i前与i形成超级逆序对的。<br>考虑将i插入到$1\sim i-1$的不同位置，并且讨论和i-1的先后顺序即可。</p>
<ul>
<li>如果i-1在p后，则方案数为$\sum_{l=p}^{l=i-1}{dp[i-1][j-i+p+1][l]}$</li>
<li>如果i-1在p前，则方案数为$\sum_{l=1}^{l=p-1}{dp[i-1][j-i+p][l]}$</li>
</ul>
<p>即$dp[i][j][p]=\sum_{l=p}^{l=i-1}{dp[i-1][j-i+p+1][l]}+\sum_{l=1}^{l=p-1}{dp[i-1][j-i+p][l]}$<br/><br>下面上代码</p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">505</span>,mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][N][N],s[<span class="number">2</span>][N][N];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a+b&gt;=mod?a+b-mod:a+b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a-b+mod:a-b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a*<span class="number">1ll</span>*b%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)s=mul(s,a);</span><br><span class="line">        a=mul(a,a);</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    s[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>,las=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        swap(now,las);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=k;++j)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=i;++p)&#123;</span><br><span class="line">                 dp[now][j][p]=<span class="number">0</span>;</span><br><span class="line">                 <span class="keyword">if</span>(j-i+p+<span class="number">1</span>&gt;=<span class="number">0</span>)dp[now][j][p]=del(s[las][j-i+p+<span class="number">1</span>][i<span class="number">-1</span>],s[las][j-i+p+<span class="number">1</span>][p<span class="number">-1</span>]);</span><br><span class="line">                 <span class="keyword">if</span>(j-i+p&gt;=<span class="number">0</span>)dp[now][j][p]=add(dp[now][j][p],s[las][j-i+p][p<span class="number">-1</span>]);</span><br><span class="line">                 s[now][j][p]=add(s[now][j][p<span class="number">-1</span>],dp[now][j][p]);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)ans=add(ans,dp[now][k][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,qpow(ans,mod<span class="number">-2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客挑战赛76E.牛牛数数</title>
    <url>/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B76E-%E7%89%9B%E7%89%9B%E6%95%B0%E6%95%B0/</url>
    <content><![CDATA[<p>这题如果你会线性基的话，非常简单！</p>
<p>如果你还没学过线性基可以来看下我的这篇博客：</p>
<p><a href="/线形基/">线性基详解</a></p>
<a id="more"></a>
<p>这题啊，直接异或第k小+二分即可。</p>
<p>因为能异或出的数的个数知道，找到大于K的最小的数是第几小即可知道大于K的数有多少了。</p>
<p>不过呢，这题数据较弱，有些细节不考虑都能过，例如可以异或出0时有部分代码会出bug。</p>
<blockquote>
<p>hack数据：<br>2 12<br>13 2</p>
</blockquote>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">62</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[N],p[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> K;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;(<span class="number">1ll</span>&lt;&lt;i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i])x^=d[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                d[i]=x;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            <span class="keyword">if</span>(d[i]&amp;(<span class="number">1ll</span>&lt;&lt;j))d[i]^=d[j];</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">60</span>;++i)</span><br><span class="line">        <span class="keyword">if</span>(d[i])p[cnt++]=d[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> S;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">kth</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>&amp;&amp;cnt&lt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;n)--k;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=cnt<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>(k&amp;(<span class="number">1ll</span>&lt;&lt;i))ans^=p[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">        add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    work();</span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;n)S=<span class="number">1ll</span>&lt;&lt;cnt;</span><br><span class="line">    <span class="keyword">else</span> S=(<span class="number">1ll</span>&lt;&lt;cnt)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> L=<span class="number">1</span>,R=S,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(L&lt;=R)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span>  mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(kth(mid)&lt;=K)L=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> R=mid<span class="number">-1</span>,ans=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,S-ans+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>]]></content>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>线形基详解</title>
    <url>/%E7%BA%BF%E5%BD%A2%E5%9F%BA%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>基（basis）是线性代数中的一个概念，它是描述、刻画向量空间的基本工具。而在现行的 OI 题目中，通常在利用基在异或空间中的一些特殊性质来解决题目，而这一类题目所涉及的知识点被称作「线性基」。（大部分求线性基类似于线代里面的矩阵求最大线性无关组）</p>
</blockquote>
<a id="more"></a>
<p>可以将每个数 x 转为二进制，将其看成一个向量。线性基即求 m 个向量，<strong>这 m 个向量线性无关</strong>（即任意一个向量不能被其他任意个向量表示出），且 m 个向量可以表示出原数组的所有向量。</p>
<p>则如果 x 为 0 ，或者 x 可以被线性基表示出，不加入线性基，否则加入线性基。</p>
<h2 id="那么如何快速得出-x-是否可以被线性基表示出？"><a href="#那么如何快速得出-x-是否可以被线性基表示出？" class="headerlink" title="那么如何快速得出 x 是否可以被线性基表示出？"></a>那么如何快速得出 x 是否可以被线性基表示出？</h2><p>可以使用高斯消元，假设线性基加入 x 后高斯消元有全为 0 的行，则说明 x 可以被表示出。<br>如果不能表示出则可以直接加入线性基。</p>
<p>在最后跑高斯消元，因为 x 转为二进制的长度有限，假设为 k ，则消元后的主元（即每一行中第一个非零元素）数最多也为 k，若大于k，则说明还能继续消元下去。<br><strong>因此我们得到了一个最多 k 个向量的线性基</strong>，该线性基在高斯消元前即为原数组中的最多 k 个元素，且这 k 个元素可以表示原数组所有数，因为未加入到线性基的数均为 0 或者可以被线性基表示的数。</p>
<p>不过因为异或的特殊性质，可以不用高斯消元求解。<br>如果是用向量写的话，正规来说，应该是将k个向量竖着组成一个矩阵，然后高斯消元，我们为了减小复杂度，可以将其横着放，将第 i 个数二进制对应的第 j 位放在矩阵的第 i 行第 j 列。<br>这样的话，行化简即为异或。<br>举个栗子，原数组为{7,1,4,3,5}<br>加入 7 ，矩阵变为<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 1<br>\end{bmatrix}</p>
<p>加入 1 ，矩阵变为<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 1\\<br>0 &amp; 0 &amp; 1<br>\end{bmatrix}</p>
<p>高斯消元后变为<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 1<br>\end{bmatrix}</p>
<p>加入 4 ，矩阵变为<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 1\\<br>1 &amp; 0 &amp; 0<br>\end{bmatrix}</p>
<p>高斯消元后变为<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 1<br>\end{bmatrix}</p>
<p>加入 3 ,矩阵变为<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 1\\<br>0 &amp; 1 &amp; 1<br>\end{bmatrix}</p>
<p>高斯消元后变为<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 1\\<br>0 &amp; 0 &amp; 0<br>\end{bmatrix}</p>
<p>因此 3 不能加入线性基，同理，5也是。</p>
<p>因此最后线性基中的元素为4,2,1，其异或和可以表示所有原数组中的任意异或和。</p>
<p>这样求需要对换两行，但其实这一步也可以省略。</p>
<p>即我们设$d[i]$表示主元是第 i 列的线性基中的数，我们插入一个数 x 时，从高位到低位，假设当前是第 i 位，且 x 的第 i 位为 1 ，如果 d[i]=0 ，则令$d[i]=x$即可，否则令 $x=x\oplus d[i]$，并继续下去。<br/><br>证明很显然。</p>
<ul>
<li>当 x 到了第 i 位，则高位一定全是0，此时第 i 为 1 且d[i]不存在，则肯定不会被消去，则 x 一定会加入线性基。</li>
<li>如果 d[i] 已经存在，则仿照高斯消元，将 x 的第 i 位消成 0 ，再继续即可。</li>
</ul>
<p>注意：这种方法也分两种写法，一种是每次加入后从下往上消去，一种是全部加入完后再从下往上消去，本质是一样的。<br>（在线代中从上往下消即向前步骤，从下往上消为向后步骤，为了理解更简单，之后会一直以向上/向下消去代替，不过我觉得学线性基的估计都是学了高斯消元的吧）</p>
<p>代码如下（后消去）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>(x&amp;(<span class="number">1ll</span>&lt;&lt;i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i])x^=d[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                d[i]=x;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            <span class="keyword">if</span>(d[i]&amp;(<span class="number">1ll</span>&lt;&lt;j))d[i]^=d[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="线性基的性质及证明"><a href="#线性基的性质及证明" class="headerlink" title="线性基的性质及证明"></a>线性基的性质及证明</h2><ul>
<li>原序列里面的任意一个数都可以由线性基里面的一些数异或得到</li>
<li>线性基的元素能相互异或得到原集合的元素的所有相互异或得到的值。</li>
<li>线性基没有异或和为 0 的子集。</li>
<li>线性基是满足性质 1 的最小的集合。</li>
<li>线性基中每个元素的异或方案唯一，也就是说，线性基中不同的异或组合异或出的数都是不一样的。</li>
<li>线性基中每个元素的二进制最高位互不相同。</li>
<li>线性基的元素的所有相互异或得到的值均可由原集合的元素相互异或得到。</li>
</ul>
<p>证明如下：</p>
<h3 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h3><p>线性基构造时我们即能被线性基得到的不加入，否则加入。<br>假设加入的数为 x ，高斯消元后变为 $x\oplus y$，则$x\oplus y \oplus y$即为 x ，y可以被线性基表示，因此性质1得证。</p>
<h3 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h3><p>因为原数组每个数都能被线性基异或得到，因此原数组相互异或得到的所有数均可以被线性基中若干个数异或得到。</p>
<h3 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h3><p>如果存在异或为 0 的子集，则与构造方法不符，因为此时必定会出现至少一行无主元，则说明至少有一个不该插入的数插入，因此当方法正确时线性基中的任意数异或不能为 0 。</p>
<h3 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h3><p>因为所有能被表示的数都被剔除了，能插入到线性基中的数均为不能被线性基表示的数，因此得证。</p>
<h3 id="性质5"><a href="#性质5" class="headerlink" title="性质5"></a>性质5</h3><p>即性质 2 的变形。</p>
<h3 id="性质6"><a href="#性质6" class="headerlink" title="性质6"></a>性质6</h3><p>高斯消元后不同行的主元不会出现在相同列，否则可以继续消元，因此性质6得证。</p>
<h3 id="性质7"><a href="#性质7" class="headerlink" title="性质7"></a>性质7</h3><p>很显然在高斯消元前线性基中的元素即为原集合的部分元素，因此高斯消元后，任何线性基的元素可以被表示为若干个原集合的元素的异或和。<br>之后即性质2。<br>因此线性基任意异或得到的数的集合与原集合中任意异或得到的数的集合完全相同（0除外，因为线性基规定不能异或出0）。</p>
<h2 id="如何求最大值"><a href="#如何求最大值" class="headerlink" title="如何求最大值"></a>如何求最大值</h2><p>其实和0/1 trie树求最大异或值差不多。<br>从高位到低位，若当前是第 i 位，若$(ans\oplus d[i]) &gt; ans$，则$ans=ans\oplus d[i]$即可。<br/><br>证明：<br>如果 ans 第 i 位是 1 ，若 d[i] 不为 0 ，则 d[i] 第 i 位是 1 ，则异或后肯定更小。<br>如果 ans 第 i 位是 0 ，若 d[i] 不为 0 ，则 d[i] 比 i 位更高的位均为 0 ，且第 i 位是 1 ，因此异或后肯定更大。</p>
<p>因此也可以看出其实可以有两种写法，具体效率相差多少我不清楚qwq。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM4MTI=">异或最大值模板题<i class="fa fa-external-link-alt"></i></span></p>
<details>
    <summary>参考代码</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">52</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">50</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>(x&amp;(<span class="number">1ll</span>&lt;&lt;i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i])x^=d[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                d[i]=x;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_Max</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">50</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>((ans^d[i])&gt;ans)</span><br><span class="line">            ans^=d[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;<span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">        add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,get_Max());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>此代码并未向上消元，仅仅只是最大值/最小值的话没必要。</p>
<h2 id="如何求最小值"><a href="#如何求最小值" class="headerlink" title="如何求最小值"></a>如何求最小值</h2><p>1.如果线性基元素个数小于原集合元素个数，说明至少有一个未能成功插入线性基，则这个数要么是 0 要么可以被线性基中的数表示，两种情况最小值均为0。<br>2.如果线性基元素等于原集合元素个数。<br>我们假设最小值为$d_{a_1}\oplus d_{a_2}\oplus d_{a_3}…\oplus d_{a_m}$ ，且$a_1&lt; a_2 &lt;…&lt; a_m$，则最高位一定是$a_m$，必定大于$d_{a_1}$，因为后者最高位是$a_1$。<br/><br>所以可以知道最小值是最小的$d$，因为最小值不为 0 ，因此为最小的$d_i(d_i!=0)$。</p>
<h2 id="如何求第k小"><a href="#如何求第k小" class="headerlink" title="如何求第k小"></a>如何求第k小</h2><p>之前求最大和最小均可以不用向上消元，但是求第 k 小就需要向上消元了。<br>在高斯消元后每个主元所在列除了该主元所在行之外均为0。<br>若有$d_{a_1}\oplus d_{a_2}…\oplus d_{a_m}$，且$a_1&lt; a_2…&lt; a_m$，则第 $a_1,a_2…,a_m$位均为 1 ，因为有且仅有$d_{a_1}$第$a_1$位是1，其他同理。<br/><br>现在考虑比较由线性基异或得到的不同的两个数的大小，假设$x=d_{a_1}\oplus d_{a_2}…\oplus d_{a_p},y=d_{b_1}\oplus d_{b_2}…\oplus d_{b_q}$ ，且$a_1 &lt; a_2…&lt; a_p,b_1 &lt; b_2…&lt; b_q$，且$d_{a_1},d_{a_2}…，d_{a_p} ,d_{b_1},d_{b_2}…d_{b_q}$均不为0<br/><br>1.若$a_p &lt; a_q$ ，则$x &lt; y$<br/><br>2.若$a_p &gt; a_q$ ，则$x &gt; y$<br/><br>3.若$a_p = a_q$ ，则比较$a_{p-1}$和$b_{q-1}$ ，假设$a_{p-1}&gt;b_{q-1}$，则比$a_{p-1}$高的位不变，且第$a_{p-1}$位 x 是 1，y 是 0，因此$x&gt;y$ ，$a_{p-1} &lt; b_{q-1}$则$x &lt; y$，当$a_{p-1}=b_{q-1}$时，不妨将$d_{a_{p}}\oplus d_{a_{p-1}}$当成新数，并继续这样下去。<br/></p>
<p>因此可以发现仅比较$a_{1}，a_{2}…a_{p}，b_{1},b_{2}…b_{q}$即可。<br/><br>我们用另一个数组 p ，令p[i] 表示从低到高位第 i+1 个非零的 d<br>将 k 表示为二进制，则如果$k\&amp;(1ll &lt;&lt; i)$，令$ans = ans \oplus p[i]$即可。<br/></p>
<p>最大值即为所有异或起来，最小值需要讨论。</p>
<p>如果原集合能异或出 0 ，即线性基中元素个数 cnt &lt; 原集合元素个数 n ，那么最小值为 0 。<br>如果不能异或出 0 ，即为 p[0]。<br>因此其实能异或出的元素个数也能求出来。</p>
<ul>
<li>如果 cnt &lt; n ，则能异或出的数为 $2^{cnt}$。<br/></li>
<li>如果 cnt = n ，则能异或出的数为 $2^{cnt}-1$。<br/></li>
</ul>
<p>因此当求第 k 小时有几点需要注意：</p>
<ul>
<li>cnt &lt; n 时 ，能异或出的数的个数为 $2^{cnt}$（可以有 0 ）。<br/></li>
<li>cnt = n 时 ， 能异或出的数的个书屋 $2^{cnt}-1$（不能有 0 ）。<br/></li>
<li>当 k=1 时 ，如果 cnt &lt; n ，则最小是 0 。</li>
<li>当 k 不为 1 ，且 cnt &lt; n 时，因为最小值是 0 ，而 0 被算成了第 0 小，因此需要令$k=k-1$。</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA4NDUvRQ==">异或第k小例题+二分<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>hack数据：<br>2 12<br>13 2</p>
</blockquote>
<p><a href="/2021/01/17/牛客挑战赛76E-牛牛数数/">题解</a></p>
<h2 id="判断一个数是否能被当前元素异或得到"><a href="#判断一个数是否能被当前元素异或得到" class="headerlink" title="判断一个数是否能被当前元素异或得到"></a>判断一个数是否能被当前元素异或得到</h2><p>即看是否能插入到线性基中，如果不能则说明可以，否则说明不行。</p>
<blockquote>
<p>参考文章<br><span class="exturl" data-url="aHR0cHM6Ly9vaS13aWtpLm9yZy9tYXRoL2Jhc2lzLyNfX2NvbW1lbnRz">线性基 OI wiki<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnNlbmd4aWFuLmNvbS9hbGdvcml0aG1zL2xpbmVhci1iYXNpcw==">线性基学习笔记<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FfZm9yZXZlcl9kcmVhbS9hcnRpY2xlL2RldGFpbHMvODM2NTQzOTc=">线性基详解<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客练习赛76</title>
    <url>/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B76/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vZGlzY3Vzcy81ODkwMDc/dHlwZT0xMDEmYW1wO2NoYW5uZWw9LTEmYW1wO3NvdXJjZV9pZD0w">官方题解<i class="fa fa-external-link-alt"></i></span></p>
<a id="more"></a>
<p>这次比赛还比较难，就挺不戳的，刚好补知识点。</p>
<p>涉及考点：</p>
<ol>
<li><p>博弈论</p>
</li>
<li><p>线性基 异或第k小</p>
</li>
<li><p>最小斯坦纳树</p>
</li>
<li><p>莫比乌斯反演</p>
</li>
</ol>
<p>知识点讲解：</p>
<ol>
<li><p><a href="/%E7%BA%BF%E5%BD%A2%E5%9F%BA/">线性基</a></p>
</li>
<li><p><a href="/最小斯坦纳树详解/">最小斯坦纳树</a></p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>牛客每日一题</title>
    <url>/%E7%89%9B%E5%AE%A2%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vZGlzY3Vzcy80MzYyNTM/dHlwZT0xMDEmYW1wO29yZGVyPTAmYW1wO3Bvcz0xJmFtcDtwYWdlPTImYW1wO2NoYW5uZWw9LTEmYW1wO3NvdXJjZV9pZD0x">原文链接<i class="fa fa-external-link-alt"></i></span></p>
<p>题解的话牛客上也有很多，我的博客也写了一些。</p>
<p>要找到对应的题解，可以在标签找”牛客每日一题”，或者直接搜索对应的题目名字。</p>
<a id="more"></a>]]></content>
      <tags>
        <tag>牛客每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>线性筛详解</title>
    <url>/%E7%BA%BF%E6%80%A7%E7%AD%9B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>最简单的，最容易想到的筛素数的应该就是直接从小到大，将每个素数的2以上的倍数筛掉了，这个方法复杂度约为 O(N ln ln N)。</p>
<a id="more"></a>
<p>举个栗子：<br>初始：&emsp;&emsp; &emsp; &nbsp;&nbsp;&nbsp; 1 2 3 4 5 6 7 8 9 10 11 12<br>第一次（2）：&nbsp;&nbsp; 1 2 3 5 7 9 11<br>第二次（3）：&nbsp;&nbsp; 1 2 3 5 7 11<br>第三次（5）： &nbsp;&nbsp;1 2 3 5 7 11<br>第四次（7）： &nbsp;&nbsp;1 2 3 5 7 11<br>第五次（11）：1 2 3 5 7 11</p>
<p>如果每次并非是用素数进行筛，复杂度是O(N lnN)（调和级数），因为只用素数筛去，因此复杂度进一步降低了。</p>
<p>不过这个方法并不是线性的，下面来重点介绍下线性筛。</p>
<h2 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h2><p>线性筛本质就是让一个数只被筛去一次，而上述的筛法（Eratosthenes筛法）有很多数其实不止被筛去了一次。<br>我们考虑让每个非素数 x=p*q ，其中 p 是 x 分解质因数的最小质数，我们仅让其能被 q 筛去，这样因为每个数仅有一个最小质因数，所以只会被筛去一次，且每个非素数一定会被筛去，因为我们总是能找到这样的 p 和 q </p>
<h3 id="那么如何实现呢？"><a href="#那么如何实现呢？" class="headerlink" title="那么如何实现呢？"></a>那么如何实现呢？</h3><p>将 q 分解质因数，则 q 也存在一个最小的质因数，假设为 c ，则当 p 不大于 c 时，即代表可以筛去。<br>不过实际上不用求出 q 的最小质因数。<br>我们假设当前是 i ，且我们用了另一个数组 pri 存下来当前找到的所有素数（从小到大），然后考虑用 i 用上述方法筛去非素数，枚举素数，当 i%pri[j]==0 时停止即可，此时代表 i 存在一个 pri[j]这个素数，当 j 继续增加，i 分解质因数后的最小素数比 pri[j]更小，这样会导致部分数筛去多次，因此需要停止。</p>
<p>举个栗子：<br>初始：&emsp;&emsp;&emsp;&nbsp;&nbsp;       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16<br>第一次（2）：1 2 3 5 6 7 8 9 10 11 12 13 14 15 16  （pri:2，筛去2*2=4并停止）<br>第二次（3）：1 2 3 5 7 8 10 11 12 13 14 15 16  （pri:2,3，筛去3*2=6，3*3=9并停止）<br>第三次（4）：1 2 3 5 7 10 11 12 13 14 15 16  （pri:2,3，筛去4*2=6并停止）<br>第四次（5）：1 2 3 5 7 11 12 13 14 16 （pri:2,3,5，筛去5*2=10，5*3=15并停止）<br>第五次（6）：1 2 3 5 7 11 13 14 16  （pri:2,3,5，筛去6*2并停止）<br>第六次（7）：1 2 3 5 7 11 13 16  （pri:2,3,5,7，筛去7*2=14并停止）<br>第七次（8）：1 2 3 5 7 11 13 （pri:2,3,5,7，筛去8*2=16并停止）<br>…</p>
<p>代码如下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> pri[maxn];</span><br><span class="line"><span class="keyword">bool</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])pri[++pri[<span class="number">0</span>]]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=pri[<span class="number">0</span>]&amp;&amp;i*pri[j]&lt;=n;++j)&#123;</span><br><span class="line">            f[i*pri[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>线性筛也可以用于求欧拉函数、莫比乌斯函数，因此弄懂线性筛的原理很重要！</p>
]]></content>
      <tags>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title>背包</title>
    <url>/%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL3Byb2JsZW0vMTczMTU=">题目链接<i class="fa fa-external-link-alt"></i></span><br>容量为 V 的背包，有 n 个物品 ，每一个物品有一个价值 a 和重量 b ，现在要你选择 m 个物品装进背包，求出这 m 个物品价值中位数的最大值。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>题解说的是 m 为偶数时取中位数较大的一个枚举也行，但是貌似这个没单调性？（我枚举最大数没做出来…</p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这题需要求中位数的最大值，因此需要先将所有物品按照从小到大排序<br>然后将问题从求解中位数最大值变成判断中位数是 x 的可能性<br>即我们枚举中位数，然后判断是否能成立</p>
<ol>
<li>m 是奇数时（ m = 2k + 1 )<br>此时我们枚举  $a_i(k+1\leq i \leq n-k)$ ，如果 i 重量最小的 k 个与 i 后重量最小 k 个与 i 的重量之和小于等于 V ，则说明中位数可以为$a_i$。</li>
<li>m 是偶数时（ m = 2k ）<br>此时枚举中位数中较小的一个，要使中位数最大，则中位数中较大的一个要尽量大。<br>我们设$pre_i$表示前 i 个中重量最小的 k 个，设$suf_i$表示 i 后重量最小的 k 个，则不难发现 $pre_i$单减，$suf_i$单增<br>这样的话其实如果枚举中位数较小的一个，中位数较大的一个是可以二分出来的，因为中位数较大的一个越大，$suf_i$越大，反之越小，因此能找大最大的一个。</li>
</ol>
<p>因此就这样边枚举边更新答案即可。</p>
<p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> pre[N],suf[N];</span><br><span class="line"><span class="keyword">int</span> n,m,V;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp;other)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&lt;other.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;V,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i].a,&amp;a[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">int</span> x=m&amp;<span class="number">1</span>;m&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]+a[i].b;</span><br><span class="line">        q.push(a[i].b);</span><br><span class="line">        <span class="keyword">if</span> (q.size() &gt; m<span class="number">-1</span>+x) &#123;</span><br><span class="line">            pre[i]-=q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())q.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        suf[i]=suf[i+<span class="number">1</span>]+a[i].b;</span><br><span class="line">        q.push(a[i].b);</span><br><span class="line">        <span class="keyword">if</span> (q.size() &gt; m) &#123;</span><br><span class="line">            suf[i]-=q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m+<span class="number">1</span>; i &lt;= n-m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[i<span class="number">-1</span>]+suf[i+<span class="number">1</span>]+a[i].b&lt;=V)ans=a[i].a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> L,R,mid,Ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= n-m; ++i) &#123;</span><br><span class="line">            L=i+<span class="number">1</span>,R=n-m+<span class="number">1</span>,Ans=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">                mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(pre[i<span class="number">-1</span>]+a[i].b+suf[mid]&lt;=V)L=mid+<span class="number">1</span>,Ans=mid;</span><br><span class="line">                <span class="keyword">else</span> R=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Ans)ans=max(ans,(<span class="keyword">long</span> <span class="keyword">long</span>)(a[Ans].a+a[i].a));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>牛客每日一题</tag>
        <tag>优先队列</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>莫比乌斯反演学习</title>
    <url>/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来没打算现在就学这个神(yin)仙(jian)东西的，结果这几天来了好几题莫比乌斯反演题…<br><a id="more"></a></p>
<p>我是在这篇<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcGVuZy15bS9wLzg2NDc4NTYuaHRtbA==">博客<i class="fa fa-external-link-alt"></i></span>学的，讲的不错，博客也是真的相当好看，相比之下我的博客就…<br>（也许以后会把我博客搞的也很漂亮吧，立个flag</p>
<h2 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h2><ul>
<li>首先，我们可以先明确一点，莫比乌斯函数并不是什么很高大上的东西，它其实只是一个由容斥系数所构成的函数。$\mu(d)$的定义是：</li>
</ul>
<ol>
<li>当 $d=1$ 时，$\mu(d)=1$.</li>
<li>当 $d=\Pi_{i=1}^{k}p_i$ 且 $p_i$为互异素数时，$\mu(d)=(-1)^k$.（即 d 的所有质因数幂次均不大于1时）</li>
<li>当 $d$ 的任意质因数幂次大于等于 2 ，$\mu(d)=0$.</li>
</ol>
<ul>
<li>当然，莫比乌斯函数也有很多有趣的性质：</li>
</ul>
<ol>
<li>对于任意正整数 n ，$\sum_{d|n}\mu(d)=[n=1]$（这个性质非常重要，后面给出证明）</li>
<li>对于任意正整数 n , $\sum_{d|n}{\frac{\mu(d)}{d}}=\frac{\phi(n)}{n}$（这个性质也很重要）</li>
</ol>
<h3 id="关于性质-1-的证明："><a href="#关于性质-1-的证明：" class="headerlink" title="关于性质 1 的证明："></a>关于性质 1 的证明：</h3><p>假设 $n=\Pi_{i=1}^{k}p_{i}^{k_i}$，因为质因数幂次大于等于 2 的莫比乌斯函数值为 0 ，因此只用考虑幂次为 0/1<br>当 n 不为 1 时，假设 d 中有 i 个互异素数，则有<br>$\sum_{d|n}\mu(d)=\sum_{i=0}^{k}(-1)^{k}*C(k,i)$，这个式子显然为 0 。<br>当 n = 1 时，没有质因数，且根据定义该性质依然成立。<br>证毕。</p>
<h3 id="求解莫比乌斯函数"><a href="#求解莫比乌斯函数" class="headerlink" title="求解莫比乌斯函数"></a>求解莫比乌斯函数</h3><p>可以在线性筛的基础上进行改造，如果没学过线性筛，可以来<a href="/线性筛详解/">这里</a>看看。</p>
<ul>
<li>当 d 为 1 时，$\mu(d)=1$</li>
<li>当 d 为素数时，很显然 $\mu(d)=-1$</li>
<li>当 d 为非素数时，因为线性筛的特殊性质，prime[j] 必定是 i*prime[j] 的最小质因数，如果 i % prime[ j ] ! = 0 ，则根据莫比乌斯的第二个定义， $\mu(i*prime[j])=-\mu(i)$即可，如果 i % prime[ j ] == 0 ，则根据第三个定义，$\mu(i*primep[j])=0$</li>
</ul>
<p>代码如下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mu[maxn],pri[maxn];<span class="comment">//prime简写</span></span><br><span class="line"><span class="keyword">bool</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            pri[++pri[<span class="number">0</span>]]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=pri[<span class="number">0</span>]&amp;&amp;i*pri[j]&lt;=n;++j)&#123;</span><br><span class="line">            f[i*pri[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            mu[i*pri[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>那么，莫比乌斯函数就这么告一段落了。</li>
</ul>
<h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><ul>
<li>解决完莫比乌斯函数的问题后，我们便迎来了重头戏<strong>莫比乌斯反演</strong></li>
<li>定理：F(n)和f(n)是定义在非负整数集合上的两个函数，并且满足条件：<script type="math/tex; mode=display">
F(n)=\sum_{d|n} f(d)</script>那么存在一个结论：<script type="math/tex; mode=display">
f(n)=\sum_{d|n}\mu(d)F(\frac{n}{d})</script>这个定理就称作莫比<strong>乌斯反演定理</strong>。</li>
</ul>
<p><li>莫比乌斯反演的证明主要有两种方式，其中一种就是通过定义来证明；另外一种，我则是会在<strong><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcGVuZy15bS9wLzk0NDY1NTUuaHRtbA==">杜教筛<i class="fa fa-external-link-alt"></i></span></strong>中提到( 利用<em><strong>狄利克雷卷积</strong></em> )。那么我先来说一说第一种证明方法：</li></p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum{\mu(d)F(\frac{n}{d})} &= \sum{\mu(d)\sum_{i|\frac{n}{d}}f(i)} \\
&=\sum_{i|n}f(i)\sum_{d|\frac{n}{i}}{\mu(d)} \\
&=f(n)
\end{aligned}</script><p>其中第二步即将外层枚举 d 改为枚举 i 即可得到，最后一步即性质1。</p>
<ul>
<li>当然，莫比乌斯反演有另外的一种形式，当F(n)和f(n)满足：<script type="math/tex; mode=display">
F(n)=\sum_{n|d}f(d)</script>可以推出<script type="math/tex; mode=display">
f(n)=\sum_{n|d}\mu(\frac{d}{n})F(d)</script></li>
<li>感觉这个式子，可能在莫比乌斯反演中更加好用。</li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>1.<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI1MjI=">HNOI2011 Problem b<i class="fa fa-external-link-alt"></i></span><br><a href="/HNOI2011-Problem-b/">我的题解</a><br>2.<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIyNTc=">YY的GCD<i class="fa fa-external-link-alt"></i></span><br><a href="/YY的GCD/">我的题解</a></p>
]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>SAM详解</title>
    <url>/SAM%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><link rel="dns-prefetch" href="//cdn.mathjax.org" /></p>
<meta name="referrer" content="no-referrer"/>

<h2 id="后缀自动机要干什么"><a href="#后缀自动机要干什么" class="headerlink" title="后缀自动机要干什么"></a>后缀自动机要干什么</h2><p>如果要在一个DAG（有向无环图）上表示出一个字符串的所有子串，应该怎么办？</p>
<a id="more"></a>
<p>很显然，一个最简单的方法是建立一个trie（字典树），如图。（对于 aabab建trie，红色为根，黄色为终止节点，边的方向未画出）<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48640.png" alt=""><br>方法是将原串（ n为其长度，下文默认）的每一个后缀都加入字典树。</p>
<p>大家请观察一下这个字典树，看看它有什么性质。</p>
<p>我们能够直观地总结出来的性质有：</p>
<p>1.有一个源点，若干个终止点。边代表在目前的字符串后加上的字母。<strong>从源点到任意一个节点的任意路径可以形成一个字符串</strong>。<br>2.<strong>从源点到任意节点的任意路径形成的字符串均为原串子串</strong>。从源点到任意节点的任意路径不能形成的字符串均不为原串子串。（简单来说，这个图可以表示，且仅可以表示出原串的所有子串）<br>3.<strong>从源点到任意终止节点的任意路径形成的字符串均为原串后缀</strong>。<br>4.<strong>从源点出发的任意两条不同路径形成的字符串不相同</strong>。</p>
<p>如果满足以上四个性质，那我们便可以用此DAG处理许多事情。比如，判断某一个串是否为原串的子串（做法：从源点跑这个串，跑到 NULL就说明不是子串）、不同子串个数（做法：DAG上DP）等（后缀自动机可以处理的问题则多得多，因为它有更特殊的性质，这个之后再说）。</p>
<p>但是，我们发现了一个问题。<em>这样建立的DAG节点数是 $O(n^2)$<br>的</em>。当 n 很大时，这样的复杂度无法接受。事实上，我们发现图中许多的节点都可以合并，比如： b 之后的部分与 ab 之后的部分完全一致，可以合并。<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48643.png" alt=""></p>
<p>我们现在的任务就是构建出一棵树，使得其具有字典树的性质，且使得点数和边数尽可能小。</p>
<h2 id="后缀自动机特别在哪"><a href="#后缀自动机特别在哪" class="headerlink" title="后缀自动机特别在哪"></a>后缀自动机特别在哪</h2><p>先来看一些定义吧。（<strong>这部分是后缀自动机的精髓，也是后缀自动机真正厉害的地方</strong>）</p>
<p>对于一个子串，它在原串中可能出现在若干的位置。而一个子串 p 出现的这些位置的右端点标号组成的集合，我们称之为 endpos(p)（例如原串为 abcab时，endpos(ab)={2,5}）<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48645.png" alt=""><br>现在我们需要证明三个结论，它们将在算法中发挥重要的作用。</p>
<h3 id="如果两个子串的-endpos-相同，则其中子串一个必然为另一个的后缀"><a href="#如果两个子串的-endpos-相同，则其中子串一个必然为另一个的后缀" class="headerlink" title="如果两个子串的 endpos 相同，则其中子串一个必然为另一个的后缀"></a>如果两个子串的 endpos 相同，则其中子串一个必然为另一个的后缀</h3><p>设较短的字符串为 t ，较长的字符串为 p ，则每个t出现的位置的右端点前$len_t$个与 t 相同，因为endpos( t )=endpos(p)，因此 p 串后至少$len_s$个与 t 相同。（可以自己意会一下）</p>
<h3 id="对于任意两个子串-t-和-p-len-t-leq-len-p-，要么-endpos-p-in-endpos-t-，要么-endpos-p-cap-endpos-t-varnothing"><a href="#对于任意两个子串-t-和-p-len-t-leq-len-p-，要么-endpos-p-in-endpos-t-，要么-endpos-p-cap-endpos-t-varnothing" class="headerlink" title="对于任意两个子串 t 和 p ($len_t\leq len_p$)，要么$endpos(p)\in endpos( t )$，要么$endpos(p) \cap endpos( t )=\varnothing$"></a>对于任意两个子串 t 和 p ($len_t\leq len_p$)，要么$endpos(p)\in endpos( t )$，要么$endpos(p) \cap endpos( t )=\varnothing$</h3><p>证明基本同上：<br>如果 t 是 p 的后缀,则$endpos(p)\in endpos( t )$。<br><br>如果 t 不是 p 的后缀，则 t 和 p 出现的右端点不会相同，若相同，则必定有 t 是 p 的后缀，因此可得$endpos(p)\cap endpos( t )=\varnothing$。</p>
<h3 id="对于-endpos-相同的子串，我们将它们归为一个-endpos-等价类。对于任意一个-endpos-等价类，将包含在其中的所有子串依长度从大到小排序，则每一个子串的长度均为上一个子串的长度减-1-，且为上一个子串的后缀（简单来说，一个-endpos-等价类内的串的长度连续）"><a href="#对于-endpos-相同的子串，我们将它们归为一个-endpos-等价类。对于任意一个-endpos-等价类，将包含在其中的所有子串依长度从大到小排序，则每一个子串的长度均为上一个子串的长度减-1-，且为上一个子串的后缀（简单来说，一个-endpos-等价类内的串的长度连续）" class="headerlink" title="对于 endpos 相同的子串，我们将它们归为一个 endpos 等价类。对于任意一个 endpos 等价类，将包含在其中的所有子串依长度从大到小排序，则每一个子串的长度均为上一个子串的长度减 1 ，且为上一个子串的后缀（简单来说，一个 endpos 等价类内的串的长度连续）"></a>对于 endpos 相同的子串，我们将它们归为一个 endpos 等价类。对于任意一个 endpos 等价类，将包含在其中的所有子串依长度从大到小排序，则每一个子串的长度均为上一个子串的长度减 1 ，且为上一个子串的后缀（简单来说，一个 endpos 等价类内的串的长度连续）</h3><p>显然长度覆盖的区间是连续的，不可能存在空隙。后缀的命题可由结论 2 得到。<br>对于任意两个 endpos 等价类，它们不会同时包含同一个子串。<br>下文有一些地方直接用 endpos(i) 表示 endpos 等价类 i 中子串的 endpos ，请读者注意。<br>由以上三个定理，我们就可以得到一些延伸结论：</p>
<h3 id="endpos等价类个数的级别为-O-n"><a href="#endpos等价类个数的级别为-O-n" class="headerlink" title="endpos等价类个数的级别为$O(n)$"></a>endpos等价类个数的级别为$O(n)$</h3><p>这个命题比较重要。</p>
<p>对于一个<strong>类</strong>（<strong>endpos等价类简称</strong>），根据结论 3，其中有最长的一个子串（ p ）。在 p 第一个字符前添加任意一个字符（满足新形成的字符串为原串子串），得到的字符串必然不属于此类，因此会得到若干个新的类。我们由结论 2 得到新形成的字符串的 endpos 必然为 endpos(p) 的子集。并且在 p 前分别添加两个不同的字符，所得到的两个字符串的 endpos 必然完全不相交。<strong>所以对于此操作（在 p 前添加一个字符），我们可以认为是对一个原集合进行分割，分割得到几个新的集合，且保留原集合</strong>。当然，新的集合还可以继续分割，但是总的分割的次数（指断痕的个数， {1,2,3,4,5}分割成 {1,3},{2,4},{5}的分割次数为 2 ）不会超过原集合的大小，所以最终形成的集合个数也不会超过 2n（<strong>线段树的分割方法为子集个数最多的分法</strong>）。</p>
<p>由此，因为一切 endpos 都是从 {1,2,…,n}（ n 为原串长度）分割出来的，所以 endpos 等价类个数级别为 $O(n)$ 。（这一部分看不懂可以参考clj的ppt）</p>
<p>考虑<strong>分割关系</strong>。一个原集合分割成若干个子集的操作，是不是很像树的一个节点延伸出若干个子节点？我们发现，所有 endpos 等价类依靠这种分割关系，恰好可以构造出一个树形结构。（有时一个类的某些信息会在其儿子处丢失，例如图中 {1,2,4,6}的儿子是 {2}和 {4,6}，它们丢失了位置 1 的信息。至于原因，第四节会讲。）（下图例子的原串为 aababa）<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48734.png" alt=""><br>于是，类之间就有了父子关系。<br><strong>我们称这棵树为parent tree</strong><br>下一个结论</p>
<h3 id="一个类-a-中，有最长的子串，也有最短的子串，我们称最长子串的长度为-len-a-，最短子串长度为-minlen-a-。对于存在父子关系的两个类，设-fa-a-表示类-a-的父亲（也是一个类）。则：-len-fa-a-1-minlen-a"><a href="#一个类-a-中，有最长的子串，也有最短的子串，我们称最长子串的长度为-len-a-，最短子串长度为-minlen-a-。对于存在父子关系的两个类，设-fa-a-表示类-a-的父亲（也是一个类）。则：-len-fa-a-1-minlen-a" class="headerlink" title="一个类 a 中，有最长的子串，也有最短的子串，我们称最长子串的长度为 len(a) ，最短子串长度为 minlen(a) 。对于存在父子关系的两个类，设 fa(a) 表示类 a 的父亲（也是一个类）。则： len(fa(a))+1=minlen(a)"></a>一个类 a 中，有最长的子串，也有最短的子串，我们称最长子串的长度为 len(a) ，最短子串长度为 minlen(a) 。对于存在父子关系的两个类，设 fa(a) 表示类 a 的父亲（也是一个类）。则： len(fa(a))+1=minlen(a)</h3><p>这个结论很显然，从我们推理结论 4 的步骤中就可以看出。在一个类中的最长子串前再添加一个字符，形成的字符串就必然属于其儿子中的一类，且这个新形成的字符串肯定是它所属的类中最短的一个。</p>
<p>因此，我们只用在parent tree中保存len即可， minlen 可由其父亲推出来。我们定义 longest(s) 表示 s 类中的最长子串， shortest(s) 表示 s 类中的最短子串。</p>
<p>我们把每一个类的最长子串写在节点旁，以方便理解。（原串还是 aababa）<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48734.png" alt=""></p>
<p>现在，我告诉大家一个令人震惊的事情：我们要的后缀自动机的节点就是parent tree中的节点！妙啊（可以认为是parent tree和后缀自动机两个图共用同样的节点）只不过边与parent tree中的不同。其中空串所属的节点（parent tree的根）就是后缀自动机的源点。而终止节点便是最大子串（整个原串）所属于的节点（属于：这个节点的类包含此子串），以及其在parent tree上的祖先（标橙）!为什么要这么做呢？因为其节点数很少，且边数也很少（下有证明）。最重要的是，这样形成的图依靠parent tree，有非常有趣的性质，这个本节最后会说。</p>
<p>我们需要考虑如何建立parent tree，以及如何在这些点上连后缀自动机的边，使得从源点出发到达点 i 的任意一条路径形成的字符串均属于节点 i 所代表的类。</p>
<p>完成的后缀自动机如下（蓝色为后缀自动机的边）：<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48741.png" alt=""><br>（太丑了是吗……之后的部分会给更好的图。其实这个图形不符合之后我们讲的后缀自动机的形态，不过这里只是为了展现后缀自动机有多么复杂而已……）</p>
<p>还可以理解为，延parent tree的边往下走是在字符串前面添加字符，延自动机的边往下走是在字符串后面添加字符。在第四节我们将看到，正是因为上面的特性，parent tree主要用来求节点（即各个字符串）的性质，而后缀自动机本身则主要用来直接跑字符串。</p>
<p>我们先简单说明一下满足条件的后缀自动机是一定存在的。还记得第一节提到的后缀自动机必须满足的四个基本性质吗？对于前三个后缀自动机可以满足。对于第四个，由于上文说道，对于任意两个 endpos 等价类，它们不会同时包含同一个子串，因此到达任意两个不同节点可能形成的字符串均不会重复。现在我们只需要说明边的正确性即可。若对于一个类的所有子串，我们都在它们后面添加一个相同的字符，则得到的所有新的字符串必定都属于另一个相同的类（想想是不是这样）。因此边存在正确性。所以后缀自动机存在。（这里的解释还是不够严谨，如果需要严谨解释可以用类似数学归纳法的方法结合程序说明。因为程序是递推的，初始状态的后缀自动机满足条件，程序正确，所以加入一个新的字符后的后缀自动机也满足条件。这里如果看不懂，可以看完第三节后再尝试理解）</p>
<p>另外，得到点的数量级还不够。下面再证一个比较重要的结论：</p>
<h3 id="后缀自动机的边数为-O-n"><a href="#后缀自动机的边数为-O-n" class="headerlink" title="后缀自动机的边数为 $O(n)$"></a>后缀自动机的边数为 $O(n)$</h3><p>考虑对于一个后缀自动机：先求出其任意一个生成树，舍弃其其它边。我们知道，后缀自动机上有若干个终止节点。于是我们便从每个终止节点往回跑所有属于它（这个类）的子串（从终止节点跑其实就是跑原串的后缀）。注意这里的往回跑是指：对于一个子串，按照原本后缀自动机到达其的唯一路径经过的边往回跑，而非只考虑边的字符，因为可能有多条代表相同字符的边指向同一个节点。</p>
<p>对于每个终止节点：我们按一定顺序跑遍属于它的子串。如果能顺利跑回源点，则跑下一个子串。否则，连上本应该跑回的边，沿它跑回下一个节点。此时，从这个节点出发，一定有一条或多条路径（经过现存的边）回到源点（因为有树的基础结构），则我们往回跑其中任意一条路径。这样，实际走的路径形成的字符串不一定是原本希望跑的子串，但是因为加了一条新边，且路径是从同样的终止节点开始的，所以得到的字符串必然属于此类，且未被跑过。我们只需要将这个字符串在将来要跑的子串中划掉即可。之后重跑我们原本希望跑的子串，直到真正顺利跑完这个子串，再按顺序跑下一个子串。可以发现，我们在此过程中增加的边数不会超过此节点 endpos 的大小。</p>
<p>这样，当跑完所有终止节点时，在原本的生成树上增加的边不会超过后缀的个数，即 n 个。而此时，增加了边的后缀自动机已经完整了。于是，生成树的边数加 n ，数量级为 $O(n)$。（这里与clj的ppt上的证明方法是刚好相反的，clj的证明是从源点开始向各个终止节点跑后缀，而非从终止节点往回跑到源点。）</p>
<p>为了方便理解以上内容，我们再画图讲解一下。下文的图解内容完全模拟上述证明方法。<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48878.png" alt=""><br>以上是原串 abcd 的后缀自动机，我们随机取它的一个生成树：<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48879.png" alt=""><br>终止节点只有 5一个。属于 5 的后缀有（abcd,bcd,cd,dabcd,bcd,cd,d）。我们按照（cd,d,abcd,bcdcd,d,abcd,bcd）的顺序跑后缀。跑 cd 时，我们发现可以直接沿 5-4-1 跑回源点，所以跑下一个子串。</p>
<p>跑 d 时，我们发现确实有一条 d 边连向 5,但是跑这条边回到的点的 endpos是 {3}，并不是应该的 {1,2,3,4}（ d 往回跑一个字符就是去掉其结尾字符得到空串， endpos 为 {1,2,3,4}）。所以此时我们需要连一条边，从代表 {1,2,3,4}的 1 连到 5 ：<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48882.png" alt=""><br>跑 abcd 时，我们先跑回 4 节点，符合条件（去掉末尾剩下 abcabc， endpos 为 {3}，属于节点 4 ）。接下来，我们发现无法继续跑回，于是增加从 3 到 4 的 c 边：<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48889.png" alt=""><br>此时剩下 ab，到达点 3 ，我们还是没办法跑它跑回源点。但是，我们不一定要跑它跑回源点，只要能跑回源点就行了。于是，我们往回跑 1 到 3 的边（代表 b ）。那么现在，我们就等于跑了 $b+c+d=bcd$ 的后缀了，它是一个之后我们要跑的后缀，我们把它划掉。然后接着往回跑 abcd ，连上 1 到 2 的边：<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48891.png" alt=""><br>跑 bcd 时，我们发现它已经被划掉了，所以不用跑。</p>
<p>这样，我们跑完了所有后缀，增加了不多于 n 条边，完成了后缀自动机。（这个例子应该看得懂吧）</p>
<p>在进入下一节之前，我们再来说一说后缀自动机的特殊性。前面说到，后缀自动机的一般性可以让我们处理的问题有：判断子串，计算不同子串个数等。</p>
<p>而后缀自动机的特别之处在于parent tree与节点本身的特殊意义（ endpos 本质为在原串中出现的位置的集合）。这就导致可以通过在parent tree上DP得到每一个类中的子串和在原串中出现的位置相关的一些信息。例如，出现的次数，第一次出现的位置，出现在某个位置之后的次数等。这就导致后缀自动机可以处理更多类型的题目。</p>
<p>最后，我们梳理一下后缀自动机的性质，这些性质可能会对理解后缀自动机的构造方法有很大作用：</p>
<p>1.有一个源点，边代表在当前字符串后增加一个字符。<br>2.每个点代表一个 endpos等价类，到达一个点的路径形成的子串必须属于此点的类。<br><br>3.点之间有父子关系，到达点 i 的所有字符串的长度都必然大于到达 fa(i) 的所有字符串的长度，且到达 fa(i) 的任意一字符串必为到达 i 的任意一字符串的后缀。</p>
<h2 id="后缀自动机怎么构造"><a href="#后缀自动机怎么构造" class="headerlink" title="后缀自动机怎么构造"></a>后缀自动机怎么构造</h2><p>说了这么多，终于讲到构造了。</p>
<p>我们先简单描述一下后缀自动机的形态。后缀自动机大概是长这样子的<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48960.png" alt=""><br>下面那整齐的一行节点表示的就是各个前缀所属的节点。显然，对于任意一个前缀，它在它所属的类中长度是最长的（不能再在其前面添加字符）。而相邻两个前缀所属点之间也肯定有连边。当然，不相邻的节点之间也会有一些边。所以我们把这些节点排成一行，方便观察。</p>
<p>而上面那些零零散散的节点则是不包含任意一个前缀的节点，有一些边连上去，有一些边连下来（注意，连上去的边与连下去的边分割没有那么明显，图只是示意，不要误解），它们之间还有一些连边。这就是后缀自动机的基本结构。</p>
<p>后缀自动机的构造是在线的，即我们通过不断添加单个字符的方式构建后缀自动机，时刻调整其状态。简单来说，我们把原串拆成一个个字符，按顺序塞进后缀自动机里。</p>
<p>先上程序吧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> len,fa;</span><br><span class="line">    NODE()&#123;<span class="built_in">memset</span>(ch,<span class="number">0</span>,<span class="keyword">sizeof</span>(ch));len=<span class="number">0</span>;&#125;</span><br><span class="line">&#125;dian[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> las=<span class="number">1</span>,tot=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=las;<span class="keyword">int</span> np=las=++tot;</span><br><span class="line">    dian[np].len=dian[p].len+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p&amp;&amp;!dian[p].ch[c];p=dian[p].fa)dian[p].ch[c]=np;</span><br><span class="line">    <span class="keyword">if</span>(!p)dian[np].fa=<span class="number">1</span>;<span class="comment">//以上为case 1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q=dian[p].ch[c];</span><br><span class="line">        <span class="keyword">if</span>(dian[q].len==dian[p].len+<span class="number">1</span>)dian[np].fa=q;<span class="comment">//以上为case 2</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nq=++tot;dian[nq]=dian[q];</span><br><span class="line">            dian[nq].len=dian[p].len+<span class="number">1</span>;</span><br><span class="line">            dian[q].fa=dian[np].fa=nq; </span><br><span class="line">            <span class="keyword">for</span>(;p&amp;&amp;dian[p].ch[c]==q;p=dian[p].fa)dian[p].ch[c]=nq;<span class="comment">//以上为case 3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[MAXN];<span class="keyword">int</span> len;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)add(s[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（很多教材都没有很好地解释循环在条件满足时停止的原因，这也是本人当初不理解程序的重要地方之一，因此下文会花较大篇幅讲解循环的意义。）</p>
<p>相信大家肯定看不懂吧……（网上有博客说很好理解？？？）</p>
<p>但至少主函数内的东西应该是看的懂的，即读入原串，然后通过在线的方式一个个加入字符，通过 ans 函数构造后缀自动机。</p>
<p>那么 dian 就是后缀自动机里的节点。结构体里的 len 和 fa 与第二节里的定义一致。而 ch 则与 trie 里的边意义相近。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=las;<span class="keyword">int</span> np=las=++tot;</span><br><span class="line">    dian[np].len=dian[p].len+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><br>首先看第一行。 las 是什么？是未加入此字符前最长的前缀（整个串）所属的节点的编号， tot则是当前后缀自动机节点的总数。</p>
<p>新加入了一位字符 c（减了 ‘a’是为了方便塞进边里，可类比 trie 里对字符的处理）。我们设未加入 c 前的原串为旧串，加入 c 后的原串为新串。显然，此时新串的最长前缀（整个串）所属的节点显然不在原图中，因为原来的所有 endpos 都不可能包含这一位。而旧串的最长前缀就变成了新串的次大前缀。所以我们用 p 记录新串次大前缀（原串的最大前缀）所属的节点，然后新建一个节点 np ，存新的最大前缀所属的类。 len(np) 肯定就是新串的长度，即 len(p)+1 。</p>
<p>注意一下，加入 c 后，endpos 可能发生变化的字符串只有新串的后缀（或者说，旧串的后缀加 c ）（它们无论在旧串出现与否，在新串中出现的次数一定会比在旧串中多 1）。所以我们的任务就是处理好这些endpos发生变化的字符串（具体做法是遍历旧串后缀（事实上是遍历旧串的后缀自动机的终止节点），看看它们加 c 后 endpos 有没有改变）。另外，对于任意一个 endpos 变化的字符串，它的新 endpos 与原来 endpos 的差别只是多了一个 n ，即新串右端点的位置。因此我们判断一个串的 endpos 是否变化，只需要看其是否在新串最后出现即可。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;p&amp;&amp;!dian[p].ch[c];p=dian[p].fa)dian[p].ch[c]=np;</span><br></pre></td></tr></table></figure><br>我们进行一个循环操作。这个循环操作进行下去的条件是： !dian[p].ch[c]（ !p只是防止其跳出根节点），即 p 没有一条 c 的出边。而 p 每一次循环后会跳到 dian[p].fa，即 fa(p)。</p>
<p>首先我们得知道往上跳到底是干什么。我们知道存在父子关系节点包含的子串有后缀关系。那么，这个 p 跳 fa(p) 操作的意思即：一个是 longest(p)（还记得 longest 是什么意思吗？定义在结论 5 的证明下面）的后缀，且与 longest(p) 所属类不同的最长串所属的类。（这里的 longest 改成 shortest 也无妨）</p>
<p>因为由一个节点往外连一条边就等于允许到达此节点的所有字符串往尾部添加一个新的字符。并且，由于 len(fa(i))+1=minlen(i)，因此对于 i 和 fa(i) ，它们包含的子串的长度从大到小排序时也是连续的。所以我们把每一个节点想象成所有到达它的字符串的集合。那么，这个跳 fa(i) 的操作可以理解为压缩地遍历一个串的所有后缀。在这里， p=fa(p) 即从长到短遍历旧串的所有后缀。</p>
<p>对于节点 p ，如果它没有 c 边（即 “longest(p)+c” 非旧串子串），那么引一条新边到 np 。这里用上面的思想解释，即将所有是旧串后缀且在其后面加 c 形成的新字符串不是旧串子串的字符串往新串的最长后缀所属节点连一条 c 边。这样的做法显然是正确的，因为这些后缀加了 c 产生的新字符串不是旧串的子串，但是因为是旧串的后缀，加上 c 后必然是新串后缀，即它们的 endpos={n}=endpos(np) 。因此向 np 连边是正确的。</p>
<p>注意循环的终止条件。如果长度再短，这些旧串后缀加 c 形成的新字符串就已经在旧串里出现过了，显然与新串最长前缀的 endpos 不同，所以不需要继续连边。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!p)dian[np].fa=<span class="number">1</span>;<span class="comment">//以上为case 1</span></span><br></pre></td></tr></table></figure><br>如果已经遍历完了旧串的后缀且它们加 c 一个都不是旧串的子串，就说明 c 实际上是一个在旧串中没有出现过的字符，因此不可能存在除节点 1 以外的祖先，直接令 fa(np)=1。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> q=dian[p].ch[c];</span><br><span class="line">    <span class="keyword">if</span>(dian[q].len==dian[p].len+<span class="number">1</span>)dian[np].fa=q;</span><br></pre></td></tr></table></figure><br>p在第一个有 c 边的祖先停下了（停止原因已在上文说明）。此时，我们将 q 设为 p 的 c 出边到达的节点。此时，我们将做一个非常有趣的判断： len(q) 是否等于 len(p)+1。这个判断是什么意思呢？因为 “longest(p)+c” 是新串后缀，又因为 len(q)==len(p)+1，所以 longest(q)==”longest(p)+c” ，所以 longest(q) 是新串后缀。而 q 类中的所有串都是 longest(q) 的后缀，所以到达 q 的所有串都是新串后缀，它们的 endpos 都增加了 n ，因此到达 q 的所有串的 endpos 一致，符合后缀自动机的定义。由于 q 是我们找到的第一个与 np 不同的且有后缀关系的节点，我们把 fa(np) 设为 q 。<br>此时我们还需要说明一下为什么不用继续跳 fa，判断其他旧串后缀的情况。因为 p 继续跳 fa ，引出的 c 边到达节点 q’ 。那么， q’ 必然是 q 的祖先，那么原先到达 q’ 的串的endpos肯定都增加了一位 n ，满足_到达同一节点的字符串 endpos 都相同_的性质，不需要处理。到此，新串的后缀都已经被检查过了。</p>
<p>为了方便理解以上 case1 和 case2 ，我们举个例画图来讲解一下。</p>
<p>以 aaba 为例。初始只有一个源点：<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48943.png" alt=""><br>加入a，创建节点2 ，len(2)=1 ，连边，1没有a的出边，跳到0 。所以进入case 1 ，直接设fa(2)=1。（蓝边表示parent tree，红字表示 len）<br><img data-src="https://cdn.luogu.com.cn/upload/pic/48952.png" alt=""><br>加入a，创建3。2没有a的出边，所以连边，跳1 。1有a的出边连向2，且 len(2)=1=0+1=len(1)+1，所以进入 case 2，直接 fa(3)=fa(2)。<br><img data-src="https://cdn.luogu.com.cn/upload/pic/49017.png" alt=""><br>加入b。创建4。3和2和1都没有b的出边，连边。所以进入case1，直接fa(4)=1。<br><img data-src="https://cdn.luogu.com.cn/upload/pic/49018.png" alt=""><br>加入a，创建5。4没有a边，跳1。1有a边连向2，且len(2)=len(1)+1。所以进入case2，fa(5)=2。<br><img data-src="https://cdn.luogu.com.cn/upload/pic/49020.png" alt=""><br>如图便是aaba的后缀自动机，大家检查一下，看看符不符合后缀自动机的性质。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> nq=++tot;dian[nq]=dian[q];</span><br><span class="line">    dian[nq].len=dian[p].len+<span class="number">1</span>;</span><br><span class="line">    dian[q].fa=dian[np].fa=nq; </span><br><span class="line">    <span class="keyword">for</span>(;p&amp;&amp;dian[p].ch[c]==q;p=dian[p].fa)dian[p].ch[c]=nq;<span class="comment">//以上为case 3</span></span><br></pre></td></tr></table></figure><br>终于来到后缀自动机构造最难理解的部分了。<br>当 $len(q)\not=len(p)+1$时怎么办？其实这个式子等价于len(q)&gt;len(p)+1，因为p可以到q，所以 $len(q)\ge len(p)+1$。</p>
<p>那么，len(q)&gt;len(p)+1代表了什么呢？它代表了还有至少一个比 “longest(p)+c”更长的串属于q。而这个更长的串必定不是新串的后缀，因为如果是，那么去掉其最后一个字符得到的字符串必然是旧串的后缀，且其长度大于longest(p)，因此应该先被跳到。然而事实并不是这样。所以，现在出现了一个问题：属于q的长度不大len(p)+1的串是新串的后缀（case2说明过），但大于len(p)+1的串却不是。此时，到达q这个节点的字符串并不全属于一个类（准确来说，属于两个类，一类的endpos比另一类的endpos多出了一个n），出现了问题（q的endpos无法得到定义）。而现在，我们要想办法将其中一个类的子串移到另一个节点上，只保留其中一类的字符串，让q的endpos可以得到定义。</p>
<p>我们考虑把endpos多出了n的字符串转移。显然，旧串的后缀自动机中并没有endpos与其相同的节点（如果有，那p本来就应该连向它）。所以我们新建一个节点nq，让endpos多出了n的字符串转移到此节点。</p>
<p>新建了一个节点，要考虑它的连边 ，fa与len。</p>
<p>先考虑len。由上文我们知道，长度大于len(p)+1的字符串都不可能是新串的后缀。并且，p有一条连到nq的边。因此，我们把len(nq)设为len(p)+1。</p>
<p>然后考虑出边。由于nq只是q拆出来的一个点，我们考虑直接用q的边。这样做显然是正确的，因为把nq从q拆出来只是因为nq的endpos与q不一样。但是，在q后和nq后加同样的字符，得到的字符串必然属于同一个类（首先，它们之间必然存在后缀关系且在旧串中属于一个类。又因为这个类中的串必定不是新串的后缀，否则就应该先被跳到，没有受到新加入字符的影响，所以在它们新串中还是同属一个类）。</p>
<p>最后考虑fa。由于原来的q被拆成了两个点q与nq。len(fa(nq))&lt;len(nq)&lt;len(q)。又因为fa(nq)肯定为旧串中的fa(q)，因为在旧串中q和nq还未被分拆。因此，可以看做是nq插入到了这个父子关系中。所以我们让 fa(nq) 等于旧的fa(q)，然后让fa(q)等于nq，类似于链表的插入。</p>
<p>此时，我们考虑np的fa。这个fa肯定是q和nq之一，因为它们最先被跳到。q肯定是不行的，因为它的endpos没有n，而endpos(np)有n。所以fa(np)必为nq。</p>
<p>之后，我们进行一个类似case1的循环操作，不断往上跳fa。只不过，这里的判断条件变成了dian[p].ch[c]==q。意思即，因为q的endpos不包含n，而 “longest(p)+c”的endpos必然含n，不符合后缀自动机性质，所以我们让这条边连向新的节点nq，这样显然是正确的（本就连向q，只是endpos多了一个n，所以连到len紧随其后的fa(q)，即nq）。</p>
<p>那么，为什么当dian[p].ch[c]\not=q时，可以不继续跳了呢？那是因为，这时dian[p].ch[c]的指向的点肯定是q的某个祖先（p变短了，并且”longest(p)+c”还是原来 “longest(p)+c”的后缀，所以q与dian[p].ch[c]满足祖先关系（后缀和长度要求））。那么，我们知道q的父亲是 nq， endpos包含n，因此 q的祖先的endpos都包含n。所以再往上跳，dian[p].ch[c]都不会出现一个节点两种endpos的错误情况了。</p>
<p>另外说一下，程序里dian[nq]=dian[q]的语句是压缩的fa和边的赋值。可以拆分成：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(dian[nq].ch,dian[q].ch);</span><br><span class="line">dian[nq].fa=dian[q].fa;</span><br></pre></td></tr></table></figure><br>以上就是程序的基本思想。</p>
<p>我们继续上图吧（可以对照上面的讲解与程序看一看）。例子：aababa。前面 aaba的图可以继续用。这是aaba的后缀自动机：<br><img data-src="https://cdn.luogu.com.cn/upload/pic/49020.png" alt=""><br>加入b，创建6。5没有b边，连边，跳2。2有b边连向4，但是len(4)\not=len(2)+1，（此时ab和aab都到达4，但二者endpos不同）所以新建节点7，从4复制fa,ch，len(7)=len(2)+1=2，然后令fa(6),fa(4)等于2。之后跳fa，把2连向4的边连向7，1连向4的边连向7。（尽梨了……ppt的曲线就是那么诡异）<br><img data-src="https://cdn.luogu.com.cn/upload/pic/49022.png" alt=""><br>加入a，创建8。6没有a的边，连边，跳7。7有a边连向5，但len(5)\not=len(7)+1，所以新建9，重复之前的操作。<br><img data-src="https://cdn.luogu.com.cn/upload/pic/49026.png" alt=""><br>以上便是构造后缀自动机的全部内容。下面，我们再来证明一些东西。第二节中，我们已经证明了后缀自动机的空间复杂度。现在让我们来证明后缀自动机构造的时间复杂度。</p>
<p>根据程序我们知道，可能超时的地方只有两个跳fa的循环。让我们一一证明它们的均摊时间复杂度是$O(n)$的。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;p&amp;&amp;!dian[p].ch[c];p=dian[p].fa)dian[p].ch[c]=np;</span><br></pre></td></tr></table></figure><br>这是case1的循环。简单想想就知道，这个循环的真面目其实就是加边。因为后缀自动机构造的整个过程中，边数都不会减少，所以这里循环的次数应该与边数数量级相同，不会超过$O(n)$。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;p&amp;&amp;dian[p].ch[c]==q;p=dian[p].fa)dian[p].ch[c]=nq;</span><br></pre></td></tr></table></figure><br>这是case3的循环。这里显然就不能认为是加边了，所以我们得换个思路。是不是可以认为，我们在遍历连向nq的边？因为nq一个新建节点，所以下一次进行这个循环的时候，我们不会再遍历上一个nq的边。又因为所有边被遍历的均摊复杂度是线性的（本人并不怎么会证明，网上资料也不多，如果需要详细了解请参考更高级的教材）。于是，我们可以认为程序对每一个节点的入边都遍历了一次。因此，均摊时间复杂度与边数相同。</p>
<h2 id="后缀自动机该怎么用"><a href="#后缀自动机该怎么用" class="headerlink" title="后缀自动机该怎么用"></a>后缀自动机该怎么用</h2><p>（下文将把后缀自动机和后缀数组进行对比，请未学习后缀数组的同学补一下，或者跳过一些内容）</p>
<p>后缀数组和后缀自动机能处理的相同问题很多，并且各自也有对方不能处理的问题。</p>
<p>后缀数组的时间复杂度是$O(n\log n)$。后缀自动机的时间复杂度是$O(n)$，可能常数会稍微大一点点，但应该还是必后缀数组快（取决于个人代码常数）。但是后缀自动机的做法往往比后缀数组无脑。</p>
<p>下文会列举几个后缀自动机可以解决的问题。如果后缀数组可以解决，也会列出简单解法。<br><strong>问题1：判断子串</strong><br>直接在后缀自动机上跑边，跑完串还未跑到 NULL 则为原串子串。</p>
<p>后缀数组：跑出 sa，然后从最小的后缀开始，一个个往后枚举，记录下当前匹配到的位置，如果匹配不上就下一个后缀，否则位置向后移一位。如果枚举完了后缀还没有完全匹配则不是原串子串。</p>
<p><strong>问题2：不同子串个数</strong><br>DAG上DP。对于一个节点i，f[i]表示从i出发的子串个数（不含空串）。那么，f[i]就等于$\sum_{(i,j)\in Edge}(f[j]+1)$。f[1]即是答案。</p>
<p>或者直接求$\sum(len(i)-len(fa(i)))$，因为后缀自动机上无重复字符串。</p>
<p>后缀数组：每一个后缀的长度减去其height之和。</p>
<p><strong>问题3:在原串所有子串中（相同的不算一个）字典序第i大的是哪个（<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3Uub3JnL3Byb2JsZW1uZXcvc2hvdy9QMzk3NQ==">P3975<i class="fa fa-external-link-alt"></i></span>）</strong><br>这题比较重要。</p>
<p>首先处理出每个节点的endpos大小，即每个类中的串在原串中出现的次数。考虑dp，f[i]代表i的大小。对于不包含任意一个个前缀的节点，$f[i]=\sum{(i,j)\in parent \space treeEdge}f[j]$，因为比longest(i)前面多一个字符的所有字符串的endpos的并集必然等于endpos(longest(i))。而对于包含前缀的节点，$f[i]=(\sum{(i,j)\in parent \space treeEdge}f[j])+1$，因为第1位的信息在加字符时丢失了。（这里是第二节遗留的问题，可以参考第二节的parent tree示意图来理解。因为parent tree上一个节点的出边（方向从fa到ch）相当于对此节点endpos的拆分，拆分方式为在此节点的$longest$前面添加字符。但由于此节点包含前缀，在添加字符时必将丢失此前缀位置的endpos（因为加上字符的子串已经大于前缀长度），所以丢失了1位信息，需要加回来（$update\space 2019.8.15$）（具体到程序来说，只需在case1里加一句f[np]=1即可）</p>
<p>然后DP出g[i]，表示从i出发的子串个数（不含空集且计算重复），则$g[i]=\sum_{(i,j)\in SAM\space Edge}(g[j]+f[j])$。</p>
<p>最后，在后缀自动机上dfs，按字典序遍历出边，排名还够的减去这边的所有子串，不够的跑到这条出边连向的节点，重复以上步骤。当排名变为非正数时输出跑过的路径形成的字符串。具体做法还请参考本题题解。<br><strong>问题4：判断两个串的最长公共子串</strong><br>把两个串拼起来，跑后缀自动机。然后用类似于上面处理出现次数的方法，跑出一个子串在拼起来的串前半部分出现的次数和后半部分出现的次数。然后遍历节点，找len最大的前后出现次数都不为0的节点。以上思路还可以处理多个字符串的最长公共子串。</p>
<p>后缀数组：同样是拼起来，然后处理sa和height，对于每个后缀，找到其之后第一个属于另一半部分的后缀（可以$O(n)$做到，具体做法请读者思考），求它们的lcp，最后取最大值。</p>
<p>还有一些题目与方法本文可能未涉及到，请多多谅解。毕竟这只是给初学者看的文章，想要了解更高级的内容请自行寻找资料。<br><strong>后缀自动机思路精巧，处理问题多样，不失为字符串题目的好算法。</strong></p>
<blockquote>
<p>转载自 <span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvS2VzZGlhZWwzL2hvdS16aHVpLXppLWRvbmctamkteWFuZy14aWU=">KesdiaelKen 的博客<i class="fa fa-external-link-alt"></i></span><br>直接转载格式有误，因此为手工转载，如有错误，请留言指出，或QQ指出。</p>
</blockquote>
]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
</search>
