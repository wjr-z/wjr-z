<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wjr的博客</title>
  
  <subtitle>Explosion!</subtitle>
  <link href="https://wjr-z.com/atom.xml" rel="self"/>
  
  <link href="https://wjr-z.com/"/>
  <updated>2021-01-30T09:52:03.028Z</updated>
  <id>https://wjr-z.com/</id>
  
  <author>
    <name>wjr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Educational Codeforces Round 103 (Rated for Div. 2)</title>
    <link href="https://wjr-z.com/eduRound103/"/>
    <id>https://wjr-z.com/eduRound103/</id>
    <published>2021-01-30T03:29:58.000Z</published>
    <updated>2021-01-30T09:52:03.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我居然能在B题上因为 long long 和向上取整错四次…（人才<br>好在之后几题比较顺<br><a id="more"></a></p><h2 id="A-K-divisible-Sum"><a href="#A-K-divisible-Sum" class="headerlink" title="A. K-divisible Sum"></a>A. K-divisible Sum</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE0NzYvcHJvYmxlbS9B">题目链接<i class="fa fa-external-link-alt"></i></span></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给出 n 和 k ，你要构造一个 n 个元素的数组 a ，a 所有元素的和可以被 k 整除，求出 a 最大元素最小可能是多少。</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>假设 a 中最大元素是 MAX ，则可以得到的数是 $MAX+n-1\sim n*MAX$<br/></p><ul><li>$k\geq n$时，找到最小的MAX使得$n*MAX\geq k$即可，即$\lceil\frac{k}{n}\rceil$<br/></li><li>$k &lt; n$时，如果$n\%k=0$则 MAX = 1 即可满足题意，如果$n\%k\neq 0$，当 MAX = 2 时，可以得到$n+1 \sim 2n$，必定存在一个数能被 k 整除。</li></ul><p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x,T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(n&gt;x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%x==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;2\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x%n==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x/n);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x/n+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="B-Inflation"><a href="#B-Inflation" class="headerlink" title="B. Inflation"></a>B. Inflation</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE0NzYvcHJvYmxlbS9C">题目链接<i class="fa fa-external-link-alt"></i></span></p><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个数组$p_0,p_1…p_{n-1}$，可以令每个$p_i$加上一个非负整数$a_i$，使得$\frac{p_i}{p_0+p_1+…+p_{i-1}}\leq k\%$，要求$\sum_{i=0}^{n-1}a_i$的最小值。</p><h3 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h3><p>这题我花了23分钟，还错了4次…<br>这题是贪心，结论其实可以直接猜出来。<br>我们从前往后处理每个数，如果$\frac{p_i}{p_0+p_1+…+p_{i-1}} &gt; k\%$，则将$p_i$加到使得$\frac{p_i}{p_0+p_1+…+p_{i-1}} \leq k\%$，顺便更新答案即可。<br/><br>这样我们确实前面的是最小化了，但是能否保证后面也能最小化答案呢？<br>如果 $\frac{x}{y}=\frac{k}{100}$ ，则当 y 变化 100 时， x 只变化 k <br/><br>我们假设我们贪心到 i 有 $\frac{p_i+a_i}{p_0+p_1+…+p_{i-1}+x}=\frac{k}{100}$ ，如果分母增大，则分子减少的小于等于分母增加的，因此不会更优，往后处理时均如此。<br/><br>因此这个贪心策略是正确的。</p><p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span>  T,n,k;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">105</span>],d[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> s=a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]*<span class="number">100ll</span>&gt;k*s)&#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> x=<span class="built_in">ceil</span>((<span class="number">100ll</span>*a[i]-k*s)*<span class="number">1.0</span>/k);</span><br><span class="line">                ans+=x;</span><br><span class="line">                s+=x;</span><br><span class="line">            &#125;</span><br><span class="line">            s+=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>那个向上取整其实可以用更好的写法，即$long long x=(100ll*a[i]+k-1)/k-s;$，这样避免了精度问题。</p><h2 id="C-Longest-Simple-Cycle"><a href="#C-Longest-Simple-Cycle" class="headerlink" title="C. Longest Simple Cycle"></a>C. Longest Simple Cycle</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE0NzYvcHJvYmxlbS9D">题目链接<i class="fa fa-external-link-alt"></i></span></p><h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给出 n 条链，每条链的首、尾与上一条链的两个点相连，请求出最大的简单环。<br><img data-src="https://espresso.codeforces.com/f5b742ef7ad02ab00141f54a6dda3eb9bc79d4d3.png" alt=""></p><h3 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h3><p>其实真的很简单。<br>我们设$dp_i$表示第 i 条链和在其之前的链构成的最大简单环的长度，则很显然第 i 条链要么通过与上一条链连接的两个点以及自己构成一个简单环，要么是通过与上一条链构成的最大简单环构成一个新的最大简单环（需要减去重复部分）<br>因此顺着这样求就行了，我为了简便书写就改了一点变量（感觉貌似更复杂了，服了我自己</p><p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T,n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,inf=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N],c[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">        dp[<span class="number">1</span>]=-inf;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            dp[i]=<span class="number">2</span>+<span class="built_in">abs</span>(a[i]-b[i]);</span><br><span class="line">            <span class="keyword">int</span> L=min(a[i],b[i]),R=max(a[i],b[i]);</span><br><span class="line">            <span class="keyword">if</span>(a[i]!=b[i])</span><br><span class="line">                dp[i]=max(dp[i],<span class="number">2</span>+dp[i<span class="number">-1</span>]+L<span class="number">-1</span>+c[i<span class="number">-1</span>]-R);</span><br><span class="line">            ans=max(ans,dp[i]+c[i]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="D-Journey"><a href="#D-Journey" class="headerlink" title="D. Journey"></a>D. Journey</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE0NzYvcHJvYmxlbS9E">题目链接<i class="fa fa-external-link-alt"></i></span></p><h3 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h3><p>n + 1 个城市，从 $0\sim n$<br/><br>给出一个长度为 n 的字符串，如果第 i 位是 L ，表示有一条从 i 到 i-1 的有向边；如果是 R ，表示有一条从 i-1 到 i 的有向边。<br>且每次经过一条边后所有边的朝向改变，对于每一个城市，求出以其为初始位置时能经过的最多城市数。</p><h3 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h3><p>每次朝向会改变，我想都没想直接以时间点为奇数/偶数拆点建图了，初始时间为 0 。<br>然后把样例手模一下，发现一个简单的并查集就能做了，因为每条边都是双向边，并且连接着的是相邻且时间奇偶性不同的连个点，这样一来既不会有一个城市既能在偶数时间点被访问又在奇数时间点被访问，而且因为双向可以互相到达。<br>那么其实缩点也可以做到，不过我这里为了代码书写起来简单直接写了个并查集，其他方法没想过了，反正我觉得拆点后可以秒出。</p><p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> fa[N&lt;&lt;<span class="number">1</span>],siz[N&lt;&lt;<span class="number">1</span>],T,n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=get(fa[x]);&#125;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x=get(x),y=get(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span>;</span><br><span class="line">    fa[x]=y;</span><br><span class="line">    siz[y]+=siz[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> c=<span class="number">2</span>*(n+<span class="number">1</span>),S=n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=c;++i)</span><br><span class="line">            fa[i]=i,siz[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">                link(i+<span class="number">1</span>,i+S);</span><br><span class="line">            <span class="keyword">else</span> link(i,i+<span class="number">1</span>+S);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=S;++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,siz[get(i)]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="E-Pattern-Matching"><a href="#E-Pattern-Matching" class="headerlink" title="E. Pattern Matching"></a>E. Pattern Matching</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE0NzYvcHJvYmxlbS9F">题目链接<i class="fa fa-external-link-alt"></i></span></p><h3 id="题目描述：-4"><a href="#题目描述：-4" class="headerlink" title="题目描述："></a>题目描述：</h3><p>见题目。</p><h3 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h3><p>想清楚就不难，但就是想不清楚，想出来后又觉得我当时为啥这么蠢。</p><p>其实每个字符串最多能匹配$2^4$个模式串，利用拓扑排序的方式即可，如果字符串能匹配 mt 模式串，则将 mt 模式串与其他所有该字符串能匹配的模式串连有向边（起点是 mt ）；如果不能匹配则说明无解。<br>之后拓扑排序即可的出答案。<br>然后就要考虑如何快速得到字符串能匹配到的所有模式串了，可以字典树或者map，具体就不细讲了。</p><p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> ch[N&lt;&lt;<span class="number">2</span>][<span class="number">27</span>],val[N&lt;&lt;<span class="number">2</span>],cnt;</span><br><span class="line"><span class="keyword">int</span> d[N&lt;&lt;<span class="number">1</span>],nxt[N&lt;&lt;<span class="number">4</span>],to[N&lt;&lt;<span class="number">4</span>],tot;</span><br><span class="line"><span class="keyword">int</span> deg[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="keyword">int</span> ans[N&lt;&lt;<span class="number">1</span>],ans2[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    to[++tot]=b;</span><br><span class="line">    nxt[tot]=d[a];</span><br><span class="line">    d[a]=tot;</span><br><span class="line">    ++deg[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>*s,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;_&#x27;</span>)j=<span class="number">26</span>;</span><br><span class="line">        <span class="keyword">else</span> j=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ch[p][j])ch[p][j]=++cnt;</span><br><span class="line">        p=ch[p][j];</span><br><span class="line">    &#125;</span><br><span class="line">    val[p]=id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> f;</span><br><span class="line"><span class="keyword">bool</span> g;</span><br><span class="line"><span class="keyword">int</span> num,mt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">char</span>*s,<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(now&gt;k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(val[p]==mt)&#123;</span><br><span class="line">            g=<span class="literal">true</span>;</span><br><span class="line">            ins(mt,num+n);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ins(num+n,val[p]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    work(ch[p][s[now]-<span class="string">&#x27;a&#x27;</span>],s,now+<span class="number">1</span>);</span><br><span class="line">    work(ch[p][<span class="number">26</span>],s,now+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>),insert(s,i);</span><br><span class="line">    f=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        num=i;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,s+<span class="number">1</span>,&amp;mt);</span><br><span class="line">        g=<span class="literal">false</span>;</span><br><span class="line">        work(<span class="number">1</span>,s,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!g)f=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!deg[i])</span><br><span class="line">            q.push(i);</span><br><span class="line">    &#125;<span class="keyword">int</span> Tim=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=n)</span><br><span class="line">            ans[x]=++Tim;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=d[x];i;i=nxt[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> u=to[i];</span><br><span class="line">            <span class="keyword">if</span>(--deg[u]==<span class="number">0</span>)q.push(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(deg[i])&#123;</span><br><span class="line">            f=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(!ans[i])</span><br><span class="line">            ans[i]=++Tim;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        ans2[ans[i]]=i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans2[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我居然能在B题上因为 long long 和向上取整错四次…（人才&lt;br&gt;好在之后几题比较顺&lt;br&gt;</summary>
    
    
    
    
    <category term="cf比赛" scheme="https://wjr-z.com/tags/cf%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>codeforces Round 698(Div.2)</title>
    <link href="https://wjr-z.com/codeforcesR698/"/>
    <id>https://wjr-z.com/codeforcesR698/</id>
    <published>2021-01-29T03:50:30.000Z</published>
    <updated>2021-01-30T03:39:30.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>（其实是吐槽<br>昨天比赛刚开始换了三次网，换了两次镜像网站才勉强能看到题…<br>游戏体验极差，而且最后还掉了一点分。</p><a id="more"></a><h2 id="A-Nezzar-and-Colorful-Balls"><a href="#A-Nezzar-and-Colorful-Balls" class="headerlink" title="A.Nezzar and Colorful Balls"></a>A.Nezzar and Colorful Balls</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3OC9wcm9ibGVtL0E=">题目链接<i class="fa fa-external-link-alt"></i></span></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定 n 个球，每个球上有一个数字 a ，现在为每个球染色，要使得相同颜色球上的数组 a 是严格递增的，且 a 数组是递增的，求最小颜色数。</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>其实即 a 数组中出现次数最多的次数。<br>证明、代码略。</p><h2 id="B-Nezzar-and-Lucky-Number"><a href="#B-Nezzar-and-Lucky-Number" class="headerlink" title="B.Nezzar and Lucky Number"></a>B.Nezzar and Lucky Number</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3OC9wcm9ibGVtL0I=">题目链接<i class="fa fa-external-link-alt"></i></span></p><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个整数 $d(d\in[1,9])$ ，称一个数字为幸运数字当且仅当这个数字是正整数且至少有一位是 d ，给出 n 个数，对于每个数如果能由若干个幸运数字相加得到，则输出”YES”，否则输出”NO”。</p><h3 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h3><p>我是真没想到这又是一场猜结论场…<br>（是我很菜，所以不能及时推出结论…</p><ul><li>若 $x \geq 10*d$ ，则一定是 YES<br/><br>如果$x\in[10*d,11*d)$，则是 YES<br/><br>如果$x\geq 11*d$，则减去若干个 d 后必定能得到$x’\in[10*d,11*d)$，则是 YES <br/></li><li>若 $x &lt; 10* d$<br>此时暴力判断即可，最简单的判断方式就是 x 减去若干个 d ，判断个位是否为 0 ，因为十位可以任取所以可以不管，如果个位为 0 则一定可以。</li></ul><p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> q,d;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;q,&amp;d);</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">10</span>*d)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">bool</span> f=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(x&gt;=j*d&amp;&amp;((x-j*d)%<span class="number">10</span>==<span class="number">0</span>))&#123;</span><br><span class="line">                        f=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(f)<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="C-Nezzar-and-Symmetric-Array"><a href="#C-Nezzar-and-Symmetric-Array" class="headerlink" title="C.Nezzar and Symmetric Array"></a>C.Nezzar and Symmetric Array</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3OC9wcm9ibGVtL0M=">题目链接<i class="fa fa-external-link-alt"></i></span></p><h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>某数组有 2*n 个互不相同的数，每个数都能在数组中找到一个相反数。<br>令$d_i=\sum_{j=1}^{2n}|a_i-a_j|$，现在给了你数组 d ，试判断是否存在至少一种可能的原数组 a 。</p><h3 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h3><p>前四题三个数学题…<br>首先互不相同且能找出相反数，可以得到不能有 0 ，如果仅存在一个 0 ，则 必定有一个数在原数组中无相反数。<br>然后我们将 a 数组从大到小排序，则前 n 个是正数，后 n 个是负数，并且因为从大到小排序，可以得到：</p><script type="math/tex; mode=display">d_{i}=(a_1-a_i)+(a_2-a_i)+...+(a_i-a_i)+(a_i-a_{i+1})+(a_i-a_{i+2})...+(a_i-a_{2n})</script><p>然后根据相反数的条件，继续化简得到：</p><script type="math/tex; mode=display">\begin{aligned}d_{i}&=(a_1-a_i)+...+(a_i-a_i)+(a_i-a_{i+1})...+(a_i-a_{n})+(a_i+a_{n})+(a_i+a_{n-1})...+(a_i+a_1) \\&=2(a_1+a_2+...+a_i)+(2n-2i)a_i\end{aligned}</script><p>因为原数组从大到小排序了，则 d 应该是先递减后递增，且$d_{i}=d_{2<em>n-i+1}$<br/><br>为了方便，直接将 d 从小到大排序或者从大到小排序然后每两个判断下是否相同，即初步判断是否合法。<br>然后根据上述的式子推出原数组即可，例如 $2n\</em>a_1=d_1$ ，然后后面的做差即可求出。<br>我当时脑子有点乱，所以代码写的有点乱…<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[N],a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;d[i]);</span><br><span class="line">        sort(d+<span class="number">1</span>,d+<span class="number">2</span>*n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">bool</span> f=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i]!=d[i+<span class="number">1</span>])&#123;</span><br><span class="line">                f=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(d[<span class="number">2</span>*n]%(<span class="number">2</span>*n)!=<span class="number">0</span>||d[<span class="number">2</span>*n]==<span class="number">0</span>)f=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[n]=d[<span class="number">2</span>*n]/(<span class="number">2</span>*n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=n-i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> p=(<span class="number">2</span>*n<span class="number">-2</span>*j+<span class="number">2</span>)*a[i+<span class="number">1</span>]+d[<span class="number">2</span>*i]-d[<span class="number">2</span>*(i+<span class="number">1</span>)];</span><br><span class="line">            <span class="keyword">if</span>(p%(<span class="number">2</span>*n<span class="number">-2</span>*j+<span class="number">2</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">                f=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a[i]=p/(<span class="number">2</span>*n<span class="number">-2</span>*j+<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(!a[i]||a[i]==a[i+<span class="number">1</span>]||a[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                f=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="D-Nezzar-and-Board"><a href="#D-Nezzar-and-Board" class="headerlink" title="D.Nezzar and Board"></a>D.Nezzar and Board</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3OC9wcm9ibGVtL0Q=">题目链接<i class="fa fa-external-link-alt"></i></span></p><h3 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给出 n 个数，每次任选两个数 x , y ，并向数组中加一个数 2x - y ，问是否能得到 k </p><h3 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h3><ol><li>若 n = 2 ，则可以得到的数是 x + k ( x - y ) ，即得到的数相差均为 ( x - y ) 的倍数，并且 x 和 y 均在得到的数中（这不是废话么</li><li>若 n = 3 ，任意取一个前两个数能得到的数 o ，则可以得到所有和 o 相差 x - y 和 z - o （z为第三个数）的数，然后这些数相差最小为 gcd( x - y , z - o )，既可以得到所有和 o 相差 gcd( x - y , z - o )的数<br>然后 o 随便取都行，只要是前两个数能得到的数即可，反正最后不会影响 gcd 的取值</li><li>n 无限制，即求出查分数组的 gcd ，然后判断 gcd 是否能整除 $k-a_1$即可。</li></ol><p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;<span class="keyword">return</span> !b?a:gcd(b,a%b);&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;n ,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> GCD=<span class="built_in">abs</span>(a[<span class="number">2</span>]-a[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;++i)</span><br><span class="line">            GCD=gcd(GCD,<span class="built_in">abs</span>(a[i]-a[i<span class="number">-1</span>]));</span><br><span class="line">        <span class="keyword">if</span>((k-a[<span class="number">1</span>])%GCD==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;（其实是吐槽&lt;br&gt;昨天比赛刚开始换了三次网，换了两次镜像网站才勉强能看到题…&lt;br&gt;游戏体验极差，而且最后还掉了一点分。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cf比赛" scheme="https://wjr-z.com/tags/cf%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>Steps to One</title>
    <link href="https://wjr-z.com/Steps-to-One/"/>
    <id>https://wjr-z.com/Steps-to-One/</id>
    <published>2021-01-25T11:39:09.000Z</published>
    <updated>2021-01-25T12:15:27.979Z</updated>
    
    <content type="html"><![CDATA[<p>这一题质量是真的不错，做了很久才做出来（初学莫比乌斯反演，别骂了<br><a id="more"></a></p><p>题目描述：<br>每次随机选出 $1\sim m$中的一个数，当已有的数的 gcd 为 1 时停止，问停止时的期望次数。<br/><br><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL3Byb2JsZW0vMTEzNTUy">题目链接<i class="fa fa-external-link-alt"></i></span></p><p>题解：</p><ul><li>看到的一个<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLm5vd2NvZGVyLm5ldC9uLzQ2YTU2YjYwMTlkMzRlYjM5OWE4MmM1NmJjZWQyZjJj">神仙题解<i class="fa fa-external-link-alt"></i></span>，复杂度是O(m)。</li><li>我的题解<br>假设$F_i$是 gcd 为 i 时变成 1 的期望次数，则不难得出$F_i=1+\frac{1}{m}\sum_{j=1}^{m}F_{gcd(i,j)}$<br/><br>这个$gcd(i,j)$下标不好处理，我们将其变为枚举 $gcd(i,j)$，则可以得到：<br/><script type="math/tex; mode=display">F_{i}=1+\frac{1}{m}\sum_{d|i}F_{d}\sum_{j=1}^{m}[gcd(i,j)==d]</script>内层循环是可以进一步化简的，我们设$g(d)=\sum_{i=1}^{m}[gcd(i,n)==d],G(d)=\sum_{i=1}^{m}[d|gcd(i,n)]$<br/><br>可以得出<script type="math/tex; mode=display">\begin{aligned}&G(d)=\sum_{d|k}g(k)=\lfloor\frac{m}{d}\rfloor[n\%d==0] \\&g(d)=\sum_{d|k}\mu(\frac{k}{d})G(k)=\sum_{d|k}\mu(\frac{k}{d})\lfloor\frac{m}{k}\rfloor[n\%k==0]\end{aligned}</script>然后可以将原式稍微变形，并将上式代入：<script type="math/tex; mode=display">\sum_{j=1}^{m}[gcd(i,j)==d]=\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(\frac{i}{d},j)==1]</script>代入 g(1) ，得<script type="math/tex; mode=display">\begin{aligned}\sum_{k}\mu(k)\lfloor\frac{m}{dk}\rfloor[\frac{i}{d}\%k==0]=\sum_{k|\frac{i}{d}}\mu(k)\lfloor\frac{m}{dk}\rfloor\end{aligned}</script>令 $T=dk$ <script type="math/tex; mode=display">\sum_{T|i}\mu(\frac{T}{d})\lfloor\frac{m}{T}\rfloor</script>代入原式<script type="math/tex; mode=display">\begin{aligned}F_i&=1+\frac{1}{m}\sum_{d|i}F_d\sum_{T|i}\mu(\frac{T}{d})\lfloor\frac{m}{T}\rfloor \\&=1+\frac{1}{m}\sum_{T|i}\lfloor\frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})F_d\end{aligned}</script>内层循环与 i 无关，因此可以进行处理，在求 F 的同时进行更新。<br>注意到左右两边均存在 $F_i$ ，将右边的 $F_i$提出并合并到左边即可<script type="math/tex; mode=display">\begin{aligned}F_i&=1+\frac{1}{m}\sum_{T|i}\lfloor\frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})F_d \\&=1+\frac{1}{m}\sum_{T|i}\lfloor\frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})F_d[d\neq i]+\frac{1}{m}\lfloor\frac{m}{i}\rfloor\mu(1)F_i \\&=1+\frac{1}{m}\sum_{T|i}\lfloor\frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})F_d[d\neq i]+\frac{1}{m}\lfloor\frac{m}{i}\rfloor F_i \\F_{i}&=\frac{m+\sum_{T|i}\lfloor\frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})F_d[d\neq i]}{m-\lfloor\frac{m}{i}\rfloor}\end{aligned}</script>记$g_T=\sum_{d|T}\mu(\frac{T}{d})F_d[d\neq i]$即可，每次求出$F_i$后更新 g ，因为 $g_T$在求出 $F_T$后被更新，因此求$F_T$时不需要特判$T\neq i$。<br/></li></ul><p>代码如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">1e5</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a+b&gt;=mod?a+b-mod:a+b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a-b+mod:a-b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a*<span class="number">1ll</span>*b%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)s=mul(s,a);</span><br><span class="line">        a=mul(a,a);</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> prime[N],mu[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;q[N];</span><br><span class="line"><span class="keyword">bool</span> f[N];</span><br><span class="line"><span class="keyword">int</span> F[N],g[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="literal">true</span>,mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=M;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            prime[++prime[<span class="number">0</span>]]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=prime[<span class="number">0</span>]&amp;&amp;i*prime[j]&lt;=M;++j)&#123;</span><br><span class="line">            f[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            mu[i*prime[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)</span><br><span class="line">        mu[i]=mu[i]&lt;<span class="number">0</span>?mu[i]+mod:mu[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=M;j+=i)</span><br><span class="line">            q[j].push_back(i);</span><br><span class="line">    F[<span class="number">1</span>]=<span class="number">0</span>,g[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=q[i].size()<span class="number">-1</span>;~j;--j)</span><br><span class="line">            F[i]=add(F[i],mul(m/q[i][j],g[q[i][j]]));</span><br><span class="line">        F[i]=add(F[i],m);</span><br><span class="line">        F[i]=mul(F[i],qpow(m-m/i,mod<span class="number">-2</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=m;j+=i)</span><br><span class="line">            g[j]=add(g[j],mul(F[i],mu[j/i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        ans=add(ans,F[i]);</span><br><span class="line">    ans=add(<span class="number">1</span>,mul(ans,qpow(m,mod<span class="number">-2</span>)));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这一题质量是真的不错，做了很久才做出来（初学莫比乌斯反演，别骂了&lt;br&gt;</summary>
    
    
    
    
    <category term="莫比乌斯反演" scheme="https://wjr-z.com/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
    <category term="DP" scheme="https://wjr-z.com/tags/DP/"/>
    
    <category term="数论" scheme="https://wjr-z.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>WC2008游览计划</title>
    <link href="https://wjr-z.com/WC2008%E6%B8%B8%E8%A7%88%E8%AE%A1%E5%88%92/"/>
    <id>https://wjr-z.com/WC2008%E6%B8%B8%E8%A7%88%E8%AE%A1%E5%88%92/</id>
    <published>2021-01-22T13:37:38.000Z</published>
    <updated>2021-01-22T13:43:09.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这题我居然觉得难点是回溯…</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题其实和最小斯坦纳树模板很像，只是将边权改为了点权，而斯坦纳树通过 dp 方式转移的时候根节点 i 的点权会被算两次，因此减去一次即可。<br>然后就是套最小斯坦纳树板子了，不过这个回溯着实坑死我了…<br>其实就是记下每个 dp 状态是由什么转移过来的即可，最后从终止状态慢慢往回推，只要是回溯到的点都打上标记，代表这个位置安排了志愿者。</p><p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">11</span>, M = <span class="number">1</span> &lt;&lt; <span class="number">10</span>, inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, c;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, s;</span><br><span class="line">    node(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        s = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;pre[N * N][M];</span><br><span class="line"><span class="keyword">int</span> d[N * N], nxt[N * N * <span class="number">4</span>], to[N * N * <span class="number">4</span>], w[N * N], id[N * N], tot;</span><br><span class="line"><span class="keyword">int</span> maxn, cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    to[++tot] = b;</span><br><span class="line">    nxt[tot] = d[a];</span><br><span class="line">    d[a] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[N * N][M], dis[N * N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="keyword">bool</span> in[N * N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++i) &#123;</span><br><span class="line">        dis[i] = dp[i][s];</span><br><span class="line">        <span class="keyword">if</span> (dis[i] &lt; inf)in[i] = <span class="number">1</span>, q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        in[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = to[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[u] &gt; dis[x] + w[u]) &#123;</span><br><span class="line">                dis[u] = dis[x] + w[u];</span><br><span class="line">                pre[u][s] = node(x, s);</span><br><span class="line">                <span class="keyword">if</span> (!in[u])in[u] = <span class="number">1</span>, q.push(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++i)dp[i][s] = dis[i];</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    maxn = <span class="number">1</span> &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++i)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> S = <span class="number">1</span>; S &lt; maxn; ++S) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> T = (S - <span class="number">1</span>) &amp; S; T; T = (T - <span class="number">1</span>) &amp; S) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = dp[i][T] + dp[i][S ^ T] - w[i];</span><br><span class="line">                <span class="keyword">if</span> (v &lt; dp[i][S]) &#123;</span><br><span class="line">                    dp[i][S] = v;</span><br><span class="line">                    pre[i][S] = node(i, T);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        spfa(S);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">int</span> py[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i - <span class="number">1</span>) * m + j; &#125;</span><br><span class="line"><span class="keyword">bool</span> ans[N * N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x)<span class="keyword">return</span>;</span><br><span class="line">    ans[x] = <span class="literal">true</span>;</span><br><span class="line">    node p = pre[x][s];</span><br><span class="line">    dfs(p.x, p.s);</span><br><span class="line">    <span class="keyword">if</span> (p.x == x)dfs(p.x, p.s ^ s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">int</span> root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = ++c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p);</span><br><span class="line">            w[x] = p;</span><br><span class="line">            <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">                id[x] = cnt++;</span><br><span class="line">                dp[x][<span class="number">1</span> &lt;&lt; id[x]] = <span class="number">0</span>;</span><br><span class="line">                root = x;</span><br><span class="line">                pre[x][<span class="number">1</span> &lt;&lt; id[x]] = node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                id[x] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = i + py[k][<span class="number">0</span>], y = j + py[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x&lt;<span class="number">1</span> || y&lt;<span class="number">1</span> || x&gt;n || y&gt;m)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> a = get(i, j), b = get(x, y);</span><br><span class="line">                ins(a, b);</span><br><span class="line">            &#125;</span><br><span class="line">    work();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[root][maxn - <span class="number">1</span>]);</span><br><span class="line">    dfs(root, maxn - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = get(i, j);</span><br><span class="line">            <span class="keyword">if</span> (id[x] == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans[x])<span class="built_in">printf</span>(<span class="string">&quot;o&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这题我居然觉得难点是回溯…&lt;/p&gt;</summary>
    
    
    
    
    <category term="最小斯坦纳树" scheme="https://wjr-z.com/tags/%E6%9C%80%E5%B0%8F%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>YY的GCD</title>
    <link href="https://wjr-z.com/YY%E7%9A%84GCD/"/>
    <id>https://wjr-z.com/YY%E7%9A%84GCD/</id>
    <published>2021-01-22T12:22:10.000Z</published>
    <updated>2021-01-22T12:38:05.572Z</updated>
    
    <content type="html"><![CDATA[<p>入门级别的题（不过貌似我一开始想复杂了<br><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIyNTc=">题目链接<i class="fa fa-external-link-alt"></i></span><br><a id="more"></a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 $N, M$，求 $1 \leq x \leq N$，$1 \leq y \leq M$ 且 $\gcd(x, y)$ 为质数的 $(x, y)$ 有多少对。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>直接上柿子</p><script type="math/tex; mode=display">Ans=\sum_{k\in prime}\sum_{i=1}^{N}\sum_{j=1}^{M}[gcd(i,j)==k]</script><p>如果莫比乌斯反演做了个几道题，就会知道要化简后面那个式子<br>我们令$f(k)=\sum_{i=1}^{N}\sum_{j=1}^{M}[gcd(i,j)==k],F(k)=\sum_{i=1}^{N}\sum_{j=1}^{M}[k|gcd(i,j)]$<br/><br>然后可以得到</p><script type="math/tex; mode=display">\begin{aligned}&F(k)=\sum_{k|d}f(d)=\lfloor\frac{N}{k}\rfloor\lfloor\frac{M}{k}\rfloor \\\therefore &f(k)=\sum_{k|d}\mu(\frac{d}{k})F(d)=\sum_{k|d}\mu(\frac{d}{k})\lfloor\frac{N}{d}\rfloor\lfloor\frac{M}{d}\rfloor\end{aligned}</script><p>代入到 Ans 中，可以得到</p><script type="math/tex; mode=display">Ans=\sum_{k\in prime}\sum_{k|d}\mu(\frac{d}{k})\lfloor\frac{N}{d}\rfloor\lfloor\frac{M}{d}\rfloor</script><p>这题因为是多组询问，如果我们将$\lfloor\frac{N}{d}\rfloor\lfloor\frac{M}{d}\rfloor$放在内层的话不好进行整数分块，因此要想办法将其放到外层<br/><br>因此我们外层枚举 d ：</p><script type="math/tex; mode=display">Ans=\sum_{d=1}^{min(n,m)}\lfloor\frac{N}{d}\rfloor\lfloor\frac{M}{d}\rfloor(\sum_{k|d,k\in prime}\mu(\frac{d}{k}))</script><p>内层的这个与 N 和 M 无关，因此是可以预处理出其前缀和的，之后就可以进行整除分块了。</p><p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e7</span>+<span class="number">10</span>,M=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> mu[N],prime[M];</span><br><span class="line"><span class="keyword">bool</span> f[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="literal">true</span>,mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="number">1e7</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            prime[++prime[<span class="number">0</span>]]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=prime[<span class="number">0</span>]&amp;&amp;i*prime[j]&lt;=maxn;++j)&#123;</span><br><span class="line">            f[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            mu[i*prime[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=prime[<span class="number">0</span>];++j)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*prime[j]&lt;=maxn;++i)</span><br><span class="line">            sum[i*prime[j]]+=mu[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;++i)</span><br><span class="line">        sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxn=min(n,m);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;l&lt;=maxn;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=min(n/(n/l),m/(m/l));</span><br><span class="line">        ans+=(sum[r]-sum[l<span class="number">-1</span>])*(n/l)*(m/l);</span><br><span class="line">    &#125;<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,n,m;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,F(n,m));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;入门级别的题（不过貌似我一开始想复杂了&lt;br&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P2257&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    
    <category term="莫比乌斯反演" scheme="https://wjr-z.com/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>HNOI2011 Problem b</title>
    <link href="https://wjr-z.com/HNOI2011-Problem-b/"/>
    <id>https://wjr-z.com/HNOI2011-Problem-b/</id>
    <published>2021-01-22T11:21:07.000Z</published>
    <updated>2021-01-22T11:45:31.859Z</updated>
    
    <content type="html"><![CDATA[<ul><li>莫比乌斯反演入门题，让刚学莫比乌斯反演的我有了继续学下去的欲望。</li></ul><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>n 次询问 $\sum_{i=a}^{b}\sum_{j=c}^{d} [gcd(i,j)==k]$ 。<br><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI1MjI=">题目链接<i class="fa fa-external-link-alt"></i></span></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>数学题没啥好说的，这题显然的莫比乌斯反演题，把其变为可以莫比乌斯反演的形式即可。<br>并且可以用一个简单地容斥将下限都换成 1 。<br>设 $f(k)=\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)==k]$ ， $F(k)=\sum_{i=1}^{n}\sum_{j=1}^{m}[k|gcd(i,j)]$<br/><br>则有<br>$F(k)=\sum_{k|d}f(d)=\lfloor\frac{n}{k}\rfloor\lfloor\frac{m}{k}\rfloor$<br>前者很显然，后者因为只要求是 k 倍数的gcd，则 i , j 均为 k 的倍数即可。<br>然后我们开始愉快的推式子：</p><script type="math/tex; mode=display">\begin{aligned}&\because F(k)=\sum_{k|d}f(d) \\&\therefore f(k) =\sum_{k|d}\mu(\frac{d}{k})F(d) \\\end{aligned}</script><p>即</p><script type="math/tex; mode=display">f(k) = \sum_{k|d}\mu(\frac{d}{k})\lfloor\frac{n}{d}\rfloor \lfloor\frac{m}{d}\rfloor</script><p>再令 $T=\frac{d}{k}$</p><script type="math/tex; mode=display">f(k)=\sum_{T}^{\frac{min(n,m)}{k}}\mu(R)\lfloor\frac{n}{kT}\rfloor \lfloor\frac{m}{kT}\rfloor</script><p>然后整除分块即可。<br>关于整除分块，其实就是将$\frac{n}{kT}\frac{m}{KT}$相同的一起处理<br/><br>比如当$T\in(L,R)$时$\frac{n}{kT}\frac{m}{KT}$相同，则这一部分答案为$\frac{n}{kT}\frac{m}{KT}\sum_{i=L}^{R}\mu(i)$，预处理一下莫比乌斯函数的前缀和就好。</p><p>代码如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N],mu[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N];</span><br><span class="line"><span class="keyword">bool</span> f[N];</span><br><span class="line"><span class="keyword">int</span> a,b,c,d,k;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>,f[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="number">5e4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            prime[++prime[<span class="number">0</span>]]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=prime[<span class="number">0</span>]&amp;&amp;i*prime[j]&lt;=maxn;++j)&#123;</span><br><span class="line">            f[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            mu[i*prime[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;++i)</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+mu[i];</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    n/=k,m/=k;</span><br><span class="line">    <span class="keyword">int</span> maxn=min(n,m);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;l&lt;=maxn;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=min(n/(n/l),m/(m/l));</span><br><span class="line">        ans+=(sum[r]-sum[l<span class="number">-1</span>])*(n/l)*(m/l);</span><br><span class="line">    &#125;<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,F(b,d,k)-F(b,c<span class="number">-1</span>,k)-F(a<span class="number">-1</span>,d,k)+F(a<span class="number">-1</span>,c<span class="number">-1</span>,k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;莫比乌斯反演入门题，让刚学莫比乌斯反演的我有了继续学下去的欲望。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="莫比乌斯反演" scheme="https://wjr-z.com/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>莫比乌斯反演学习</title>
    <link href="https://wjr-z.com/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%AD%A6%E4%B9%A0/"/>
    <id>https://wjr-z.com/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-01-22T07:06:26.000Z</published>
    <updated>2021-01-27T14:41:10.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来没打算现在就学这个神(yin)仙(jian)东西的，结果这几天来了好几题莫比乌斯反演题…<br><a id="more"></a></p><p>我是在这篇<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcGVuZy15bS9wLzg2NDc4NTYuaHRtbA==">博客<i class="fa fa-external-link-alt"></i></span>学的，讲的不错，博客也是真的相当好看，相比之下我的博客就…<br>（也许以后会把我博客搞的也很漂亮吧，立个flag</p><h2 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h2><ul><li>首先，我们可以先明确一点，莫比乌斯函数并不是什么很高大上的东西，它其实只是一个由容斥系数所构成的函数。$\mu(d)$的定义是：</li></ul><ol><li>当 $d=1$ 时，$\mu(d)=1$.</li><li>当 $d=\Pi_{i=1}^{k}p_i$ 且 $p_i$为互异素数时，$\mu(d)=(-1)^k$.（即 d 的所有质因数幂次均不大于1时）</li><li>当 $d$ 的任意质因数幂次大于等于 2 ，$\mu(d)=0$.</li></ol><ul><li>当然，莫比乌斯函数也有很多有趣的性质：</li></ul><ol><li>对于任意正整数 n ，$\sum_{d|n}\mu(d)=[n=1]$（这个性质非常重要，后面给出证明）</li><li>对于任意正整数 n , $\sum_{d|n}{\frac{\mu(d)}{d}}=\frac{\phi(n)}{n}$（这个性质也很重要）</li></ol><h3 id="关于性质-1-的证明："><a href="#关于性质-1-的证明：" class="headerlink" title="关于性质 1 的证明："></a>关于性质 1 的证明：</h3><p>假设 $n=\Pi_{i=1}^{k}p_{i}^{k_i}$，因为质因数幂次大于等于 2 的莫比乌斯函数值为 0 ，因此只用考虑幂次为 0/1<br>当 n 不为 1 时，假设 d 中有 i 个互异素数，则有<br>$\sum_{d|n}\mu(d)=\sum_{i=0}^{k}(-1)^{k}*C(k,i)$，这个式子显然为 0 。<br>当 n = 1 时，没有质因数，且根据定义该性质依然成立。<br>证毕。</p><h3 id="求解莫比乌斯函数"><a href="#求解莫比乌斯函数" class="headerlink" title="求解莫比乌斯函数"></a>求解莫比乌斯函数</h3><p>可以在线性筛的基础上进行改造，如果没学过线性筛，可以来<a href="/线性筛详解/">这里</a>看看。</p><ul><li>当 d 为 1 时，$\mu(d)=1$</li><li>当 d 为素数时，很显然 $\mu(d)=-1$</li><li>当 d 为非素数时，因为线性筛的特殊性质，prime[j] 必定是 i*prime[j] 的最小质因数，如果 i % prime[ j ] ! = 0 ，则根据莫比乌斯的第二个定义， $\mu(i*prime[j])=-\mu(i)$即可，如果 i % prime[ j ] == 0 ，则根据第三个定义，$\mu(i*primep[j])=0$</li></ul><p>代码如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mu[maxn],pri[maxn];<span class="comment">//prime简写</span></span><br><span class="line"><span class="keyword">bool</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            pri[++pri[<span class="number">0</span>]]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=pri[<span class="number">0</span>]&amp;&amp;i*pri[j]&lt;=n;++j)&#123;</span><br><span class="line">            f[i*pri[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            mu[i*pri[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>那么，莫比乌斯函数就这么告一段落了。</li></ul><h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><ul><li>解决完莫比乌斯函数的问题后，我们便迎来了重头戏<strong>莫比乌斯反演</strong></li><li>定理：F(n)和f(n)是定义在非负整数集合上的两个函数，并且满足条件：<script type="math/tex; mode=display">F(n)=\sum_{d|n} f(d)</script>那么存在一个结论：<script type="math/tex; mode=display">f(n)=\sum_{d|n}\mu(d)F(\frac{n}{d})</script>这个定理就称作莫比<strong>乌斯反演定理</strong>。</li></ul><p><li>莫比乌斯反演的证明主要有两种方式，其中一种就是通过定义来证明；另外一种，我则是会在<strong><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcGVuZy15bS9wLzk0NDY1NTUuaHRtbA==">杜教筛<i class="fa fa-external-link-alt"></i></span></strong>中提到( 利用<em><strong>狄利克雷卷积</strong></em> )。那么我先来说一说第一种证明方法：</li></p><script type="math/tex; mode=display">\begin{aligned}\sum{\mu(d)F(\frac{n}{d})} &= \sum{\mu(d)\sum_{i|\frac{n}{d}}f(i)} \\&=\sum_{i|n}f(i)\sum_{d|\frac{n}{i}}{\mu(d)} \\&=f(n)\end{aligned}</script><p>其中第二步即将外层枚举 d 改为枚举 i 即可得到，最后一步即性质1。</p><ul><li>当然，莫比乌斯反演有另外的一种形式，当F(n)和f(n)满足：<script type="math/tex; mode=display">F(n)=\sum_{n|d}f(d)</script>可以推出<script type="math/tex; mode=display">f(n)=\sum_{n|d}\mu(\frac{d}{n})F(d)</script></li><li>感觉这个式子，可能在莫比乌斯反演中更加好用。</li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>1.<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI1MjI=">HNOI2011 Problem b<i class="fa fa-external-link-alt"></i></span><br><a href="/HNOI2011-Problem-b/">我的题解</a><br>2.<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIyNTc=">YY的GCD<i class="fa fa-external-link-alt"></i></span><br><a href="/YY的GCD/">我的题解</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本来没打算现在就学这个神(yin)仙(jian)东西的，结果这几天来了好几题莫比乌斯反演题…&lt;br&gt;</summary>
    
    
    
    
    <category term="莫比乌斯反演" scheme="https://wjr-z.com/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
    <category term="数论" scheme="https://wjr-z.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>线性筛详解</title>
    <link href="https://wjr-z.com/%E7%BA%BF%E6%80%A7%E7%AD%9B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://wjr-z.com/%E7%BA%BF%E6%80%A7%E7%AD%9B%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-01-22T05:53:57.000Z</published>
    <updated>2021-01-27T05:21:45.827Z</updated>
    
    <content type="html"><![CDATA[<p>最简单的，最容易想到的筛素数的应该就是直接从小到大，将每个素数的2以上的倍数筛掉了，这个方法复杂度约为 O(N ln ln N)。</p><a id="more"></a><p>举个栗子：<br>初始：&emsp;&emsp; &emsp; &nbsp;&nbsp;&nbsp; 1 2 3 4 5 6 7 8 9 10 11 12<br>第一次（2）：&nbsp;&nbsp; 1 2 3 5 7 9 11<br>第二次（3）：&nbsp;&nbsp; 1 2 3 5 7 11<br>第三次（5）： &nbsp;&nbsp;1 2 3 5 7 11<br>第四次（7）： &nbsp;&nbsp;1 2 3 5 7 11<br>第五次（11）：1 2 3 5 7 11</p><p>如果每次并非是用素数进行筛，复杂度是O(N lnN)（调和级数），因为只用素数筛去，因此复杂度进一步降低了。</p><p>不过这个方法并不是线性的，下面来重点介绍下线性筛。</p><h2 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h2><p>线性筛本质就是让一个数只被筛去一次，而上述的筛法（Eratosthenes筛法）有很多数其实不止被筛去了一次。<br>我们考虑让每个非素数 x=p*q ，其中 p 是 x 分解质因数的最小质数，我们仅让其能被 q 筛去，这样因为每个数仅有一个最小质因数，所以只会被筛去一次，且每个非素数一定会被筛去，因为我们总是能找到这样的 p 和 q </p><h3 id="那么如何实现呢？"><a href="#那么如何实现呢？" class="headerlink" title="那么如何实现呢？"></a>那么如何实现呢？</h3><p>将 q 分解质因数，则 q 也存在一个最小的质因数，假设为 c ，则当 p 不大于 c 时，即代表可以筛去。<br>不过实际上不用求出 q 的最小质因数。<br>我们假设当前是 i ，且我们用了另一个数组 pri 存下来当前找到的所有素数（从小到大），然后考虑用 i 用上述方法筛去非素数，枚举素数，当 i%pri[j]==0 时停止即可，此时代表 i 存在一个 pri[j]这个素数，当 j 继续增加，i 分解质因数后的最小素数比 pri[j]更小，这样会导致部分数筛去多次，因此需要停止。</p><p>举个栗子：<br>初始：&emsp;&emsp;&emsp;&nbsp;&nbsp;       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16<br>第一次（2）：1 2 3 5 6 7 8 9 10 11 12 13 14 15 16  （pri:2，筛去2*2=4并停止）<br>第二次（3）：1 2 3 5 7 8 10 11 12 13 14 15 16  （pri:2,3，筛去3*2=6，3*3=9并停止）<br>第三次（4）：1 2 3 5 7 10 11 12 13 14 15 16  （pri:2,3，筛去4*2=6并停止）<br>第四次（5）：1 2 3 5 7 11 12 13 14 16 （pri:2,3,5，筛去5*2=10，5*3=15并停止）<br>第五次（6）：1 2 3 5 7 11 13 14 16  （pri:2,3,5，筛去6*2并停止）<br>第六次（7）：1 2 3 5 7 11 13 16  （pri:2,3,5,7，筛去7*2=14并停止）<br>第七次（8）：1 2 3 5 7 11 13 （pri:2,3,5,7，筛去8*2=16并停止）<br>…</p><p>代码如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pri[maxn];</span><br><span class="line"><span class="keyword">bool</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])pri[++pri[<span class="number">0</span>]]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=pri[<span class="number">0</span>]&amp;&amp;i*pri[j]&lt;=n;++j)&#123;</span><br><span class="line">            f[i*pri[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>线性筛也可以用于求欧拉函数、莫比乌斯函数，因此弄懂线性筛的原理很重要！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最简单的，最容易想到的筛素数的应该就是直接从小到大，将每个素数的2以上的倍数筛掉了，这个方法复杂度约为 O(N ln ln N)。&lt;/p&gt;</summary>
    
    
    
    
    <category term="线性筛" scheme="https://wjr-z.com/tags/%E7%BA%BF%E6%80%A7%E7%AD%9B/"/>
    
  </entry>
  
  <entry>
    <title>SCOI2005最大子矩阵</title>
    <link href="https://wjr-z.com/SCOI2005%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/"/>
    <id>https://wjr-z.com/SCOI2005%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/</id>
    <published>2021-01-21T04:43:56.000Z</published>
    <updated>2021-01-21T04:56:21.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>这里有一个n*m的矩阵，请你选出其中k个子矩阵，使得这个k个子矩阵分值之和最大。<br>注意：选出的k个子矩阵 不能相互重叠。</p></blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL3Byb2JsZW0vMjAyNDI=">题目链接<i class="fa fa-external-link-alt"></i></span><br><a id="more"></a></p><p>题解：<br>题目范围很重要，$m\leq 2$，当m为1时即简单的数组中取k段连续和的最大值，令dp[i][j]表示前i个取j个子矩阵的最大值即可。<br>当m=2时，即将上述的二维dp改为三维dp即可，令dp[i][j][k]表示第一列前i个，第二列前j个中取k个子矩阵的最大值。<br>dp[i][j][k]初始为max(dp[i-1][j][k],dp[i][j-1][k])，表示不取的转移。<br>1.如果是当前取一个一列的矩阵，则分别在两列进行转移：</p><script type="math/tex; mode=display">\begin{aligned}dp[i][j][k]=max\{dp[p][j][k-1]+s1[i]-s1[p]\}\\dp[i][j][k]=max\{dp[i][p][k-1]+s2[i]-s2[p]\}\end{aligned}</script><p>2.如果是取一个两列的矩阵，则只能在i=j时进行转移：</p><script type="math/tex; mode=display">\begin{aligned}dp[i][i][k]=max\{dp[p][p][k-1]+s1[i]+s2[i]-s1[p]-s2[p]\}\end{aligned}</script><p>其中s1表示第一列前缀和，s2表示第二列前缀和。</p><p>不过后来我发现这样做还是有些问题的，如果m=1并且第一列全为负数，这样第二列当做0算，这样取的k个子矩阵可能有第二列的，但这是非法的，因此需要考虑将m=1和m=2分开来做或者是第二列前缀和进行修改。<br>因为数据范围并不大，因此对第二列前缀和修改即可，而且此题貌似数据也很弱，不考虑也能过。</p><details>    <summary>参考代码</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>][<span class="number">12</span>],s[<span class="number">105</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">105</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0xf3</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">            s[i][j]=s[i<span class="number">-1</span>][j]+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;++j)</span><br><span class="line">            dp[i][j][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            s[i][<span class="number">2</span>]=-i*<span class="number">1e7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=k;++p)<span class="comment">//取p个子矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="comment">//第一列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;<span class="comment">//第二列</span></span><br><span class="line">                dp[i][j][p]=max(dp[i<span class="number">-1</span>][j][p],dp[i][j<span class="number">-1</span>][p]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;i;++l)</span><br><span class="line">                    dp[i][j][p]=max(dp[i][j][p],dp[l][j][p<span class="number">-1</span>]+s[i][<span class="number">1</span>]-s[l][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;j;++l)</span><br><span class="line">                    dp[i][j][p]=max(dp[i][j][p],dp[i][l][p<span class="number">-1</span>]+s[j][<span class="number">2</span>]-s[l][<span class="number">2</span>]);</span><br><span class="line">                <span class="keyword">if</span>(i==j)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;i;++l)</span><br><span class="line">                        dp[i][j][p]=max(dp[i][j][p],dp[l][l][p<span class="number">-1</span>]+s[i][<span class="number">1</span>]+s[i][<span class="number">2</span>]-s[l][<span class="number">1</span>]-s[l][<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[n][n][k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这里有一个n*m的矩阵，请你选出其中k个子矩阵，使得这个k个子矩阵分值之和最大。&lt;br&gt;注意：选出的k个子矩阵 不能相互重叠。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/20242&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    
    <category term="DP" scheme="https://wjr-z.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P4151最大XOR路径</title>
    <link href="https://wjr-z.com/%E6%B4%9B%E8%B0%B7P4151%E6%9C%80%E5%A4%A7XOR%E8%B7%AF%E5%BE%84/"/>
    <id>https://wjr-z.com/%E6%B4%9B%E8%B0%B7P4151%E6%9C%80%E5%A4%A7XOR%E8%B7%AF%E5%BE%84/</id>
    <published>2021-01-20T12:40:27.000Z</published>
    <updated>2021-01-20T13:25:23.685Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个无向图，让你求从 1 到 n 的路径最大异或和。<br><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQxNTE=">题目链接<i class="fa fa-external-link-alt"></i></span><br><a id="more"></a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一条边如果经过偶数次则这条边对答案无影响，如果经过奇数次则有影响。<br>不难发现任意两条路径异或后其实都是若干个环，证明省略。<br>接下来考虑如何找到所有的环。<br>因为异或的性质，因此我们并非需要真的找到所有的环，实际上要找的环十分有限。<br>我们用dfs，每搜到一个点打上 vis 标记，如果下一个点已经 vis 过了，则这个环的异或和丢进线性基，否则继续深搜。<br>这样为什么是对的呢？<br>事实上这样很多的环套环是搜不到的。<br>当我们找到一个环后，这个环因为其所有点均 vis 过，因此包含此环一部分的其他环无法被找到。<br>不过所有的环其实均为若干个简单环异或而成，此处简单环指不可能与其他若干环异或的到新环，而简单环我们可以证明一定都能被找到，加入存在某简单环未在dfs中找到，则说明必定存在环上P，在找到该环前访问过该环上的某点Q，则P，Q之间必定至少存在一个环，说明该环不是简单环，因此可以证明所有简单环一定是能被找到的。<br>然后所有的环都能由若干个简单环异或而成，用线性基便可以得到所有可能异或出的值。<br>再回到最初说的两条路径异或和都是若干个环，这样的话最优路径和我们随便找的一条路径只相差若干个环，将所有的简单环的异或值丢进线性基，然后随便用一个1 到 n 的路径异或和找到异或最大值即可。</p><details>    <summary>参考代码</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50010</span>,M=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">70</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>(x&amp;(<span class="number">1ll</span>&lt;&lt;i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i])x^=f[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                f[i]=x;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> d[N],nxt[M&lt;&lt;<span class="number">1</span>],to[M&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> cost[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">long</span> <span class="keyword">long</span> c)</span></span>&#123;</span><br><span class="line">    to[++tot]=b;</span><br><span class="line">    nxt[tot]=d[a];</span><br><span class="line">    d[a]=tot;</span><br><span class="line">    cost[tot]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">long</span> <span class="keyword">long</span> v)</span></span>&#123;</span><br><span class="line">    dis[x]=v;vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=d[x];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> u=to[i];</span><br><span class="line">        <span class="keyword">if</span>(!vis[u])dfs(u,v^cost[i]);</span><br><span class="line">        <span class="keyword">else</span> insert(v^dis[u]^cost[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Max</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>((ans^f[i])&gt;ans)ans^=f[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        ins(u,v,w);</span><br><span class="line">        ins(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,Max(dis[n]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个无向图，让你求从 1 到 n 的路径最大异或和。&lt;br&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P4151&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    
    <category term="线性基" scheme="https://wjr-z.com/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
  </entry>
  
  <entry>
    <title>牛客挑战赛47E.路径</title>
    <link href="https://wjr-z.com/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B47E-%E8%B7%AF%E5%BE%84/"/>
    <id>https://wjr-z.com/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B47E-%E8%B7%AF%E5%BE%84/</id>
    <published>2021-01-19T12:22:49.000Z</published>
    <updated>2021-01-19T12:41:44.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵树，求所有经过点数大于等于2的无向路径中长度第k小的。</p><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA3NDMvRQ==">题目链接<i class="fa fa-external-link-alt"></i></span></p><a id="more"></a><p>用点分治先预处理出长度为 i 的路径数 ans[i] 。<br>假设当前层重心是 x ，设 a[i] 表示当前已经处理的所有子树到 x 路径长度为 i 的路径数，b[i] 表示正在处理的子树到 x 路径长度为 i 的路径数，则有</p><script type="math/tex; mode=display">ans[i]=\sum_{j=0}^{i}a[j]*b[i-j]</script><p>然后将当前处理子树合并到已处理子树上，两数组相加即可。<br>关于求这个卷积，如果暴力求，很可能会TLE，如果没有TLE说明数据比较水，反正复杂度肯定是不行的。<br>可以用FFT或者NTT来求这个卷积。<br>不过就算这样了其实还是很可能会TLE。<br>假设当前根有 n-1 棵子树，每颗子树仅一个点，且第一个子树和当前根节点连的边为 100000 ，这样的话会被卡到 $O(n* z)$。<br/><br>因此需要将当前根节点的所有子树按照其最长路径从小到大排序后再依次合并，类似于启发式合并，复杂度会降低到$O(z\,logz\,logn)$<br/><br>算上点分治复杂度，总复杂度为 $O(z\,logz\,logn+n\,logn)$<br/><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Complex(<span class="keyword">double</span> a = <span class="number">0</span>, <span class="keyword">double</span> b = <span class="number">0</span>) &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>+(Complex a, Complex b) &#123; <span class="keyword">return</span> Complex(a.x + b.x, a.y + b.y); &#125;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(Complex a, Complex b) &#123; <span class="keyword">return</span> Complex(a.x - b.x, a.y - b.y); &#125;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>*(Complex a, Complex b) &#123; <span class="keyword">return</span> Complex(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> rev[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_rev</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span> &lt;&lt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (s - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i])</span><br><span class="line">            swap(a[i], a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, mid = <span class="number">1</span>; i &lt;= n; i &lt;&lt;= <span class="number">1</span>, mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">Complex <span class="title">wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span> * PI / i), p * <span class="built_in">sin</span>(<span class="number">2</span> * PI / i))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += i) &#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) &#123;</span><br><span class="line">                Complex x = a[k], y = w * a[k + mid];</span><br><span class="line">                a[k] = x + y, a[k + mid] = x - y;</span><br><span class="line">                w = w * wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            a[i].x /= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5e4</span> + <span class="number">10</span>, H = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[H];</span><br><span class="line">Complex F[N], G[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = n + m, bit = <span class="number">0</span>, s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (s &lt;= len)++bit, s &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; ++i)</span><br><span class="line">        F[i].x = a[i], G[i].x = b[i], F[i].y = G[i].y = <span class="number">0</span>;</span><br><span class="line">    get_rev(bit);</span><br><span class="line">    FFT(F, s, <span class="number">1</span>), FFT(G, s, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; ++i)</span><br><span class="line">        F[i] = F[i] * G[i];</span><br><span class="line">    FFT(F, s, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; ++i)</span><br><span class="line">        ans[i] += (<span class="keyword">int</span>)(F[i].x + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[M], siz[M], d[M], nxt[M &lt;&lt; <span class="number">1</span>], to[M &lt;&lt; <span class="number">1</span>], cost[M &lt;&lt; <span class="number">1</span>], tot;</span><br><span class="line"><span class="keyword">bool</span> vis[M];</span><br><span class="line"><span class="keyword">int</span> Siz, rot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    to[++tot] = b;</span><br><span class="line">    nxt[tot] = d[a];</span><br><span class="line">    d[a] = tot;</span><br><span class="line">    cost[tot] = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_rt</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    siz[x] = <span class="number">1</span>; dp[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (u == f || vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        get_rt(u, x);</span><br><span class="line">        siz[x] += siz[u];</span><br><span class="line">        dp[x] = max(dp[x], siz[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[x] = max(dp[x], Siz - siz[x]);</span><br><span class="line">    <span class="keyword">if</span> (dp[x] &lt; dp[rot])rot = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> al, bl;</span><br><span class="line"><span class="keyword">int</span> stk[M], top;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    ++b[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (u == f || vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        dfs(u, x, v + cost[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Max;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, max_dep, cost;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; other)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> max_dep &lt; other.max_dep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;st[M];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_dep</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = dep;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (u == f || vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        c = max(c, get_dep(u, x, dep + cost[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>; al = <span class="number">0</span>;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">        st[cnt].x = u, st[cnt].max_dep = get_dep(u, x, cost[i]);</span><br><span class="line">        st[cnt].cost = cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(st + <span class="number">1</span>, st + <span class="number">1</span> + cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = st[i].x;</span><br><span class="line">        bl = st[i].max_dep;</span><br><span class="line">        dfs(u, x, st[i].cost);</span><br><span class="line">        Merge(a, b, al, bl);</span><br><span class="line">        Max = max(Max, al + bl);</span><br><span class="line">        al = max(al, bl);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= al; ++j)</span><br><span class="line">            a[j] += b[j], b[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= al; ++i)</span><br><span class="line">        a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    rot = <span class="number">0</span>; Siz = s;</span><br><span class="line">    get_rt(x, <span class="number">0</span>);</span><br><span class="line">    x = rot;</span><br><span class="line">    vis[x] = <span class="number">1</span>; calc(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        solve(u, siz[u] &lt; siz[x] ? siz[u] : s - siz[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    dp[<span class="number">0</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        ins(u, v, w);</span><br><span class="line">        ins(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    solve(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Max; ++i)</span><br><span class="line">        ans[i] += ans[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> k;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;k);</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = Max, Ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = L + R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans[mid] &lt; k)L = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> R = mid - <span class="number">1</span>, Ans = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一棵树，求所有经过点数大于等于2的无向路径中长度第k小的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/10743/E&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFT" scheme="https://wjr-z.com/tags/FFT/"/>
    
    <category term="点分治" scheme="https://wjr-z.com/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>FFT详解</title>
    <link href="https://wjr-z.com/FFT%E8%AF%A6%E8%A7%A3/"/>
    <id>https://wjr-z.com/FFT%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-01-18T04:44:14.000Z</published>
    <updated>2021-01-26T12:27:14.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FFT定义"><a href="#FFT定义" class="headerlink" title="FFT定义"></a>FFT定义</h2><blockquote><p>FFT（Fast Fourier Transformation）是离散傅氏变换（DFT）的快速算法。即为快速傅氏变换。它是根据离散傅氏变换的奇、偶、虚、实等特性，对离散傅立叶变换的算法进行改进获得的。<br>(yysy这个定义看着乐呵就好)<br><a id="more"></a></p></blockquote><h2 id="FFT的用处"><a href="#FFT的用处" class="headerlink" title="FFT的用处"></a>FFT的用处</h2><p>在算法竞赛中会碰到卷积形式的计数，或者说多项式乘法，但是常规的计算复杂度是$O(n^2)$的，当 n 比较大的时候，很显然不能满足我们的要求。<br>而FFT将这个过程的复杂度降低到了$O(nlog n)$。</p><h2 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h2><h3 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h3><p>简单来说，形如$a_0+a_1 x+a_2 x^{2}…+a_n a^{n}$的代数表达式叫做多项式，可以记做$f(x)=a_0+a_1 x+a_2 x^{2}…+a_n a^{n}$</p><h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>复数形如$a+bi$，其中$i=\sqrt{-1},i*i=-1$<br/><br>a 叫做复数的实部， b 叫做复数的虚部。<br>复数相乘：</p><script type="math/tex; mode=display">(a1+b1i)*(a2+b2i)=(a1*a2-b1*b2)+(a1*b2+a2*b1)i</script><p>复数$c+di$可以用这种方式表示出来：<br><img data-src="https://tu.sunpma.com/imgs/2021/01/f7bce41a38b84035.png" alt=""><br>复数乘法的在复平面中表现为<strong>辐角相加，模长相乘</strong></p><h3 id="单位根"><a href="#单位根" class="headerlink" title="单位根"></a>单位根</h3><p>复数 w 满足$w^n=1$，则称 w 是 n 次单位根，下图包含了所有的 8 次方根 （下图中圆的半径是1）<br><img data-src="https://tu.sunpma.com/imgs/2021/01/427fa960f8864b4c.png" alt=""></p><p>n 次单位根用 $w_n$ 表示<br/><br>关于单位根有如下性质：<br>1.$w_{2n}^{2}=w_{n}$，因此有$w_{2n}^{2m}=w_{n}^{m}$<br/><br>2.$w_{n}^{\frac{n}{2}}=-1$，因此有$w_{2n}^{m}=-w_{2n}^{m+\frac{n}{2}}$<br/><br>这两个很有用，一定要记住。</p><h3 id="多项式的系数表示法"><a href="#多项式的系数表示法" class="headerlink" title="多项式的系数表示法"></a>多项式的系数表示法</h3><p>这是我们常用的表示方法，即$f(x)=a_0+a_1 x+a_2 x^{2}…+a_n a^{n}$的形式，称$A(X)$是多项式$f(x)$的系数表示法。<br/><br>这样多项式乘法是$O(n^2)$</p><h3 id="多项式的点值表示法"><a href="#多项式的点值表示法" class="headerlink" title="多项式的点值表示法"></a>多项式的点值表示法</h3><p>即用 n+1 个点表示多项式，可以证明 n+1 个不同的点可以唯一确定一个 n 次多项式。<br>其实就是相当于有 n+1 个方程求 n+1 个未知数（ n 次多项式最高此项是n，最多是 n+1 项）<br>也可以将其理解为解系数矩阵。<br>这样多项式乘法是$O(n)$，因为我们只需要两个多项式分别求出$O(n)$个点，然后相乘即可确定两个多项式相乘后的多项式。<br/></p><h2 id="FFT的具体过程"><a href="#FFT的具体过程" class="headerlink" title="FFT的具体过程"></a>FFT的具体过程</h2><p>我们可以看到点值表示法多项式相乘是$O(n)$的，不过要转化为点值相乘却要$O(n^2)$，因此我们要想办法降低这些点值的复杂度。<br/><br>所以FFT即将系数表示法转化为点值表示法再转化回来，其中第一个过程叫 <strong>求值(DFT)</strong>，第二个过程叫 <strong>插值(IDFT)</strong>。</p><h3 id="求值"><a href="#求值" class="headerlink" title="求值"></a>求值</h3><p>还记得我们之前提到的单位根吗？回顾一下：</p><script type="math/tex; mode=display">\begin{aligned}&w_{2n}^{2m}=w_{n}^{m}\\&w_{n}^{m}=-w_{n}^{m+\frac{n}{2}}\\\end{aligned}</script><p>设$A_0(X)$为$A(X)$（这里设其为n次多项式，共n+1项，n+1为偶数）偶数项的和，设$A_1(X)$为$A(X)$奇数项的和，即</p><script type="math/tex; mode=display">\begin{aligned}&A_0(X)=a_0+a_2X+...+a_{n-1}X^{\frac{n}{2}}\\&A_1(X)=a_1+a_3X+...+a_{n}X^{\frac{n}{2}}\\\end{aligned}</script><p>因为$A(w_{n}^{m})=a_0w_{n}^{0}+a_1w_n^{m}+a_2w_n^{2m}+…+a_{n}w_{n}^{nm}$<br/><br>将此多项式偶数项和奇数项分别提出来可以得到</p><script type="math/tex; mode=display">\begin{aligned}&a_0w_n^0+a_2w_n^{2m}+a_4w_n^{4m}+...+a_{n-1}w_n^{(n-1)m}\\&a_1w_n^m+a_3w_n^{3m}+a_5w_n^{5m}+...+a_{n}w_n^{nm}\\\end{aligned}</script><p>根据之前的性质可以得出</p><script type="math/tex; mode=display">\begin{aligned}&A_0(w_{\frac{n}{2}}^{m})=A_0({w_n^{2m}})=a_0w_n^0+a_2w_n^{2m}+a_4w_n^{4m}+...+a_{n-1}w_n^{(n-1)m} \\&A_1(w_{\frac{n}{2}}^{m})=A_1({w_n^{2m}})=a_1w_n^0+a_3w_n^{2m}+a_5w_n^{4m}+...+a_{n}w_n^{(n-1)m}\\\end{aligned}</script><p>因此有$A(w_n^m)=A_0(w_{\frac{n}{2}}^m)+w_n^m*A_1(w_{\frac{n}{2}}^m)$<br/></p><p>且有$A(w_n^{m+\frac{n}{2}})=A_0(w_{\frac{n}{2}}^{m+\frac{n}{2}})+w_{n}^{m+\frac{n}{2}}*A_1(w_{\frac{n}{2}}^{m+\frac{n}{2}})$<br/></p><p>$\because w_{\frac{n}{2}}^{m+\frac{n}{2}}=w_{\frac{n}{2}}^{m}，w_{n}^{m+\frac{n}{2}}=-w_{n}^{m}$<br/></p><p>$\therefore A(w_n^{m+\frac{n}{2}})=A_0(w_{\frac{n}{2}}^{m})-w_{n}^{m}*A_1(w_{\frac{n}{2}}^{m})$<br/></p><p>这样的话，只要知道了$A_0(X)$和$A_1(X)$的点值表示，就可以$O(n)$求出$A(X)$的点值表示。<br/><br>我们将 $2^k$ 次单位根看做是第 k 层，这样我们知道了第 k-1 层的点值表示，就可以推出第 k 层。<br/><br>假设$f(2^k)$是求$2^k$多项式的复杂度，则有$f(2^k)=2*f(2^{k-1})+2^k$，因此复杂度是$O(k*2^k)$，令$n=2^k$，即$O(n log n)$。</p><p>因为这个过程一定要求每层都可以分成两大小相等的部分，所以求的点值必须是$2^k(k\in N)$个，则最高次至多为$2^k-1$，项数至多为$2^k$，如果次数不够，可以将高次项设置为0。</p><p>于是我们就有了递归写法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex* a,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    Complex* a0=<span class="keyword">new</span> Complex[len/<span class="number">2</span>];</span><br><span class="line">    Complex* a1=<span class="keyword">new</span> Complex[len/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        a0[i/<span class="number">2</span>]=a[i];</span><br><span class="line">        a1[i/<span class="number">2</span>]=a[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(a0,len/<span class="number">2</span>);FFT(a1,len/<span class="number">2</span>);</span><br><span class="line">    <span class="function">Complex <span class="title">wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span>*Pi/len),<span class="built_in">sin</span>(<span class="number">2</span>*Pi/len))</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(len/<span class="number">2</span>);i++)&#123;</span><br><span class="line">        a[i]=a0[i]+w*a1[i];</span><br><span class="line">        a[i+len/<span class="number">2</span>]=a0[i]-w*a1[i];</span><br><span class="line">        w=w*wn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但递归版的FFT常数巨大，实现起来比较复杂，于是又有了迭代的写法</p><p>重新考虑下递归FFT的过程，在第 i 次求解中，我们将所有元素二进制 i 位为 0 的放在了左面，i 位为 1 的放在了右面，事实上，每个元素最终到的是他二进制颠倒过来的位置<br>例如：</p><div class="table-container"><table><thead><tr><th>000</th><th>001</th><th>010</th><th>011</th><th>100</th><th>101</th><th>110</th><th>111</th></tr></thead><tbody><tr><td>000</td><td>010</td><td>100</td><td>110</td><td>001</td><td>011</td><td>101</td><td>111</td></tr><tr><td>000</td><td>100</td><td>001</td><td>101</td><td>010</td><td>110</td><td>011</td><td>111</td></tr><tr><td>000</td><td>001</td><td>010</td><td>011</td><td>100</td><td>101</td><td>110</td><td>111</td></tr></tbody></table></div><p>这样子我们将原数组顺序替换成最下面之后就不用再像递归一样每次把原数组的偶数项放左边，奇数项放右边了。<br>关于如何将二进制反转，其实也不难。<br>假设有个数 x ，我们知道了 x&gt;&gt;1 反转后的数，那么 x 反转后的数和 x&gt;&gt;1 反转后的数就差最高位，而这个最高位是 x 的最低位反转后的，然后就很简单了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_rev</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">1</span>&lt;&lt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(s<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后我们再看看非递归版该怎么向上合并。<br>我们对应要求的$x$的值列出来</p><div class="table-container"><table><thead><tr><th>$w_8^0$</th><th>$w_8^1$</th><th>$w_8^2$</th><th>$w_8^3$</th><th>$w_8^4$</th><th>$w_8^5$</th><th>$w_8^6$</th><th>$w_8^7$</th></tr></thead><tbody><tr><td>$w_4^0$</td><td>$w_4^1$</td><td>$w_4^2$</td><td>$w_4^3$</td><td>$w_4^0$</td><td>$w_4^1$</td><td>$w_4^2$</td><td>$w_4^3$</td></tr><tr><td>$w_2^0$</td><td>$w_2^1$</td><td>$w_2^0$</td><td>$w_2^1$</td><td>$w_2^0$</td><td>$w_2^1$</td><td>$w_2^0$</td><td>$w_2^1$</td></tr><tr><td>$w_1^0$</td><td>$w_1^0$</td><td>$w_1^0$</td><td>$w_1^0$</td><td>$w_1^0$</td><td>$w_1^0$</td><td>$w_1^0$</td><td>$w_1^0$</td></tr></tbody></table></div><p>首先最下面一层，只用求一个点，这个点只用求$x=w_{1}^{0}=1$的值即可，所以交换后的数组即为最下面一层的初始值。<br>然后从最下面一层慢慢往上推就行了，可以通过手动模拟画图来找到递推的规律。<br>迭代写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DFT</span><span class="params">(Complex*a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i])<span class="comment">//没这个条件的话，交换两次就会恢复原状</span></span><br><span class="line">            swap(a[i],a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,mid=<span class="number">1</span>;i&lt;=n;i&lt;&lt;=<span class="number">1</span>,mid&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function">Complex <span class="title">wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span>*PI/i),<span class="built_in">sin</span>(<span class="number">2</span>*PI/i))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j+=i)&#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;j+mid;++k)&#123;</span><br><span class="line">                Complex x=a[k],y=w*a[k+mid];</span><br><span class="line">                a[k]=x+y,a[k+mid]=x-y;</span><br><span class="line">                w=w*wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><p>刚刚计算的是 $\vec y = DFT_n(\vec a)$，可以将多项式转化成点值表示，现在为了将点值表示转化成系数表示，需要计算 IDFT（Inverse Discrete Fourier Transform），它是 DFT 的逆</p><p>这个问题实际上相当于是一个解线性方程组的问题，也就是给出了 $n$ 个线性方程 \(\begin{equation*} \left\{ \begin{array}{ccccccccc} a_0(\omega_n^0)^{0}&amp;+&amp;\cdots&amp;+&amp;a_{n-2}(\omega_n^0)^{n-2}&amp;+&amp;+a_{n-1}(\omega_n^0)^{n-1}&amp;=&amp;A(\omega_n^0) \\ a_0(\omega_n^1)^{0}&amp;+&amp;\cdots&amp;+&amp;a_{n-2}(\omega_n^1)^{n-2}&amp;+&amp;+a_{n-1}(\omega_n^1)^{n-1}&amp;=&amp;A(\omega_n^1) \\ \vdots &amp; &amp; \vdots &amp; &amp;\vdots&amp; &amp; \vdots &amp; &amp; \vdots\\ a_0(\omega_n^{n-1})^{0}&amp;+&amp;\cdots&amp;+&amp;a_{n-2}(\omega_n^{n-1})^{n-2}&amp;+&amp;+a_{n-1}(\omega_n^{n-1})^{n-1}&amp;=&amp;A(\omega_n^{n-1}) \end{array} \right. \end{equation*}\)</p><p>写成矩阵方程的形式就是</p><p>\begin{equation} \label{IDFT-equation} \begin{bmatrix} (\omega_n^0)^0 &amp; (\omega_n^0)^1 &amp; \cdots &amp; (\omega_n^0)^{n-1} \\ (\omega_n^1)^0 &amp; (\omega_n^1)^1 &amp; \cdots &amp; (\omega_n^1)^{n-1} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ (\omega_n^{n-1})^0 &amp; (\omega_n^{n-1})^1 &amp; \cdots &amp; (\omega_n^{n-1})^{n-1} \end{bmatrix} \begin{bmatrix} a_0 \\ a_1 \\ \vdots \\ a_{n-1} \end{bmatrix} = \begin{bmatrix} A(\omega_n^0) \\ A(\omega_n^1) \\ \vdots \\ A(\omega_n^{n-1}) \end{bmatrix} \end{equation}</p><p>记上面的系数矩阵为 $\mathbf V$ 现在考虑下面这个矩阵 $d_{ij}=\omega_n^{-ij}$ </p><p>\begin{equation} \mathbf D = \begin{bmatrix} (\omega_n^{-0})^0 &amp; (\omega_n^{-0})^1 &amp; \cdots &amp; (\omega_n^{-0})^{n-1} \\ (\omega_n^{-1})^0 &amp; (\omega_n^{-1})^1 &amp; \cdots &amp; (\omega_n^{-1})^{n-1} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ (\omega_n^{-(n-1)})^0 &amp; (\omega_n^{-(n-1)})^1 &amp; \cdots &amp; (\omega_n^{-(n-1)})^{n-1} \end{bmatrix} \end{equation}</p><p>设它们相乘后的结果是 $\mathbf E=\mathbf D \cdot \mathbf V$</p><p>\begin{eqnarray} e_{ij} &amp;=&amp; \sum_{k=0}^{n-1} d_{ik} v_{kj} \\ &amp;=&amp; \sum_{k=0}^{n-1} \omega_n^{-ik}\omega_n^{kj} \\ &amp;=&amp; \sum_{k=0}^{n-1} \omega_n^{k(j-i)} \end{eqnarray}</p><p>当 $i=j$ 时，$e_{ij}=n$</p><p>当 $i\neq j$ 时，</p><p>\begin{eqnarray} e_{ij} &amp;=&amp; \sum_{k=0}^{n-1} (\omega_n^{j-i})^k \\ &amp;=&amp; \frac{1-(\omega_n^{j-i})^n}{1-\omega_n^{j-i}}\\ &amp;=&amp; 0 \end{eqnarray}</p><p>因此可以知道 $\mathbf I_n=\frac{1}{n}\mathbf E$，所以 $\frac{1}{n}\mathbf D = \mathbf V^{-1}$</p><p>将 $\frac{1}{n}\mathbf D$ 在 $\ref{IDFT-equation}$ 左乘就会得到</p><p>\begin{equation} \begin{bmatrix} a_0 \\ a_1 \\ \vdots \\ a_{n-1} \end{bmatrix} = \frac{1}{n} \begin{bmatrix} (\omega_n^{-0})^0 &amp; (\omega_n^{-0})^1 &amp; \cdots &amp; (\omega_n^{-0})^{n-1} \\ (\omega_n^{-1})^0 &amp; (\omega_n^{-1})^1 &amp; \cdots &amp; (\omega_n^{-1})^{n-1} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ (\omega_n^{-(n-1)})^0 &amp; (\omega_n^{-(n-1)})^1 &amp; \cdots &amp; (\omega_n^{-(n-1)})^{n-1} \end{bmatrix} \begin{bmatrix} A(\omega_n^0) \\ A(\omega_n^1) \\ \vdots \\ A(\omega_n^{n-1}) \end{bmatrix} \end{equation}</p><p>这样，IDFT 就相当于把 DFT 过程中的 $\omega_n^i$ 换成 $\omega_n^{-i}$，然后做一次 DFT，之后结果除以 $n$ 就可以了。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="洛谷P3803-多项式乘法模板题"><a href="#洛谷P3803-多项式乘法模板题" class="headerlink" title="洛谷P3803 多项式乘法模板题"></a>洛谷P3803 多项式乘法模板题</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM4MDM=">多项式乘法模板<i class="fa fa-external-link-alt"></i></span><br>多项式乘法还是有些细节需要注意：<br>1.自带的complex速度不如手写一个Complex，推荐手写一个Complex，并重载运算符。<br>2.注意数组开的大小。<br>3.此题相乘后是最高次是 n+m 次，因此需要至少 n+m+1 个点值。<br>4.因为精度可能出问题，因此最后需要四舍五入。</p><p>下面上代码</p><details>    <summary>参考代码</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;<span class="comment">//实部和虚部</span></span><br><span class="line">    Complex(<span class="keyword">double</span> a=<span class="number">0</span>,<span class="keyword">double</span> b=<span class="number">0</span>)&#123;</span><br><span class="line">        x=a;</span><br><span class="line">        y=b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>+(Complex a,Complex b)&#123;<span class="keyword">return</span> Complex(a.x+b.x,a.y+b.y);&#125;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(Complex a,Complex b)&#123;<span class="keyword">return</span> Complex(a.x-b.x,a.y-b.y);&#125;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>*(Complex a,Complex b)&#123;<span class="keyword">return</span> Complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1</span>&lt;&lt;<span class="number">21</span>|<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> rev[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_rev</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">1</span>&lt;&lt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(s<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex*a,<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;<span class="comment">//p为1即DFT，p为-1即为IDFT</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">            swap(a[i],a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,mid=<span class="number">1</span>;i&lt;=n;i&lt;&lt;=<span class="number">1</span>,mid&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function">Complex <span class="title">wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span>*PI/i),p*<span class="built_in">sin</span>(<span class="number">2</span>*PI/i))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j+=i)&#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;j+mid;++k)&#123;</span><br><span class="line">                Complex x=a[k],y=w*a[k+mid];</span><br><span class="line">                a[k]=x+y,a[k+mid]=x-y;</span><br><span class="line">                w=w*wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)a[i].x/=n;</span><br><span class="line">&#125;<span class="keyword">int</span> n,m;</span><br><span class="line">Complex a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i].x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;b[i].x);</span><br><span class="line">    <span class="keyword">int</span> len=n+m+<span class="number">1</span>,s=<span class="number">1</span>,bit=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s&lt;len)++bit,s&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    get_rev(bit);</span><br><span class="line">    FFT(a,s,<span class="number">1</span>),FFT(b,s,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;++i)a[i]=a[i]*b[i];</span><br><span class="line">    FFT(a,s,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="keyword">int</span>(a[i].x+<span class="number">0.5</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="牛客挑战赛47-E-路径"><a href="#牛客挑战赛47-E-路径" class="headerlink" title="牛客挑战赛47 E.路径"></a>牛客挑战赛47 E.路径</h3><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA3NDMvRQ==">点分治+FFT<i class="fa fa-external-link-alt"></i></span><br><a href="/牛客挑战赛47E-路径/">题解</a></p><blockquote><p>参考文章<br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dBRHVhbjIvYXJ0aWNsZS9kZXRhaWxzLzc5NTI5OTAw">FFT算法讲解<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jsb2cubWlza2Nvby5jb20vMjAxNS8wNC9wb2x5bm9taWFsLW11bHRpcGxpY2F0aW9uLWFuZC1mYXN0LWZvdXJpZXItdHJhbnNmb3JtI21qeC1lcW4tSURGVC1lcXVhdGlvbg==">从多项式乘法到快速傅里叶变换<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>第一篇讲的是针不戳，就是有些细节有点问题，本文已经处理过了（<del>不保证修bug一定不出新bug qwq</del>）</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;FFT定义&quot;&gt;&lt;a href=&quot;#FFT定义&quot; class=&quot;headerlink&quot; title=&quot;FFT定义&quot;&gt;&lt;/a&gt;FFT定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;FFT（Fast Fourier Transformation）是离散傅氏变换（DFT）的快速算法。即为快速傅氏变换。它是根据离散傅氏变换的奇、偶、虚、实等特性，对离散傅立叶变换的算法进行改进获得的。&lt;br&gt;(yysy这个定义看着乐呵就好)&lt;br&gt;</summary>
    
    
    
    
    <category term="FFT" scheme="https://wjr-z.com/tags/FFT/"/>
    
  </entry>
  
  <entry>
    <title>寒假学习计划</title>
    <link href="https://wjr-z.com/%E5%AF%92%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>https://wjr-z.com/%E5%AF%92%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</id>
    <published>2021-01-18T04:30:17.000Z</published>
    <updated>2021-01-19T03:29:56.282Z</updated>
    
    <content type="html"><![CDATA[<p>知识点：<br><a id="more"></a><br>1.线性基<br>2.最小斯坦纳树<br>3.bitset<br>4.点分治<br>5.边分治<br>6.莫比乌斯反演<br>7.杜教筛<br>8.DP<br>9.SAM<br>10.序列自动机<br>11.splay<br>12.替罪羊树<br>13.LCT<br>14.treap及可持久化<br>15.主席树<br>16.线段树合并<br>17.启发式合并<br>18.可撤销并查集<br>19.整体二分<br>20.2-SAT<br>21.欧拉回路<br>22.哈密顿回路<br>23.哈夫曼树<br>24.最大流最小割<br>25.次小生成树<br>26.k小生成树<br>27.差分约束<br>28.中国剩余定理<br>29.欧拉函数<br>30.欧几里得定理<br>31.扩展欧几里得<br>32.容斥原理<br>33.Ploya<br>34.Burnside<br>35.斯特林数<br>36.Min-25筛<br>37.凸包<br>38.半平面交<br>39.FFT<br>40.NTT<br>未完待续…</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;知识点：&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>牛客挑战赛76D.魔物消灭计划</title>
    <link href="https://wjr-z.com/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B76D-%E9%AD%94%E7%89%A9%E6%B6%88%E7%81%AD%E8%AE%A1%E5%88%92/"/>
    <id>https://wjr-z.com/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B76D-%E9%AD%94%E7%89%A9%E6%B6%88%E7%81%AD%E8%AE%A1%E5%88%92/</id>
    <published>2021-01-17T10:43:50.000Z</published>
    <updated>2021-01-17T11:22:27.796Z</updated>
    
    <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA4NDUvRA==">题目链接<i class="fa fa-external-link-alt"></i></span></p><a id="more"></a><p>这题其实就是最小斯坦纳树的模板题…<br>真的，只要会最小斯坦纳树，这题基本秒解。<br>将所有相同宝石当做一个点，然后将x,y也算作必选即可。<br>之后就是套最小斯坦纳树模板了。<br>不过其实也可以不用这样啦，直接将所有相同宝石的点连一个对应宝石的新增点，边权为0，然后初始化的时候，第i个点如果宝石种类是p，令f[i][1&lt;&lt;(p-1)]=0即可。</p><details>    <summary>参考代码</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">120</span>,M=<span class="number">1</span>&lt;&lt;<span class="number">10</span>,inf=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> d[N],nxt[M+<span class="number">2</span>*N],to[M+<span class="number">2</span>*N],cost[M+<span class="number">2</span>*N],tot;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> x,y,cnt;</span><br><span class="line"><span class="keyword">int</span> f[N][M],dis[N];</span><br><span class="line"><span class="keyword">bool</span> in[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    to[++tot]=b;</span><br><span class="line">    nxt[tot]=d[a];</span><br><span class="line">    d[a]=tot;</span><br><span class="line">    cost[tot]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        dis[i]=f[i][S];</span><br><span class="line">        <span class="keyword">if</span>(dis[i]&lt;inf)q.push(i),in[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        in[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=d[x];i;i=nxt[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> u=to[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[u]&gt;dis[x]+cost[i])&#123;</span><br><span class="line">                dis[u]=dis[x]+cost[i];</span><br><span class="line">                <span class="keyword">if</span>(!in[u])in[u]=<span class="number">1</span>,q.push(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)f[i][S]=dis[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Stenier</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt=<span class="number">1</span>&lt;&lt;(k+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)f[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S=<span class="number">0</span>;S&lt;cnt;++S)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> T=S&amp;(S<span class="number">-1</span>);T;T=(T<span class="number">-1</span>)&amp;S)</span><br><span class="line">                f[i][S]=min(f[i][S],f[i][T]+f[i][S^T]);</span><br><span class="line">        spfa(S);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k,&amp;x,&amp;y);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p);</span><br><span class="line">        <span class="keyword">if</span>(i==x)f[i][<span class="number">1</span>&lt;&lt;k]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==y)f[i][<span class="number">1</span>&lt;&lt;(k+<span class="number">1</span>)]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!p)<span class="keyword">continue</span>;</span><br><span class="line">            f[i][<span class="number">1</span>&lt;&lt;(p<span class="number">-1</span>)]=<span class="number">0</span>;</span><br><span class="line">            ins(i,n+p,<span class="number">0</span>);</span><br><span class="line">            ins(n+p,i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;n+=k;</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        <span class="keyword">if</span>(u==v)<span class="keyword">continue</span>;</span><br><span class="line">        ins(u,v,w),ins(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    Stenier();</span><br><span class="line">    <span class="keyword">int</span> ans=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)ans=min(ans,f[i][cnt<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>感觉这样子的话如果去掉相同宝石可以传送，然后去掉建额外边，好像也是可以的？<br>因为其实求最小斯坦纳树除了初始化之外，之后与那k个点无关了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/10845/D&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="最小斯坦纳树" scheme="https://wjr-z.com/tags/%E6%9C%80%E5%B0%8F%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>牛客挑战赛76E.牛牛数数</title>
    <link href="https://wjr-z.com/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B76E-%E7%89%9B%E7%89%9B%E6%95%B0%E6%95%B0/"/>
    <id>https://wjr-z.com/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B76E-%E7%89%9B%E7%89%9B%E6%95%B0%E6%95%B0/</id>
    <published>2021-01-17T10:43:30.000Z</published>
    <updated>2021-01-26T12:25:43.188Z</updated>
    
    <content type="html"><![CDATA[<p>这题如果你会线性基的话，非常简单！</p><p>如果你还没学过线性基可以来看下我的这篇博客：</p><p><a href="/线形基/">线性基详解</a></p><a id="more"></a><p>这题啊，直接异或第k小+二分即可。</p><p>因为能异或出的数的个数知道，找到大于K的最小的数是第几小即可知道大于K的数有多少了。</p><p>不过呢，这题数据较弱，有些细节不考虑都能过，例如可以异或出0时有部分代码会出bug。</p><blockquote><p>hack数据：<br>2 12<br>13 2</p></blockquote><details>    <summary>参考代码</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">62</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[N],p[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> K;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;(<span class="number">1ll</span>&lt;&lt;i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i])x^=d[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                d[i]=x;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            <span class="keyword">if</span>(d[i]&amp;(<span class="number">1ll</span>&lt;&lt;j))d[i]^=d[j];</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">60</span>;++i)</span><br><span class="line">        <span class="keyword">if</span>(d[i])p[cnt++]=d[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> S;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">kth</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>&amp;&amp;cnt&lt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;n)--k;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=cnt<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>(k&amp;(<span class="number">1ll</span>&lt;&lt;i))ans^=p[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">        add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    work();</span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;n)S=<span class="number">1ll</span>&lt;&lt;cnt;</span><br><span class="line">    <span class="keyword">else</span> S=(<span class="number">1ll</span>&lt;&lt;cnt)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> L=<span class="number">1</span>,R=S,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(L&lt;=R)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span>  mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(kth(mid)&lt;=K)L=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> R=mid<span class="number">-1</span>,ans=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,S-ans+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;这题如果你会线性基的话，非常简单！&lt;/p&gt;
&lt;p&gt;如果你还没学过线性基可以来看下我的这篇博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/线形基/&quot;&gt;线性基详解&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="线性基" scheme="https://wjr-z.com/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
  </entry>
  
  <entry>
    <title>codeforces美化</title>
    <link href="https://wjr-z.com/codeforces%E7%BE%8E%E5%8C%96/"/>
    <id>https://wjr-z.com/codeforces%E7%BE%8E%E5%8C%96/</id>
    <published>2021-01-16T09:23:41.000Z</published>
    <updated>2021-01-17T04:02:13.079Z</updated>
    
    <content type="html"><![CDATA[<p>谷歌浏览器的codeforces美化方法。</p><a id="more"></a><p>点击谷歌浏览器右上角自定义及控制（竖着的三个点）<br><img data-src="https://tu.sunpma.com/imgs/2021/01/f4e7104bfe4762d7.png" alt=""><br>点击更多工具并进入扩展程序<br><img data-src="https://tu.sunpma.com/imgs/2021/01/17a05f81538ff962.png" alt=""><br>点击左上角扩展程序并点击弹出的窗口下面的“打开Chrome网上商店”<br><img data-src="https://tu.sunpma.com/imgs/2021/01/f3265b52ed36e54c.png" alt=""><br><img data-src="https://tu.sunpma.com/imgs/2021/01/649074f270b6af0f.png" alt=""><br>在搜索框内搜索stylus<br><img data-src="https://tu.sunpma.com/imgs/2021/01/ab28eb144e5d21e1.png" alt=""><br>点击第一个并添加到Chrome</p><p><span class="exturl" data-url="aHR0cHM6Ly91c2Vyc3R5bGVzLm9yZy9zdHlsZXMvMTkxNjY1L2NvZGVmb3JjZXM=">下载codeforces美化脚本<i class="fa fa-external-link-alt"></i></span></p><p>(可能会比较慢)</p><p>脚本有一个开启/关闭顶栏动画可选。</p><p>Customize Settings中选择turn off即可关闭顶栏动画。（顶栏动画为动态）</p><p>这里还有个wusoj的美化脚本（wustoj是武汉科技大学的OJ）<br><span class="exturl" data-url="aHR0cHM6Ly91c2Vyc3R5bGVzLm9yZy9zdHlsZXMvMTkwNDcxL3d1c3Rvag==">wustoj美化脚本<i class="fa fa-external-link-alt"></i></span></p><p>为了方便起见，可以固定该扩展<br><img data-src="https://tu.sunpma.com/imgs/2021/01/c86897a69b90d969.png" alt=""></p><p>如果想取消某个网站的所有脚本<br><img data-src="https://tu.sunpma.com/imgs/2021/01/3614a2eda352e992.png" alt=""></p><p>如果想更换脚本或者更新脚本请在管理样式界面操作。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;谷歌浏览器的codeforces美化方法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="网站美化" scheme="https://wjr-z.com/tags/%E7%BD%91%E7%AB%99%E7%BE%8E%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>最小斯坦纳树详解</title>
    <link href="https://wjr-z.com/%E6%9C%80%E5%B0%8F%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91%E8%AF%A6%E8%A7%A3/"/>
    <id>https://wjr-z.com/%E6%9C%80%E5%B0%8F%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-01-16T01:56:09.000Z</published>
    <updated>2021-01-17T10:10:52.359Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自:<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc3FydHl6L3AvMTM0Mjc4NjguaHRtbA==">https://www.cnblogs.com/sqrtyz/p/13427868.html<i class="fa fa-external-link-alt"></i></span></p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>摘自百度百科的定义：<br>斯坦纳树问题是组合优化问题，与 最小生成树相似 ，是最短网络的一种。最小生成树是在给定的点集和边中寻求最短网络使所有点连通。而最小斯坦纳树允许在给定点外增加额外的点，使生成的最短网络开销最小。</p></blockquote><a id="more"></a><p>可以这么理解：一个图的生成树是构造一棵树把所有点给联通，而斯坦纳树则是构造一棵树把给定的几个点联通。如同生成树有最小的一棵，斯坦纳树也有最小的。如何求最小斯坦纳树，是我们今天要探讨的话题。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>例题：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDYxOTI=">Luogu P6192【模板】最小斯坦纳树<i class="fa fa-external-link-alt"></i></span></li></ul><blockquote><p><div>给定一个包含 $n$ 个结点和 $m$ 条带权边的无向连通图 $G=(V,E)$。<br/><br>再给定包含 $k$ 个结点的点集 $S$，选出 $G$ 的子图 $G&#039;=(V&#039;,E&#039;)$，使得：<br/></p><ol><li>$S\subseteq V&#039;$；<br/></li><li>$G&#039;$ 为连通图；<br/></li><li>$E&#039;$ 中所有边的权值和最小。<br/><br>你只需要求出 $E&#039;$ 中所有边的权值和。&lt;/div&gt; <br/></li></ol></blockquote><p>求最小斯坦纳树，我们使用的是 <strong>状压DP</strong>。</p><p>首先非常显然的是，这个选出来的子图 <span class="math inline">\(G'\)</span> 一定是个树。</p><p>令 <span class="math inline">\(f_{i,S}\)</span> 表示当前这个树的根为 <span class="math inline">\(i\)</span>，选出的点的集合为 <span class="math inline">\(S\)</span>（注意这里选出的点专指那 <span class="math inline">\(k\)</span> 个点中的点），这里的 <span class="math inline">\(S\)</span> 在 dp 中是被状压的。</p><ul><li>第一种转移方式：</li></ul><p></p><div class="math display">\[f_{i,S} = f_{i,T} + f_{i,S-T} \ \ \ (T \subseteq S)\]</div><p></p><p>这种转移方式意义在于把一个根可能会连出多棵 <span class="math inline">\(S\)</span> 互不相交的树，该方程可以合并它们。此时这个根的度数 <span class="math inline">\(\geq 1\)</span>。以下是一个示意图，其中 <span class="math inline">\(5,6,7\)</span> 三个点属于目标的那 <span class="math inline">\(k\)</span> 个点，<span class="math inline">\(3\)</span> 是目前的 <span class="math inline">\(i\)</span>。</p><p><img data-src="https://cdn.luogu.com.cn/upload/image_hosting/mqaufgz2.png" alt="" loading="lazy"></p><ul><li>第二种转移方式：</li></ul><p><p></p><div class="math display">\[f_{i,S} = f_{j,S} + w(i,j)\]</div><p></p><p>这种转移方式意义在于把一个根的状态转移到与他相邻的一个根上。此时根 <span class="math inline">\(i\)</span> 的度数 <span class="math inline">\(=1\)</span>。示意图如下，其中 <span class="math inline">\(i = 1，j=3\)</span>，<span class="math inline">\(S=\{5,6\}\)</span>，橙色虚线代表待扩展的边 <span class="math inline">\((i,j)\)</span>。</p></p><p><p><img data-src="https://cdn.luogu.com.cn/upload/image_hosting/kpoebt6x.png" alt="" loading="lazy"></p></p><p><p>考虑 dp 顺序，显然 <span class="math inline">\(S\)</span> 从小到大枚举即可。</p></p><p><p>对于第一种转移方式，只需枚举 <span class="math inline">\(S\)</span> 的子集 <span class="math inline">\(T\)</span>。对于第二种转移方式，注意到这玩意儿是个 <strong>三角不等式</strong>，联想到最短路也是如此——没错，用最短路跑一遍就行了。</p></p><h3 id="参考代码">参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, k, f[Maxn][<span class="number">1</span> &lt;&lt; Maxk];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, dis;</span><br><span class="line">&#125;</span><br><span class="line">edge[Maxm * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[Maxn], edge_num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dis)</span> </span>&#123;</span><br><span class="line">    edge[++edge_num].next = head[from];</span><br><span class="line">    edge[edge_num].to = to;</span><br><span class="line">    edge[edge_num].dis = dis;</span><br><span class="line">    head[from] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; Q; <span class="keyword">int</span> dist[Maxn]; <span class="keyword">bool</span> inq[Maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(inq, <span class="number">0</span>, <span class="keyword">sizeof</span>(inq));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        dist[i] = f[i][S];</span><br><span class="line">        <span class="keyword">if</span>(dist[i] != <span class="number">1061109567</span>) Q.push(i), inq[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(Q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        inq[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dist[v] &gt; dist[u] + edge[i].dis) &#123;</span><br><span class="line">                dist[v] = dist[u] + edge[i].dis;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v]) &#123;</span><br><span class="line">                    inq[v] = <span class="number">1</span>;</span><br><span class="line">                    Q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i][S] = dist[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(); m = read(); k = read();</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        u = read(); v = read(); w = read();</span><br><span class="line">        add_edge(u, v, w);</span><br><span class="line">        add_edge(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">63</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        u = read();</span><br><span class="line">        f[u][<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>)] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; k); ++S) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> T = S &amp; (S - <span class="number">1</span>); T; T = S &amp; (T - <span class="number">1</span>))</span><br><span class="line">                f[i][S] = min(f[i][S], f[i][T] + f[i][T ^ S]);</span><br><span class="line">        SPFA(S);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans = min(ans, f[i][(<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题">例题</h3><ul><li>[WC2008] 游览计划</li></ul><p><p>考虑把每个方格当成一个点，最小斯坦纳树搞它就完了。</p></p><p><p>需要注意的是，由于这道题从边权变成了点权，因此需要把第一种转移方式改成</p></p><p><p></p><div class="math display">\[f_{i,S} = f_{i,T} + f_{i,S-T} - w_i\ \ \ (T \subseteq S)\]</div><p></p><p>原因显然，因为合并状态时 <span class="math inline">\(i\)</span> 的点权被算了两次，需要减去一次。</p></p><p><p>另外，这道题需要输出方案。一个解决方法是记录前驱、回溯解决。怎么 dp 过来，就怎么找回去，如果某个状态和上个状态满足 dp 方程，说明这个状态是从上个状态转移过来的，从而可以计算出哪些点是选了的。具体请参见代码的 dfs 部分。</p></p><p><p>代码：</p><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> w, h, n, cnt, root, val[Maxn], dp[Maxn][<span class="number">1</span> &lt;&lt; Maxk], pre[Maxn][<span class="number">1</span> &lt;&lt; Maxk];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to;</span><br><span class="line">&#125;</span><br><span class="line">edge[Maxm];</span><br><span class="line"><span class="keyword">int</span> head[Maxn], edge_num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    edge[++edge_num].next = head[from];</span><br><span class="line">    edge[edge_num].to = to;</span><br><span class="line">    head[from] = edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h * (i - <span class="number">1</span>) + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; Q; <span class="keyword">bool</span> inq[Maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span>(dp[i][S] != <span class="number">1061109567</span>) Q.push(i), inq[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(Q.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        inq[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(rg <span class="keyword">int</span> i = head[u]; i; i = edge[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dp[v][S] &gt; dp[u][S] + val[v]) &#123;</span><br><span class="line">                dp[v][S] = dp[u][S] + val[v];</span><br><span class="line">                pre[v][S] = u;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v]) inq[v] = <span class="number">1</span>, Q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ans[Maxn], vis[Maxn][<span class="number">1</span> &lt;&lt; Maxk];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!S || vis[u][S]) <span class="keyword">return</span>;</span><br><span class="line">    vis[u][S] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pre[u][S] &amp;&amp; dp[pre[u][S]][S] + val[u] == dp[u][S]) dfs(pre[u][S], S), ans[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rg <span class="keyword">int</span> T = S &amp; (S - <span class="number">1</span>); T; T = S &amp; (T - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span>(dp[u][T] + dp[u][S ^ T] - val[u] == dp[u][S]) dfs(u, T), dfs(u, S ^ T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    w = read(); h = read(); n = w * h;</span><br><span class="line">    <span class="keyword">for</span>(rg <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= w; ++i)</span><br><span class="line">        <span class="keyword">for</span>(rg <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= h; ++j) &#123;</span><br><span class="line">            val[f(i, j)] = read();</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span>) add_edge(f(i, j), f(i - <span class="number">1</span>, j));</span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">1</span>) add_edge(f(i, j), f(i, j - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(i &lt; w) add_edge(f(i, j), f(i + <span class="number">1</span>, j));</span><br><span class="line">            <span class="keyword">if</span>(j &lt; h) add_edge(f(i, j), f(i, j + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(rg <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!val[i]) dp[i][<span class="number">1</span> &lt;&lt; (cnt++)] = <span class="number">0</span>, root = i;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rg <span class="keyword">int</span> S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; cnt); ++S) &#123;</span><br><span class="line">        <span class="keyword">for</span>(rg <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(rg <span class="keyword">int</span> T = S &amp; (S - <span class="number">1</span>); T; T = S &amp; (T - <span class="number">1</span>))</span><br><span class="line">                dp[i][S] = min(dp[i][S], dp[i][T] + dp[i][S ^ T] - val[i]);</span><br><span class="line">        SPFA(S);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root, (<span class="number">1</span> &lt;&lt; cnt) - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[root][(<span class="number">1</span> &lt;&lt; cnt) - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(rg <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= w; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(rg <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= h; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = f(i, j);</span><br><span class="line">            <span class="keyword">if</span>(!val[pos]) <span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ans[pos]) <span class="built_in">printf</span>(<span class="string">&quot;o&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;转载自:&lt;a href=&quot;https://www.cnblogs.com/sqrtyz/p/13427868.html&quot;&gt;https://www.cnblogs.com/sqrtyz/p/13427868.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;摘自百度百科的定义：&lt;br&gt;斯坦纳树问题是组合优化问题，与 最小生成树相似 ，是最短网络的一种。最小生成树是在给定的点集和边中寻求最短网络使所有点连通。而最小斯坦纳树允许在给定点外增加额外的点，使生成的最短网络开销最小。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="最小斯坦纳树" scheme="https://wjr-z.com/tags/%E6%9C%80%E5%B0%8F%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>线形基详解</title>
    <link href="https://wjr-z.com/%E7%BA%BF%E5%BD%A2%E5%9F%BA%E8%AF%A6%E8%A7%A3/"/>
    <id>https://wjr-z.com/%E7%BA%BF%E5%BD%A2%E5%9F%BA%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-01-16T01:55:33.000Z</published>
    <updated>2021-01-21T05:15:02.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>基（basis）是线性代数中的一个概念，它是描述、刻画向量空间的基本工具。而在现行的 OI 题目中，通常在利用基在异或空间中的一些特殊性质来解决题目，而这一类题目所涉及的知识点被称作「线性基」。（大部分求线性基类似于线代里面的矩阵求最大线性无关组）</p></blockquote><a id="more"></a><p>可以将每个数 x 转为二进制，将其看成一个向量。线性基即求 m 个向量，<strong>这 m 个向量线性无关</strong>（即任意一个向量不能被其他任意个向量表示出），且 m 个向量可以表示出原数组的所有向量。</p><p>则如果 x 为 0 ，或者 x 可以被线性基表示出，不加入线性基，否则加入线性基。</p><h2 id="那么如何快速得出-x-是否可以被线性基表示出？"><a href="#那么如何快速得出-x-是否可以被线性基表示出？" class="headerlink" title="那么如何快速得出 x 是否可以被线性基表示出？"></a>那么如何快速得出 x 是否可以被线性基表示出？</h2><p>可以使用高斯消元，假设线性基加入 x 后高斯消元有全为 0 的行，则说明 x 可以被表示出。<br>如果不能表示出则可以直接加入线性基。</p><p>在最后跑高斯消元，因为 x 转为二进制的长度有限，假设为 k ，则消元后的主元（即每一行中第一个非零元素）数最多也为 k，若大于k，则说明还能继续消元下去。<br><strong>因此我们得到了一个最多 k 个向量的线性基</strong>，该线性基在高斯消元前即为原数组中的最多 k 个元素，且这 k 个元素可以表示原数组所有数，因为未加入到线性基的数均为 0 或者可以被线性基表示的数。</p><p>不过因为异或的特殊性质，可以不用高斯消元求解。<br>如果是用向量写的话，正规来说，应该是将k个向量竖着组成一个矩阵，然后高斯消元，我们为了减小复杂度，可以将其横着放，将第 i 个数二进制对应的第 j 位放在矩阵的第 i 行第 j 列。<br>这样的话，行化简即为异或。<br>举个栗子，原数组为{7,1,4,3,5}<br>加入 7 ，矩阵变为<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 1<br>\end{bmatrix}</p><p>加入 1 ，矩阵变为<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 1\\<br>0 &amp; 0 &amp; 1<br>\end{bmatrix}</p><p>高斯消元后变为<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 1<br>\end{bmatrix}</p><p>加入 4 ，矩阵变为<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 1\\<br>1 &amp; 0 &amp; 0<br>\end{bmatrix}</p><p>高斯消元后变为<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 1<br>\end{bmatrix}</p><p>加入 3 ,矩阵变为<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 1\\<br>0 &amp; 1 &amp; 1<br>\end{bmatrix}</p><p>高斯消元后变为<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0\\<br>0 &amp; 1 &amp; 0\\<br>0 &amp; 0 &amp; 1\\<br>0 &amp; 0 &amp; 0<br>\end{bmatrix}</p><p>因此 3 不能加入线性基，同理，5也是。</p><p>因此最后线性基中的元素为4,2,1，其异或和可以表示所有原数组中的任意异或和。</p><p>这样求需要对换两行，但其实这一步也可以省略。</p><p>即我们设$d[i]$表示主元是第 i 列的线性基中的数，我们插入一个数 x 时，从高位到低位，假设当前是第 i 位，且 x 的第 i 位为 1 ，如果 d[i]=0 ，则令$d[i]=x$即可，否则令 $x=x\oplus d[i]$，并继续下去。<br/><br>证明很显然。</p><ul><li>当 x 到了第 i 位，则高位一定全是0，此时第 i 为 1 且d[i]不存在，则肯定不会被消去，则 x 一定会加入线性基。</li><li>如果 d[i] 已经存在，则仿照高斯消元，将 x 的第 i 位消成 0 ，再继续即可。</li></ul><p>注意：这种方法也分两种写法，一种是每次加入后从下往上消去，一种是全部加入完后再从下往上消去，本质是一样的。<br>（在线代中从上往下消即向前步骤，从下往上消为向后步骤，为了理解更简单，之后会一直以向上/向下消去代替，不过我觉得学线性基的估计都是学了高斯消元的吧）</p><p>代码如下（后消去）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>(x&amp;(<span class="number">1ll</span>&lt;&lt;i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i])x^=d[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                d[i]=x;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            <span class="keyword">if</span>(d[i]&amp;(<span class="number">1ll</span>&lt;&lt;j))d[i]^=d[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="线性基的性质及证明"><a href="#线性基的性质及证明" class="headerlink" title="线性基的性质及证明"></a>线性基的性质及证明</h2><ul><li>原序列里面的任意一个数都可以由线性基里面的一些数异或得到</li><li>线性基的元素能相互异或得到原集合的元素的所有相互异或得到的值。</li><li>线性基没有异或和为 0 的子集。</li><li>线性基是满足性质 1 的最小的集合。</li><li>线性基中每个元素的异或方案唯一，也就是说，线性基中不同的异或组合异或出的数都是不一样的。</li><li>线性基中每个元素的二进制最高位互不相同。</li><li>线性基的元素的所有相互异或得到的值均可由原集合的元素相互异或得到。</li></ul><p>证明如下：</p><h3 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h3><p>线性基构造时我们即能被线性基得到的不加入，否则加入。<br>假设加入的数为 x ，高斯消元后变为 $x\oplus y$，则$x\oplus y \oplus y$即为 x ，y可以被线性基表示，因此性质1得证。</p><h3 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h3><p>因为原数组每个数都能被线性基异或得到，因此原数组相互异或得到的所有数均可以被线性基中若干个数异或得到。</p><h3 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h3><p>如果存在异或为 0 的子集，则与构造方法不符，因为此时必定会出现至少一行无主元，则说明至少有一个不该插入的数插入，因此当方法正确时线性基中的任意数异或不能为 0 。</p><h3 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h3><p>因为所有能被表示的数都被剔除了，能插入到线性基中的数均为不能被线性基表示的数，因此得证。</p><h3 id="性质5"><a href="#性质5" class="headerlink" title="性质5"></a>性质5</h3><p>即性质 2 的变形。</p><h3 id="性质6"><a href="#性质6" class="headerlink" title="性质6"></a>性质6</h3><p>高斯消元后不同行的主元不会出现在相同列，否则可以继续消元，因此性质6得证。</p><h3 id="性质7"><a href="#性质7" class="headerlink" title="性质7"></a>性质7</h3><p>很显然在高斯消元前线性基中的元素即为原集合的部分元素，因此高斯消元后，任何线性基的元素可以被表示为若干个原集合的元素的异或和。<br>之后即性质2。<br>因此线性基任意异或得到的数的集合与原集合中任意异或得到的数的集合完全相同（0除外，因为线性基规定不能异或出0）。</p><h2 id="如何求最大值"><a href="#如何求最大值" class="headerlink" title="如何求最大值"></a>如何求最大值</h2><p>其实和0/1 trie树求最大异或值差不多。<br>从高位到低位，若当前是第 i 位，若$(ans\oplus d[i]) &gt; ans$，则$ans=ans\oplus d[i]$即可。<br/><br>证明：<br>如果 ans 第 i 位是 1 ，若 d[i] 不为 0 ，则 d[i] 第 i 位是 1 ，则异或后肯定更小。<br>如果 ans 第 i 位是 0 ，若 d[i] 不为 0 ，则 d[i] 比 i 位更高的位均为 0 ，且第 i 位是 1 ，因此异或后肯定更大。</p><p>因此也可以看出其实可以有两种写法，具体效率相差多少我不清楚qwq。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM4MTI=">异或最大值模板题<i class="fa fa-external-link-alt"></i></span></p><details>    <summary>参考代码</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">52</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">50</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>(x&amp;(<span class="number">1ll</span>&lt;&lt;i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i])x^=d[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                d[i]=x;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_Max</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">50</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>((ans^d[i])&gt;ans)</span><br><span class="line">            ans^=d[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;<span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">        add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,get_Max());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>此代码并未向上消元，仅仅只是最大值/最小值的话没必要。</p><h2 id="如何求最小值"><a href="#如何求最小值" class="headerlink" title="如何求最小值"></a>如何求最小值</h2><p>1.如果线性基元素个数小于原集合元素个数，说明至少有一个未能成功插入线性基，则这个数要么是 0 要么可以被线性基中的数表示，两种情况最小值均为0。<br>2.如果线性基元素等于原集合元素个数。<br>我们假设最小值为$d_{a_1}\oplus d_{a_2}\oplus d_{a_3}…\oplus d_{a_m}$ ，且$a_1&lt; a_2 &lt;…&lt; a_m$，则最高位一定是$a_m$，必定大于$d_{a_1}$，因为后者最高位是$a_1$。<br/><br>所以可以知道最小值是最小的$d$，因为最小值不为 0 ，因此为最小的$d_i(d_i!=0)$。</p><h2 id="如何求第k小"><a href="#如何求第k小" class="headerlink" title="如何求第k小"></a>如何求第k小</h2><p>之前求最大和最小均可以不用向上消元，但是求第 k 小就需要向上消元了。<br>在高斯消元后每个主元所在列除了该主元所在行之外均为0。<br>若有$d_{a_1}\oplus d_{a_2}…\oplus d_{a_m}$，且$a_1&lt; a_2…&lt; a_m$，则第 $a_1,a_2…,a_m$位均为 1 ，因为有且仅有$d_{a_1}$第$a_1$位是1，其他同理。<br/><br>现在考虑比较由线性基异或得到的不同的两个数的大小，假设$x=d_{a_1}\oplus d_{a_2}…\oplus d_{a_p},y=d_{b_1}\oplus d_{b_2}…\oplus d_{b_q}$ ，且$a_1 &lt; a_2…&lt; a_p,b_1 &lt; b_2…&lt; b_q$，且$d_{a_1},d_{a_2}…，d_{a_p} ,d_{b_1},d_{b_2}…d_{b_q}$均不为0<br/><br>1.若$a_p &lt; a_q$ ，则$x &lt; y$<br/><br>2.若$a_p &gt; a_q$ ，则$x &gt; y$<br/><br>3.若$a_p = a_q$ ，则比较$a_{p-1}$和$b_{q-1}$ ，假设$a_{p-1}&gt;b_{q-1}$，则比$a_{p-1}$高的位不变，且第$a_{p-1}$位 x 是 1，y 是 0，因此$x&gt;y$ ，$a_{p-1} &lt; b_{q-1}$则$x &lt; y$，当$a_{p-1}=b_{q-1}$时，不妨将$d_{a_{p}}\oplus d_{a_{p-1}}$当成新数，并继续这样下去。<br/></p><p>因此可以发现仅比较$a_{1}，a_{2}…a_{p}，b_{1},b_{2}…b_{q}$即可。<br/><br>我们用另一个数组 p ，令p[i] 表示从低到高位第 i+1 个非零的 d<br>将 k 表示为二进制，则如果$k\&amp;(1ll &lt;&lt; i)$，令$ans = ans \oplus p[i]$即可。<br/></p><p>最大值即为所有异或起来，最小值需要讨论。</p><p>如果原集合能异或出 0 ，即线性基中元素个数 cnt &lt; 原集合元素个数 n ，那么最小值为 0 。<br>如果不能异或出 0 ，即为 p[0]。<br>因此其实能异或出的元素个数也能求出来。</p><ul><li>如果 cnt &lt; n ，则能异或出的数为 $2^{cnt}$。<br/></li><li>如果 cnt = n ，则能异或出的数为 $2^{cnt}-1$。<br/></li></ul><p>因此当求第 k 小时有几点需要注意：</p><ul><li>cnt &lt; n 时 ，能异或出的数的个数为 $2^{cnt}$（可以有 0 ）。<br/></li><li>cnt = n 时 ， 能异或出的数的个书屋 $2^{cnt}-1$（不能有 0 ）。<br/></li><li>当 k=1 时 ，如果 cnt &lt; n ，则最小是 0 。</li><li>当 k 不为 1 ，且 cnt &lt; n 时，因为最小值是 0 ，而 0 被算成了第 0 小，因此需要令$k=k-1$。</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA4NDUvRQ==">异或第k小例题+二分<i class="fa fa-external-link-alt"></i></span></p><blockquote><p>hack数据：<br>2 12<br>13 2</p></blockquote><p><a href="/2021/01/17/牛客挑战赛76E-牛牛数数/">题解</a></p><h2 id="判断一个数是否能被当前元素异或得到"><a href="#判断一个数是否能被当前元素异或得到" class="headerlink" title="判断一个数是否能被当前元素异或得到"></a>判断一个数是否能被当前元素异或得到</h2><p>即看是否能插入到线性基中，如果不能则说明可以，否则说明不行。</p><blockquote><p>参考文章<br><span class="exturl" data-url="aHR0cHM6Ly9vaS13aWtpLm9yZy9tYXRoL2Jhc2lzLyNfX2NvbW1lbnRz">线性基 OI wiki<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnNlbmd4aWFuLmNvbS9hbGdvcml0aG1zL2xpbmVhci1iYXNpcw==">线性基学习笔记<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FfZm9yZXZlcl9kcmVhbS9hcnRpY2xlL2RldGFpbHMvODM2NTQzOTc=">线性基详解<i class="fa fa-external-link-alt"></i></span></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;基（basis）是线性代数中的一个概念，它是描述、刻画向量空间的基本工具。而在现行的 OI 题目中，通常在利用基在异或空间中的一些特殊性质来解决题目，而这一类题目所涉及的知识点被称作「线性基」。（大部分求线性基类似于线代里面的矩阵求最大线性无关组）&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="线性基" scheme="https://wjr-z.com/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
  </entry>
  
  <entry>
    <title>牛客练习赛76</title>
    <link href="https://wjr-z.com/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B76/"/>
    <id>https://wjr-z.com/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B76/</id>
    <published>2021-01-16T01:47:35.000Z</published>
    <updated>2021-01-26T12:26:52.718Z</updated>
    
    <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vZGlzY3Vzcy81ODkwMDc/dHlwZT0xMDEmYW1wO2NoYW5uZWw9LTEmYW1wO3NvdXJjZV9pZD0w">官方题解<i class="fa fa-external-link-alt"></i></span></p><a id="more"></a><p>这次比赛还比较难，就挺不戳的，刚好补知识点。</p><p>涉及考点：</p><ol><li><p>博弈论</p></li><li><p>线性基 异或第k小</p></li><li><p>最小斯坦纳树</p></li><li><p>莫比乌斯反演</p></li></ol><p>知识点讲解：</p><ol><li><p><a href="/%E7%BA%BF%E5%BD%A2%E5%9F%BA/">线性基</a></p></li><li><p><a href="/最小斯坦纳树详解/">最小斯坦纳树</a></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/discuss/589007?type=101&amp;amp;channel=-1&amp;amp;source_id=0&quot;&gt;官方题解&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>常用markdown介绍</title>
    <link href="https://wjr-z.com/%E5%B8%B8%E7%94%A8markdown%E4%BB%8B%E7%BB%8D/"/>
    <id>https://wjr-z.com/%E5%B8%B8%E7%94%A8markdown%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-01-15T07:06:53.000Z</published>
    <updated>2021-01-26T12:25:10.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><a id="more"></a><p> 效果如下：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h2><p><img data-src="https://tu.sunpma.com/imgs/2021/01/36de521bd3107ef2.png" align='left'><br><br/><br><br/><br><br/><br>效果如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>此处以C++为例，```后面是代码语言。</p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">**我是sb** （粗体）</span><br><span class="line">*tql* （斜体）</span><br><span class="line">~~啊这~~ （划线）</span><br></pre></td></tr></table></figure><p>效果如下：<br><strong>我是sb</strong> （粗体）<br><em>tql</em> （斜体）<br><del>啊这</del> （划线）</p><h2 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[链接文本](链接地址)</span><br></pre></td></tr></table></figure><p>效果如下：<br><a href="https://wjr-z.com/">myblog</a></p><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片文字描述](图片地址)</span><br></pre></td></tr></table></figure><p>效果如下：<br><img data-src="https://tu.sunpma.com/imgs/2021/01/dce480b807f1e9fe.webp" alt="我和德狗贴贴"></p><p>若觉得图片位置或者大小不太适合，可以尝试用html语言设置高度和宽以及位置等。</p><h2 id="插入引用"><a href="#插入引用" class="headerlink" title="插入引用"></a>插入引用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 啊这</span><br></pre></td></tr></table></figure><blockquote><p>啊这</p></blockquote><h2 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|name|age|address|</span><br><span class="line">|---|:----:|---:|</span><br><span class="line">|zhang|18|beijing|</span><br><span class="line">|wang|22|shandong|</span><br></pre></td></tr></table></figure><blockquote><p>居中 <code>:------</code><br>局左 <code>-------</code> 或 <code>:-----:</code><br>居右 <code>------:</code></p></blockquote><p>效果如下：</p><div class="table-container"><table><thead><tr><th>name</th><th style="text-align:center">age</th><th style="text-align:right">address</th></tr></thead><tbody><tr><td>zhang</td><td style="text-align:center">18</td><td style="text-align:right">beijing</td></tr><tr><td>wang</td><td style="text-align:center">22</td><td style="text-align:right">shandong</td></tr></tbody></table></div><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>两个空格一个回车</p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LCT</span><br><span class="line"></span><br><span class="line">--- </span><br><span class="line">splay</span><br></pre></td></tr></table></figure><p>效果如下：<br>LCT</p><hr><p>splay</p><p>(yysy这个分割线好丑，以后改一下样式)</p><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- a</span><br><span class="line">- b</span><br><span class="line">- c</span><br></pre></td></tr></table></figure><p>效果如下：</p><ul><li>a</li><li>b</li><li>c</li></ul><blockquote><p>参考文章  <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vemhhbmdqaW56aGUvcC84MjUyODkzLmh0bWw=">常用Markdown语法归纳<i class="fa fa-external-link-alt"></i></span></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h2&gt; &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 一级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## 二级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 三级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 四级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;##### 五级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;###### 六级标题&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
