<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wjr的博客</title>
  
  <subtitle>Explosion!</subtitle>
  <link href="https://wjr-z.com/atom.xml" rel="self"/>
  
  <link href="https://wjr-z.com/"/>
  <updated>2021-02-02T14:45:40.306Z</updated>
  <id>https://wjr-z.com/</id>
  
  <author>
    <name>wjr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>合并回文子串</title>
    <link href="https://wjr-z.com/%E5%90%88%E5%B9%B6%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>https://wjr-z.com/%E5%90%88%E5%B9%B6%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2021-02-02T14:22:53.000Z</published>
    <updated>2021-02-02T14:45:40.306Z</updated>
    
    <content type="html"><![CDATA[<p>经典的回文串相关的 DP 题，理解了如何用$O(n^2)$求解回文串，这题会比较简单。</p><a id="more"></a><p>对于求解最长回文串，可以用复杂度为$O(n)$的 Manacher 算法，或者回文自动机，但是此题只需要 DP 即可。<br>对于 DP 求解回文串，记 dp[i][j] 为 i 到 j 是否是回文串即可，转移很简单，当 s[i] == s[j] 时 dp[i][j] = dp[i+1][j-1] 即可<br>如果 i+1 到 j-1 是回文串，则 i 到 j 也是回文串，反之则不是。</p><p>此题有两个字符串，但其实 DP 只用略微修改即可<br>因为合并出的字符串中连续的一段必定是原来的分别来自两个字符串中连续的一段合并而来的（可以为空）<br>这样的话用个四维 dp 即可，记 dp[i][j][k][l] 表示第一个串 i 到 j 和第二个串 k 到 l 构成的串是否能是回文串<br>此时注意，转移有四种，转移：</p><script type="math/tex; mode=display">\begin{aligned}dp[i][j][k][l]|=dp[i+1][j-1][k][l]\;(s[i]==s[j]) \\dp[i][j][k][l]|=dp[i+1][j][k][l-1]\;(s[i]==g[l]) \\dp[i][j][k][l]|=dp[i][j-1][k+1][l]\;(s[j]==g[k]) \\dp[i][j][k][l]|=dp[i][j][k+1][l-1]\;(g[k]==g[l])\end{aligned}</script><p>若某个 dp[i][j][k][l] 为 1 ，则说明这是一个回文串，更新下答案即可。</p><p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">52</span>;</span><br><span class="line"><span class="keyword">char</span> s[N], g[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][N][N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s + <span class="number">1</span>, g + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), m = <span class="built_in">strlen</span>(g + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l + i - <span class="number">1</span> &lt;= n; ++l) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = l + i - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">1</span>; L + j - <span class="number">1</span> &lt;= m; ++L) &#123;</span><br><span class="line">                        <span class="keyword">int</span> R = L + j - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (i + j &lt;= <span class="number">1</span>)</span><br><span class="line">                            dp[l][r][L][R] = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            dp[l][r][L][R] = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">if</span> (s[l] == s[r])dp[l][r][L][R] |= dp[l + <span class="number">1</span>][r - <span class="number">1</span>][L][R];</span><br><span class="line">                            <span class="keyword">if</span> (s[l] == g[R])dp[l][r][L][R] |= dp[l + <span class="number">1</span>][r][L][R - <span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span> (g[L] == s[r])dp[l][r][L][R] |= dp[l][r - <span class="number">1</span>][L + <span class="number">1</span>][R];</span><br><span class="line">                            <span class="keyword">if</span> (g[L] == g[R])dp[l][r][L][R] |= dp[l][r][L + <span class="number">1</span>][R - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (dp[l][r][L][R])ans = max(ans, i + j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;经典的回文串相关的 DP 题，理解了如何用$O(n^2)$求解回文串，这题会比较简单。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DP" scheme="https://wjr-z.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>NC18386字符串</title>
    <link href="https://wjr-z.com/%E7%89%9B%E5%AE%A2-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://wjr-z.com/%E7%89%9B%E5%AE%A2-%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-02-02T04:14:49.000Z</published>
    <updated>2021-02-02T04:22:07.432Z</updated>
    
    <content type="html"><![CDATA[<p>基础中的基础题。</p><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL3Byb2JsZW0vMTgzODY=">题目链接<i class="fa fa-external-link-alt"></i></span><br>给出一个长度为 n 的仅由小写字母构成的字符串，求出包含了所有的小写字母子串的最小长度。</p><a id="more"></a><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>很显然是用尺取法<br>对于每一个右端点，求出最大的左端点并且能满足条件即可，这样的话，当右端点往右移动时，显然这样的左端点也是往右移动的<br>对于快速求出是否符合条件只需要用桶存每个字母出现次数即可，每次移动右端点后，将左端点移动到最后一个使得所有字母都出现过的位置，这个位置也是第一个至少一个字母未出现的位置的左边一个。</p><p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">30</span>],res;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(++num[s[x]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">1</span>)--res;</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(--num[s[x]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>)++res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    res=<span class="number">26</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> L=<span class="number">1</span>,R=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (R &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">while</span>(R&lt;=n&amp;&amp;res)add(++R);</span><br><span class="line">        <span class="keyword">if</span>(R&gt;n)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span>(!res)del(L++);</span><br><span class="line">        ans=min(ans,R-L+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基础中的基础题。&lt;/p&gt;
&lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/18386&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;给出一个长度为 n 的仅由小写字母构成的字符串，求出包含了所有的小写字母子串的最小长度。&lt;/p&gt;</summary>
    
    
    
    
    <category term="尺取法" scheme="https://wjr-z.com/tags/%E5%B0%BA%E5%8F%96%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>牛客每日一题</title>
    <link href="https://wjr-z.com/%E7%89%9B%E5%AE%A2%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>https://wjr-z.com/%E7%89%9B%E5%AE%A2%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2021-02-01T04:40:48.000Z</published>
    <updated>2021-02-16T13:43:04.075Z</updated>
    
    <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vZGlzY3Vzcy80MzYyNTM/dHlwZT0xMDEmYW1wO29yZGVyPTAmYW1wO3Bvcz0xJmFtcDtwYWdlPTImYW1wO2NoYW5uZWw9LTEmYW1wO3NvdXJjZV9pZD0x">原文链接<i class="fa fa-external-link-alt"></i></span></p><p>题解的话牛客上也有很多，我的博客也写了一些。</p><p>要找到对应的题解，可以在标签找”牛客每日一题”，或者直接搜索对应的题目名字。</p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/discuss/436253?type=101&amp;amp;order=0&amp;amp;pos=1&amp;amp;page=2&amp;amp;channel=-1&amp;amp;source_id=1&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题解的话牛客上也有很多，我的博客也写了一些。&lt;/p&gt;
&lt;p&gt;要找到对应的题解，可以在标签找”牛客每日一题”，或者直接搜索对应的题目名字。&lt;/p&gt;</summary>
    
    
    
    
    <category term="牛客每日一题" scheme="https://wjr-z.com/tags/%E7%89%9B%E5%AE%A2%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>背包</title>
    <link href="https://wjr-z.com/%E8%83%8C%E5%8C%85/"/>
    <id>https://wjr-z.com/%E8%83%8C%E5%8C%85/</id>
    <published>2021-02-01T04:36:59.000Z</published>
    <updated>2021-02-01T04:56:25.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL3Byb2JsZW0vMTczMTU=">题目链接<i class="fa fa-external-link-alt"></i></span><br>容量为 V 的背包，有 n 个物品 ，每一个物品有一个价值 a 和重量 b ，现在要你选择 m 个物品装进背包，求出这 m 个物品价值中位数的最大值。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>题解说的是 m 为偶数时取中位数较大的一个枚举也行，但是貌似这个没单调性？（我枚举最大数没做出来…</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这题需要求中位数的最大值，因此需要先将所有物品按照从小到大排序<br>然后将问题从求解中位数最大值变成判断中位数是 x 的可能性<br>即我们枚举中位数，然后判断是否能成立</p><ol><li>m 是奇数时（ m = 2k + 1 )<br>此时我们枚举  $a_i(k+1\leq i \leq n-k)$ ，如果 i 重量最小的 k 个与 i 后重量最小 k 个与 i 的重量之和小于等于 V ，则说明中位数可以为$a_i$。</li><li>m 是偶数时（ m = 2k ）<br>此时枚举中位数中较小的一个，要使中位数最大，则中位数中较大的一个要尽量大。<br>我们设$pre_i$表示前 i 个中重量最小的 k 个，设$suf_i$表示 i 后重量最小的 k 个，则不难发现 $pre_i$单减，$suf_i$单增<br>这样的话其实如果枚举中位数较小的一个，中位数较大的一个是可以二分出来的，因为中位数较大的一个越大，$suf_i$越大，反之越小，因此能找大最大的一个。</li></ol><p>因此就这样边枚举边更新答案即可。</p><p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> pre[N],suf[N];</span><br><span class="line"><span class="keyword">int</span> n,m,V;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp;other)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&lt;other.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;V,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i].a,&amp;a[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">int</span> x=m&amp;<span class="number">1</span>;m&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]+a[i].b;</span><br><span class="line">        q.push(a[i].b);</span><br><span class="line">        <span class="keyword">if</span> (q.size() &gt; m<span class="number">-1</span>+x) &#123;</span><br><span class="line">            pre[i]-=q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())q.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        suf[i]=suf[i+<span class="number">1</span>]+a[i].b;</span><br><span class="line">        q.push(a[i].b);</span><br><span class="line">        <span class="keyword">if</span> (q.size() &gt; m) &#123;</span><br><span class="line">            suf[i]-=q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m+<span class="number">1</span>; i &lt;= n-m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[i<span class="number">-1</span>]+suf[i+<span class="number">1</span>]+a[i].b&lt;=V)ans=a[i].a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> L,R,mid,Ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= n-m; ++i) &#123;</span><br><span class="line">            L=i+<span class="number">1</span>,R=n-m+<span class="number">1</span>,Ans=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">                mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(pre[i<span class="number">-1</span>]+a[i].b+suf[mid]&lt;=V)L=mid+<span class="number">1</span>,Ans=mid;</span><br><span class="line">                <span class="keyword">else</span> R=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Ans)ans=max(ans,(<span class="keyword">long</span> <span class="keyword">long</span>)(a[Ans].a+a[i].a));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/17315&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;容量为 V 的背包，有 n 个物品 ，每一个物品有一个价值 a 和重量 b ，现在要你选择 m 个物品装进背包，求出这 m 个物品价值中位数的最大值。&lt;/p&gt;</summary>
    
    
    
    
    <category term="牛客每日一题" scheme="https://wjr-z.com/tags/%E7%89%9B%E5%AE%A2%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="优先队列" scheme="https://wjr-z.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="二分" scheme="https://wjr-z.com/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>失衡天平</title>
    <link href="https://wjr-z.com/%E5%A4%B1%E8%A1%A1%E5%A4%A9%E5%B9%B3/"/>
    <id>https://wjr-z.com/%E5%A4%B1%E8%A1%A1%E5%A4%A9%E5%B9%B3/</id>
    <published>2021-01-31T11:57:10.000Z</published>
    <updated>2021-01-31T12:08:18.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给了 n 个武器，每个武器有一个重量 a ，并且给了一个天平，现在你每次都可以从这些武器中选择若干个武器并放到天平上，但是只有天平两边重量相差 m 以内你才能拿走，并且拿走的武器不能再放到天平上，问你最多能拿走的武器总重量。</p><a id="more"></a><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>实际上如果答案最优，则拿若干次一定不优于拿一次。<br>假设拿的第一次左右两边相差 x ，第二次左右两边相差 y ，则一定有 $|x-y|\leq m$（第二次重的一边放到第一次轻的一边），所以其实无论拿多少次都可以变成只拿一次。<br/><br>这样就是个简单 dp 了。<br>设 $dp[i][j]$ 表示前 i 个武器天平重量相差 j 能拿走的最大武器重量<br/><br>转移：</p><script type="math/tex; mode=display">dp[i][j]=max(dp[i-1][j],dp[i-1][j+a[i]],dp[i-1][|j-a[i]|])</script><p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][N*N],a[N];<span class="comment">//dp[i][j]表示前i个左右两边相差j的最大重量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>,las=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0xf3</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        now^=<span class="number">1</span>,las^=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">10000</span>;++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            x=<span class="built_in">abs</span>(j-a[i]);</span><br><span class="line">            dp[now][j]=dp[las][j];</span><br><span class="line">            dp[now][j]=max(dp[now][j],dp[las][x]+a[i]);</span><br><span class="line">            x=j+a[i];</span><br><span class="line">            <span class="keyword">if</span>(x&lt;=<span class="number">10000</span>)</span><br><span class="line">                dp[now][j]=max(dp[now][j],dp[las][x]+a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i)</span><br><span class="line">        ans=max(ans,dp[now][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>用了下滚动数组优化。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;给了 n 个武器，每个武器有一个重量 a ，并且给了一个天平，现在你每次都可以从这些武器中选择若干个武器并放到天平上，但是只有天平两边重量相差 m 以内你才能拿走，并且拿走的武器不能再放到天平上，问你最多能拿走的武器总重量。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DP" scheme="https://wjr-z.com/tags/DP/"/>
    
    <category term="牛客每日一题" scheme="https://wjr-z.com/tags/%E7%89%9B%E5%AE%A2%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Educational Codeforces Round 103 (Rated for Div. 2)</title>
    <link href="https://wjr-z.com/eduRound103/"/>
    <id>https://wjr-z.com/eduRound103/</id>
    <published>2021-01-30T03:29:58.000Z</published>
    <updated>2021-01-30T09:52:03.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我居然能在B题上因为 long long 和向上取整错四次…（人才<br>好在之后几题比较顺<br><a id="more"></a></p><h2 id="A-K-divisible-Sum"><a href="#A-K-divisible-Sum" class="headerlink" title="A. K-divisible Sum"></a>A. K-divisible Sum</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE0NzYvcHJvYmxlbS9B">题目链接<i class="fa fa-external-link-alt"></i></span></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给出 n 和 k ，你要构造一个 n 个元素的数组 a ，a 所有元素的和可以被 k 整除，求出 a 最大元素最小可能是多少。</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>假设 a 中最大元素是 MAX ，则可以得到的数是 $MAX+n-1\sim n*MAX$<br/></p><ul><li>$k\geq n$时，找到最小的MAX使得$n*MAX\geq k$即可，即$\lceil\frac{k}{n}\rceil$<br/></li><li>$k &lt; n$时，如果$n\%k=0$则 MAX = 1 即可满足题意，如果$n\%k\neq 0$，当 MAX = 2 时，可以得到$n+1 \sim 2n$，必定存在一个数能被 k 整除。</li></ul><p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x,T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(n&gt;x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%x==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;2\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x%n==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x/n);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x/n+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="B-Inflation"><a href="#B-Inflation" class="headerlink" title="B. Inflation"></a>B. Inflation</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE0NzYvcHJvYmxlbS9C">题目链接<i class="fa fa-external-link-alt"></i></span></p><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个数组$p_0,p_1…p_{n-1}$，可以令每个$p_i$加上一个非负整数$a_i$，使得$\frac{p_i}{p_0+p_1+…+p_{i-1}}\leq k\%$，要求$\sum_{i=0}^{n-1}a_i$的最小值。</p><h3 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h3><p>这题我花了23分钟，还错了4次…<br>这题是贪心，结论其实可以直接猜出来。<br>我们从前往后处理每个数，如果$\frac{p_i}{p_0+p_1+…+p_{i-1}} &gt; k\%$，则将$p_i$加到使得$\frac{p_i}{p_0+p_1+…+p_{i-1}} \leq k\%$，顺便更新答案即可。<br/><br>这样我们确实前面的是最小化了，但是能否保证后面也能最小化答案呢？<br>如果 $\frac{x}{y}=\frac{k}{100}$ ，则当 y 变化 100 时， x 只变化 k <br/><br>我们假设我们贪心到 i 有 $\frac{p_i+a_i}{p_0+p_1+…+p_{i-1}+x}=\frac{k}{100}$ ，如果分母增大，则分子减少的小于等于分母增加的，因此不会更优，往后处理时均如此。<br/><br>因此这个贪心策略是正确的。</p><p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span>  T,n,k;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">105</span>],d[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> s=a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]*<span class="number">100ll</span>&gt;k*s)&#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> x=<span class="built_in">ceil</span>((<span class="number">100ll</span>*a[i]-k*s)*<span class="number">1.0</span>/k);</span><br><span class="line">                ans+=x;</span><br><span class="line">                s+=x;</span><br><span class="line">            &#125;</span><br><span class="line">            s+=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>那个向上取整其实可以用更好的写法，即$long long x=(100ll*a[i]+k-1)/k-s;$，这样避免了精度问题。</p><h2 id="C-Longest-Simple-Cycle"><a href="#C-Longest-Simple-Cycle" class="headerlink" title="C. Longest Simple Cycle"></a>C. Longest Simple Cycle</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE0NzYvcHJvYmxlbS9D">题目链接<i class="fa fa-external-link-alt"></i></span></p><h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给出 n 条链，每条链的首、尾与上一条链的两个点相连，请求出最大的简单环。<br><img data-src="https://espresso.codeforces.com/f5b742ef7ad02ab00141f54a6dda3eb9bc79d4d3.png" alt=""></p><h3 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h3><p>其实真的很简单。<br>我们设$dp_i$表示第 i 条链和在其之前的链构成的最大简单环的长度，则很显然第 i 条链要么通过与上一条链连接的两个点以及自己构成一个简单环，要么是通过与上一条链构成的最大简单环构成一个新的最大简单环（需要减去重复部分）<br>因此顺着这样求就行了，我为了简便书写就改了一点变量（感觉貌似更复杂了，服了我自己</p><p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T,n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,inf=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N],c[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">        dp[<span class="number">1</span>]=-inf;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            dp[i]=<span class="number">2</span>+<span class="built_in">abs</span>(a[i]-b[i]);</span><br><span class="line">            <span class="keyword">int</span> L=min(a[i],b[i]),R=max(a[i],b[i]);</span><br><span class="line">            <span class="keyword">if</span>(a[i]!=b[i])</span><br><span class="line">                dp[i]=max(dp[i],<span class="number">2</span>+dp[i<span class="number">-1</span>]+L<span class="number">-1</span>+c[i<span class="number">-1</span>]-R);</span><br><span class="line">            ans=max(ans,dp[i]+c[i]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="D-Journey"><a href="#D-Journey" class="headerlink" title="D. Journey"></a>D. Journey</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE0NzYvcHJvYmxlbS9E">题目链接<i class="fa fa-external-link-alt"></i></span></p><h3 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h3><p>n + 1 个城市，从 $0\sim n$<br/><br>给出一个长度为 n 的字符串，如果第 i 位是 L ，表示有一条从 i 到 i-1 的有向边；如果是 R ，表示有一条从 i-1 到 i 的有向边。<br>且每次经过一条边后所有边的朝向改变，对于每一个城市，求出以其为初始位置时能经过的最多城市数。</p><h3 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h3><p>每次朝向会改变，我想都没想直接以时间点为奇数/偶数拆点建图了，初始时间为 0 。<br>然后把样例手模一下，发现一个简单的并查集就能做了，因为每条边都是双向边，并且连接着的是相邻且时间奇偶性不同的连个点，这样一来既不会有一个城市既能在偶数时间点被访问又在奇数时间点被访问，而且因为双向可以互相到达。<br>那么其实缩点也可以做到，不过我这里为了代码书写起来简单直接写了个并查集，其他方法没想过了，反正我觉得拆点后可以秒出。</p><p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> fa[N&lt;&lt;<span class="number">1</span>],siz[N&lt;&lt;<span class="number">1</span>],T,n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=get(fa[x]);&#125;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x=get(x),y=get(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span>;</span><br><span class="line">    fa[x]=y;</span><br><span class="line">    siz[y]+=siz[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> c=<span class="number">2</span>*(n+<span class="number">1</span>),S=n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=c;++i)</span><br><span class="line">            fa[i]=i,siz[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">                link(i+<span class="number">1</span>,i+S);</span><br><span class="line">            <span class="keyword">else</span> link(i,i+<span class="number">1</span>+S);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=S;++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,siz[get(i)]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="E-Pattern-Matching"><a href="#E-Pattern-Matching" class="headerlink" title="E. Pattern Matching"></a>E. Pattern Matching</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE0NzYvcHJvYmxlbS9F">题目链接<i class="fa fa-external-link-alt"></i></span></p><h3 id="题目描述：-4"><a href="#题目描述：-4" class="headerlink" title="题目描述："></a>题目描述：</h3><p>见题目。</p><h3 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h3><p>想清楚就不难，但就是想不清楚，想出来后又觉得我当时为啥这么蠢。</p><p>其实每个字符串最多能匹配$2^4$个模式串，利用拓扑排序的方式即可，如果字符串能匹配 mt 模式串，则将 mt 模式串与其他所有该字符串能匹配的模式串连有向边（起点是 mt ）；如果不能匹配则说明无解。<br>之后拓扑排序即可的出答案。<br>然后就要考虑如何快速得到字符串能匹配到的所有模式串了，可以字典树或者map，具体就不细讲了。</p><p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> ch[N&lt;&lt;<span class="number">2</span>][<span class="number">27</span>],val[N&lt;&lt;<span class="number">2</span>],cnt;</span><br><span class="line"><span class="keyword">int</span> d[N&lt;&lt;<span class="number">1</span>],nxt[N&lt;&lt;<span class="number">4</span>],to[N&lt;&lt;<span class="number">4</span>],tot;</span><br><span class="line"><span class="keyword">int</span> deg[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="keyword">int</span> ans[N&lt;&lt;<span class="number">1</span>],ans2[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    to[++tot]=b;</span><br><span class="line">    nxt[tot]=d[a];</span><br><span class="line">    d[a]=tot;</span><br><span class="line">    ++deg[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>*s,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;_&#x27;</span>)j=<span class="number">26</span>;</span><br><span class="line">        <span class="keyword">else</span> j=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ch[p][j])ch[p][j]=++cnt;</span><br><span class="line">        p=ch[p][j];</span><br><span class="line">    &#125;</span><br><span class="line">    val[p]=id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> f;</span><br><span class="line"><span class="keyword">bool</span> g;</span><br><span class="line"><span class="keyword">int</span> num,mt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">char</span>*s,<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(now&gt;k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(val[p]==mt)&#123;</span><br><span class="line">            g=<span class="literal">true</span>;</span><br><span class="line">            ins(mt,num+n);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ins(num+n,val[p]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    work(ch[p][s[now]-<span class="string">&#x27;a&#x27;</span>],s,now+<span class="number">1</span>);</span><br><span class="line">    work(ch[p][<span class="number">26</span>],s,now+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>),insert(s,i);</span><br><span class="line">    f=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        num=i;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,s+<span class="number">1</span>,&amp;mt);</span><br><span class="line">        g=<span class="literal">false</span>;</span><br><span class="line">        work(<span class="number">1</span>,s,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!g)f=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!deg[i])</span><br><span class="line">            q.push(i);</span><br><span class="line">    &#125;<span class="keyword">int</span> Tim=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=n)</span><br><span class="line">            ans[x]=++Tim;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=d[x];i;i=nxt[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> u=to[i];</span><br><span class="line">            <span class="keyword">if</span>(--deg[u]==<span class="number">0</span>)q.push(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(deg[i])&#123;</span><br><span class="line">            f=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(!ans[i])</span><br><span class="line">            ans[i]=++Tim;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        ans2[ans[i]]=i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans2[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我居然能在B题上因为 long long 和向上取整错四次…（人才&lt;br&gt;好在之后几题比较顺&lt;br&gt;</summary>
    
    
    
    
    <category term="cf比赛" scheme="https://wjr-z.com/tags/cf%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>codeforces Round 698(Div.2)</title>
    <link href="https://wjr-z.com/codeforcesR698/"/>
    <id>https://wjr-z.com/codeforcesR698/</id>
    <published>2021-01-29T03:50:30.000Z</published>
    <updated>2021-01-30T03:39:30.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>（其实是吐槽<br>昨天比赛刚开始换了三次网，换了两次镜像网站才勉强能看到题…<br>游戏体验极差，而且最后还掉了一点分。</p><a id="more"></a><h2 id="A-Nezzar-and-Colorful-Balls"><a href="#A-Nezzar-and-Colorful-Balls" class="headerlink" title="A.Nezzar and Colorful Balls"></a>A.Nezzar and Colorful Balls</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3OC9wcm9ibGVtL0E=">题目链接<i class="fa fa-external-link-alt"></i></span></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定 n 个球，每个球上有一个数字 a ，现在为每个球染色，要使得相同颜色球上的数组 a 是严格递增的，且 a 数组是递增的，求最小颜色数。</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>其实即 a 数组中出现次数最多的次数。<br>证明、代码略。</p><h2 id="B-Nezzar-and-Lucky-Number"><a href="#B-Nezzar-and-Lucky-Number" class="headerlink" title="B.Nezzar and Lucky Number"></a>B.Nezzar and Lucky Number</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3OC9wcm9ibGVtL0I=">题目链接<i class="fa fa-external-link-alt"></i></span></p><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个整数 $d(d\in[1,9])$ ，称一个数字为幸运数字当且仅当这个数字是正整数且至少有一位是 d ，给出 n 个数，对于每个数如果能由若干个幸运数字相加得到，则输出”YES”，否则输出”NO”。</p><h3 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h3><p>我是真没想到这又是一场猜结论场…<br>（是我很菜，所以不能及时推出结论…</p><ul><li>若 $x \geq 10*d$ ，则一定是 YES<br/><br>如果$x\in[10*d,11*d)$，则是 YES<br/><br>如果$x\geq 11*d$，则减去若干个 d 后必定能得到$x’\in[10*d,11*d)$，则是 YES <br/></li><li>若 $x &lt; 10* d$<br>此时暴力判断即可，最简单的判断方式就是 x 减去若干个 d ，判断个位是否为 0 ，因为十位可以任取所以可以不管，如果个位为 0 则一定可以。</li></ul><p>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> q,d;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;q,&amp;d);</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">10</span>*d)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">bool</span> f=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(x&gt;=j*d&amp;&amp;((x-j*d)%<span class="number">10</span>==<span class="number">0</span>))&#123;</span><br><span class="line">                        f=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(f)<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="C-Nezzar-and-Symmetric-Array"><a href="#C-Nezzar-and-Symmetric-Array" class="headerlink" title="C.Nezzar and Symmetric Array"></a>C.Nezzar and Symmetric Array</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3OC9wcm9ibGVtL0M=">题目链接<i class="fa fa-external-link-alt"></i></span></p><h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>某数组有 2*n 个互不相同的数，每个数都能在数组中找到一个相反数。<br>令$d_i=\sum_{j=1}^{2n}|a_i-a_j|$，现在给了你数组 d ，试判断是否存在至少一种可能的原数组 a 。</p><h3 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h3><p>前四题三个数学题…<br>首先互不相同且能找出相反数，可以得到不能有 0 ，如果仅存在一个 0 ，则 必定有一个数在原数组中无相反数。<br>然后我们将 a 数组从大到小排序，则前 n 个是正数，后 n 个是负数，并且因为从大到小排序，可以得到：</p><script type="math/tex; mode=display">d_{i}=(a_1-a_i)+(a_2-a_i)+...+(a_i-a_i)+(a_i-a_{i+1})+(a_i-a_{i+2})...+(a_i-a_{2n})</script><p>然后根据相反数的条件，继续化简得到：</p><script type="math/tex; mode=display">\begin{aligned}d_{i}&=(a_1-a_i)+...+(a_i-a_i)+(a_i-a_{i+1})...+(a_i-a_{n})+(a_i+a_{n})+(a_i+a_{n-1})...+(a_i+a_1) \\&=2(a_1+a_2+...+a_i)+(2n-2i)a_i\end{aligned}</script><p>因为原数组从大到小排序了，则 d 应该是先递减后递增，且$d_{i}=d_{2<em>n-i+1}$<br/><br>为了方便，直接将 d 从小到大排序或者从大到小排序然后每两个判断下是否相同，即初步判断是否合法。<br>然后根据上述的式子推出原数组即可，例如 $2n\</em>a_1=d_1$ ，然后后面的做差即可求出。<br>我当时脑子有点乱，所以代码写的有点乱…<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[N],a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;d[i]);</span><br><span class="line">        sort(d+<span class="number">1</span>,d+<span class="number">2</span>*n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">bool</span> f=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i]!=d[i+<span class="number">1</span>])&#123;</span><br><span class="line">                f=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(d[<span class="number">2</span>*n]%(<span class="number">2</span>*n)!=<span class="number">0</span>||d[<span class="number">2</span>*n]==<span class="number">0</span>)f=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[n]=d[<span class="number">2</span>*n]/(<span class="number">2</span>*n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=n-i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> p=(<span class="number">2</span>*n<span class="number">-2</span>*j+<span class="number">2</span>)*a[i+<span class="number">1</span>]+d[<span class="number">2</span>*i]-d[<span class="number">2</span>*(i+<span class="number">1</span>)];</span><br><span class="line">            <span class="keyword">if</span>(p%(<span class="number">2</span>*n<span class="number">-2</span>*j+<span class="number">2</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">                f=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a[i]=p/(<span class="number">2</span>*n<span class="number">-2</span>*j+<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(!a[i]||a[i]==a[i+<span class="number">1</span>]||a[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                f=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="D-Nezzar-and-Board"><a href="#D-Nezzar-and-Board" class="headerlink" title="D.Nezzar and Board"></a>D.Nezzar and Board</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLm1sL2NvbnRlc3QvMTQ3OC9wcm9ibGVtL0Q=">题目链接<i class="fa fa-external-link-alt"></i></span></p><h3 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给出 n 个数，每次任选两个数 x , y ，并向数组中加一个数 2x - y ，问是否能得到 k </p><h3 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h3><ol><li>若 n = 2 ，则可以得到的数是 x + k ( x - y ) ，即得到的数相差均为 ( x - y ) 的倍数，并且 x 和 y 均在得到的数中（这不是废话么</li><li>若 n = 3 ，任意取一个前两个数能得到的数 o ，则可以得到所有和 o 相差 x - y 和 z - o （z为第三个数）的数，然后这些数相差最小为 gcd( x - y , z - o )，既可以得到所有和 o 相差 gcd( x - y , z - o )的数<br>然后 o 随便取都行，只要是前两个数能得到的数即可，反正最后不会影响 gcd 的取值</li><li>n 无限制，即求出查分数组的 gcd ，然后判断 gcd 是否能整除 $k-a_1$即可。</li></ol><p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;<span class="keyword">return</span> !b?a:gcd(b,a%b);&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;n ,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> GCD=<span class="built_in">abs</span>(a[<span class="number">2</span>]-a[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;++i)</span><br><span class="line">            GCD=gcd(GCD,<span class="built_in">abs</span>(a[i]-a[i<span class="number">-1</span>]));</span><br><span class="line">        <span class="keyword">if</span>((k-a[<span class="number">1</span>])%GCD==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;（其实是吐槽&lt;br&gt;昨天比赛刚开始换了三次网，换了两次镜像网站才勉强能看到题…&lt;br&gt;游戏体验极差，而且最后还掉了一点分。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cf比赛" scheme="https://wjr-z.com/tags/cf%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>Steps to One</title>
    <link href="https://wjr-z.com/Steps-to-One/"/>
    <id>https://wjr-z.com/Steps-to-One/</id>
    <published>2021-01-25T11:39:09.000Z</published>
    <updated>2021-01-31T11:56:46.719Z</updated>
    
    <content type="html"><![CDATA[<p>这一题质量是真的不错，做了很久才做出来（初学莫比乌斯反演，别骂了<br><a id="more"></a></p><p>题目描述：<br>每次随机选出 $1\sim m$中的一个数，当已有的数的 gcd 为 1 时停止，问停止时的期望次数。<br/><br><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL3Byb2JsZW0vMTEzNTUy">题目链接<i class="fa fa-external-link-alt"></i></span></p><p>题解：</p><ul><li>看到的一个<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLm5vd2NvZGVyLm5ldC9uLzQ2YTU2YjYwMTlkMzRlYjM5OWE4MmM1NmJjZWQyZjJj">神仙题解<i class="fa fa-external-link-alt"></i></span>，复杂度是O(m)。</li><li>我的题解<br>假设$F_i$是 gcd 为 i 时变成 1 的期望次数，则不难得出$F_i=1+\frac{1}{m}\sum_{j=1}^{m}F_{gcd(i,j)}$<br/><br>这个$gcd(i,j)$下标不好处理，我们将其变为枚举 $gcd(i,j)$，则可以得到：<br/><script type="math/tex; mode=display">F_{i}=1+\frac{1}{m}\sum_{d|i}F_{d}\sum_{j=1}^{m}[gcd(i,j)==d]</script>内层循环是可以进一步化简的，我们设$g(d)=\sum_{i=1}^{m}[gcd(i,n)==d],G(d)=\sum_{i=1}^{m}[d|gcd(i,n)]$<br/><br>可以得出<script type="math/tex; mode=display">\begin{aligned}&G(d)=\sum_{d|k}g(k)=\lfloor\frac{m}{d}\rfloor[n\%d==0] \\&g(d)=\sum_{d|k}\mu(\frac{k}{d})G(k)=\sum_{d|k}\mu(\frac{k}{d})\lfloor\frac{m}{k}\rfloor[n\%k==0]\end{aligned}</script>然后可以将原式稍微变形，并将上式代入：<script type="math/tex; mode=display">\sum_{j=1}^{m}[gcd(i,j)==d]=\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(\frac{i}{d},j)==1]</script>代入 g(1) ，得<script type="math/tex; mode=display">\begin{aligned}\sum_{k}\mu(k)\lfloor\frac{m}{dk}\rfloor[\frac{i}{d}\%k==0]=\sum_{k|\frac{i}{d}}\mu(k)\lfloor\frac{m}{dk}\rfloor\end{aligned}</script>令 $T=dk$ <script type="math/tex; mode=display">\sum_{T|i}\mu(\frac{T}{d})\lfloor\frac{m}{T}\rfloor</script>代入原式<script type="math/tex; mode=display">\begin{aligned}F_i&=1+\frac{1}{m}\sum_{d|i}F_d\sum_{T|i}\mu(\frac{T}{d})\lfloor\frac{m}{T}\rfloor \\&=1+\frac{1}{m}\sum_{T|i}\lfloor\frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})F_d\end{aligned}</script>内层循环与 i 无关，因此可以进行处理，在求 F 的同时进行更新。<br>注意到左右两边均存在 $F_i$ ，将右边的 $F_i$提出并合并到左边即可<script type="math/tex; mode=display">\begin{aligned}F_i&=1+\frac{1}{m}\sum_{T|i}\lfloor\frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})F_d \\&=1+\frac{1}{m}\sum_{T|i}\lfloor\frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})F_d[d\neq i]+\frac{1}{m}\lfloor\frac{m}{i}\rfloor\mu(1)F_i \\&=1+\frac{1}{m}\sum_{T|i}\lfloor\frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})F_d[d\neq i]+\frac{1}{m}\lfloor\frac{m}{i}\rfloor F_i \\F_{i}&=\frac{m+\sum_{T|i}\lfloor\frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})F_d[d\neq i]}{m-\lfloor\frac{m}{i}\rfloor}\end{aligned}</script>记$g_T=\sum_{d|T}\mu(\frac{T}{d})F_d[d\neq i]$即可，每次求出$F_i$后更新 g ，因为 $g_T$在求出 $F_T$后被更新，因此求$F_T$时不需要特判$T\neq i$。<br/></li></ul><p>代码如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">1e5</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a+b&gt;=mod?a+b-mod:a+b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a-b+mod:a-b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a*<span class="number">1ll</span>*b%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)s=mul(s,a);</span><br><span class="line">        a=mul(a,a);</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> prime[N],mu[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;q[N];</span><br><span class="line"><span class="keyword">bool</span> f[N];</span><br><span class="line"><span class="keyword">int</span> F[N],g[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="literal">true</span>,mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=M;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            prime[++prime[<span class="number">0</span>]]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=prime[<span class="number">0</span>]&amp;&amp;i*prime[j]&lt;=M;++j)&#123;</span><br><span class="line">            f[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            mu[i*prime[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)</span><br><span class="line">        mu[i]=mu[i]&lt;<span class="number">0</span>?mu[i]+mod:mu[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=M;j+=i)</span><br><span class="line">            q[j].push_back(i);</span><br><span class="line">    F[<span class="number">1</span>]=<span class="number">0</span>,g[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=q[i].size()<span class="number">-1</span>;~j;--j)</span><br><span class="line">            F[i]=add(F[i],mul(m/q[i][j],g[q[i][j]]));</span><br><span class="line">        F[i]=add(F[i],m);</span><br><span class="line">        F[i]=mul(F[i],qpow(m-m/i,mod<span class="number">-2</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=m;j+=i)</span><br><span class="line">            g[j]=add(g[j],mul(F[i],mu[j/i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        ans=add(ans,F[i]);</span><br><span class="line">    ans=add(<span class="number">1</span>,mul(ans,qpow(m,mod<span class="number">-2</span>)));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这一题质量是真的不错，做了很久才做出来（初学莫比乌斯反演，别骂了&lt;br&gt;</summary>
    
    
    
    
    <category term="DP" scheme="https://wjr-z.com/tags/DP/"/>
    
    <category term="牛客每日一题" scheme="https://wjr-z.com/tags/%E7%89%9B%E5%AE%A2%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="莫比乌斯反演" scheme="https://wjr-z.com/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
    <category term="数论" scheme="https://wjr-z.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>WC2008游览计划</title>
    <link href="https://wjr-z.com/WC2008%E6%B8%B8%E8%A7%88%E8%AE%A1%E5%88%92/"/>
    <id>https://wjr-z.com/WC2008%E6%B8%B8%E8%A7%88%E8%AE%A1%E5%88%92/</id>
    <published>2021-01-22T13:37:38.000Z</published>
    <updated>2021-01-22T13:43:09.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这题我居然觉得难点是回溯…</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题其实和最小斯坦纳树模板很像，只是将边权改为了点权，而斯坦纳树通过 dp 方式转移的时候根节点 i 的点权会被算两次，因此减去一次即可。<br>然后就是套最小斯坦纳树板子了，不过这个回溯着实坑死我了…<br>其实就是记下每个 dp 状态是由什么转移过来的即可，最后从终止状态慢慢往回推，只要是回溯到的点都打上标记，代表这个位置安排了志愿者。</p><p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">11</span>, M = <span class="number">1</span> &lt;&lt; <span class="number">10</span>, inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, c;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, s;</span><br><span class="line">    node(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        s = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;pre[N * N][M];</span><br><span class="line"><span class="keyword">int</span> d[N * N], nxt[N * N * <span class="number">4</span>], to[N * N * <span class="number">4</span>], w[N * N], id[N * N], tot;</span><br><span class="line"><span class="keyword">int</span> maxn, cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    to[++tot] = b;</span><br><span class="line">    nxt[tot] = d[a];</span><br><span class="line">    d[a] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[N * N][M], dis[N * N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="keyword">bool</span> in[N * N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++i) &#123;</span><br><span class="line">        dis[i] = dp[i][s];</span><br><span class="line">        <span class="keyword">if</span> (dis[i] &lt; inf)in[i] = <span class="number">1</span>, q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        in[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = to[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[u] &gt; dis[x] + w[u]) &#123;</span><br><span class="line">                dis[u] = dis[x] + w[u];</span><br><span class="line">                pre[u][s] = node(x, s);</span><br><span class="line">                <span class="keyword">if</span> (!in[u])in[u] = <span class="number">1</span>, q.push(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++i)dp[i][s] = dis[i];</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    maxn = <span class="number">1</span> &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++i)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> S = <span class="number">1</span>; S &lt; maxn; ++S) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> T = (S - <span class="number">1</span>) &amp; S; T; T = (T - <span class="number">1</span>) &amp; S) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = dp[i][T] + dp[i][S ^ T] - w[i];</span><br><span class="line">                <span class="keyword">if</span> (v &lt; dp[i][S]) &#123;</span><br><span class="line">                    dp[i][S] = v;</span><br><span class="line">                    pre[i][S] = node(i, T);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        spfa(S);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">int</span> py[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i - <span class="number">1</span>) * m + j; &#125;</span><br><span class="line"><span class="keyword">bool</span> ans[N * N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x)<span class="keyword">return</span>;</span><br><span class="line">    ans[x] = <span class="literal">true</span>;</span><br><span class="line">    node p = pre[x][s];</span><br><span class="line">    dfs(p.x, p.s);</span><br><span class="line">    <span class="keyword">if</span> (p.x == x)dfs(p.x, p.s ^ s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">int</span> root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = ++c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p);</span><br><span class="line">            w[x] = p;</span><br><span class="line">            <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">                id[x] = cnt++;</span><br><span class="line">                dp[x][<span class="number">1</span> &lt;&lt; id[x]] = <span class="number">0</span>;</span><br><span class="line">                root = x;</span><br><span class="line">                pre[x][<span class="number">1</span> &lt;&lt; id[x]] = node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                id[x] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = i + py[k][<span class="number">0</span>], y = j + py[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x&lt;<span class="number">1</span> || y&lt;<span class="number">1</span> || x&gt;n || y&gt;m)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> a = get(i, j), b = get(x, y);</span><br><span class="line">                ins(a, b);</span><br><span class="line">            &#125;</span><br><span class="line">    work();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[root][maxn - <span class="number">1</span>]);</span><br><span class="line">    dfs(root, maxn - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = get(i, j);</span><br><span class="line">            <span class="keyword">if</span> (id[x] == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans[x])<span class="built_in">printf</span>(<span class="string">&quot;o&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这题我居然觉得难点是回溯…&lt;/p&gt;</summary>
    
    
    
    
    <category term="最小斯坦纳树" scheme="https://wjr-z.com/tags/%E6%9C%80%E5%B0%8F%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>YY的GCD</title>
    <link href="https://wjr-z.com/YY%E7%9A%84GCD/"/>
    <id>https://wjr-z.com/YY%E7%9A%84GCD/</id>
    <published>2021-01-22T12:22:10.000Z</published>
    <updated>2021-01-22T12:38:05.572Z</updated>
    
    <content type="html"><![CDATA[<p>入门级别的题（不过貌似我一开始想复杂了<br><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIyNTc=">题目链接<i class="fa fa-external-link-alt"></i></span><br><a id="more"></a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 $N, M$，求 $1 \leq x \leq N$，$1 \leq y \leq M$ 且 $\gcd(x, y)$ 为质数的 $(x, y)$ 有多少对。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>直接上柿子</p><script type="math/tex; mode=display">Ans=\sum_{k\in prime}\sum_{i=1}^{N}\sum_{j=1}^{M}[gcd(i,j)==k]</script><p>如果莫比乌斯反演做了个几道题，就会知道要化简后面那个式子<br>我们令$f(k)=\sum_{i=1}^{N}\sum_{j=1}^{M}[gcd(i,j)==k],F(k)=\sum_{i=1}^{N}\sum_{j=1}^{M}[k|gcd(i,j)]$<br/><br>然后可以得到</p><script type="math/tex; mode=display">\begin{aligned}&F(k)=\sum_{k|d}f(d)=\lfloor\frac{N}{k}\rfloor\lfloor\frac{M}{k}\rfloor \\\therefore &f(k)=\sum_{k|d}\mu(\frac{d}{k})F(d)=\sum_{k|d}\mu(\frac{d}{k})\lfloor\frac{N}{d}\rfloor\lfloor\frac{M}{d}\rfloor\end{aligned}</script><p>代入到 Ans 中，可以得到</p><script type="math/tex; mode=display">Ans=\sum_{k\in prime}\sum_{k|d}\mu(\frac{d}{k})\lfloor\frac{N}{d}\rfloor\lfloor\frac{M}{d}\rfloor</script><p>这题因为是多组询问，如果我们将$\lfloor\frac{N}{d}\rfloor\lfloor\frac{M}{d}\rfloor$放在内层的话不好进行整数分块，因此要想办法将其放到外层<br/><br>因此我们外层枚举 d ：</p><script type="math/tex; mode=display">Ans=\sum_{d=1}^{min(n,m)}\lfloor\frac{N}{d}\rfloor\lfloor\frac{M}{d}\rfloor(\sum_{k|d,k\in prime}\mu(\frac{d}{k}))</script><p>内层的这个与 N 和 M 无关，因此是可以预处理出其前缀和的，之后就可以进行整除分块了。</p><p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e7</span>+<span class="number">10</span>,M=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> mu[N],prime[M];</span><br><span class="line"><span class="keyword">bool</span> f[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="literal">true</span>,mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="number">1e7</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            prime[++prime[<span class="number">0</span>]]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=prime[<span class="number">0</span>]&amp;&amp;i*prime[j]&lt;=maxn;++j)&#123;</span><br><span class="line">            f[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            mu[i*prime[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=prime[<span class="number">0</span>];++j)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*prime[j]&lt;=maxn;++i)</span><br><span class="line">            sum[i*prime[j]]+=mu[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;++i)</span><br><span class="line">        sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxn=min(n,m);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;l&lt;=maxn;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=min(n/(n/l),m/(m/l));</span><br><span class="line">        ans+=(sum[r]-sum[l<span class="number">-1</span>])*(n/l)*(m/l);</span><br><span class="line">    &#125;<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,n,m;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,F(n,m));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;入门级别的题（不过貌似我一开始想复杂了&lt;br&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P2257&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    
    <category term="莫比乌斯反演" scheme="https://wjr-z.com/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>HNOI2011 Problem b</title>
    <link href="https://wjr-z.com/HNOI2011-Problem-b/"/>
    <id>https://wjr-z.com/HNOI2011-Problem-b/</id>
    <published>2021-01-22T11:21:07.000Z</published>
    <updated>2021-01-22T11:45:31.859Z</updated>
    
    <content type="html"><![CDATA[<ul><li>莫比乌斯反演入门题，让刚学莫比乌斯反演的我有了继续学下去的欲望。</li></ul><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>n 次询问 $\sum_{i=a}^{b}\sum_{j=c}^{d} [gcd(i,j)==k]$ 。<br><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI1MjI=">题目链接<i class="fa fa-external-link-alt"></i></span></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>数学题没啥好说的，这题显然的莫比乌斯反演题，把其变为可以莫比乌斯反演的形式即可。<br>并且可以用一个简单地容斥将下限都换成 1 。<br>设 $f(k)=\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)==k]$ ， $F(k)=\sum_{i=1}^{n}\sum_{j=1}^{m}[k|gcd(i,j)]$<br/><br>则有<br>$F(k)=\sum_{k|d}f(d)=\lfloor\frac{n}{k}\rfloor\lfloor\frac{m}{k}\rfloor$<br>前者很显然，后者因为只要求是 k 倍数的gcd，则 i , j 均为 k 的倍数即可。<br>然后我们开始愉快的推式子：</p><script type="math/tex; mode=display">\begin{aligned}&\because F(k)=\sum_{k|d}f(d) \\&\therefore f(k) =\sum_{k|d}\mu(\frac{d}{k})F(d) \\\end{aligned}</script><p>即</p><script type="math/tex; mode=display">f(k) = \sum_{k|d}\mu(\frac{d}{k})\lfloor\frac{n}{d}\rfloor \lfloor\frac{m}{d}\rfloor</script><p>再令 $T=\frac{d}{k}$</p><script type="math/tex; mode=display">f(k)=\sum_{T}^{\frac{min(n,m)}{k}}\mu(R)\lfloor\frac{n}{kT}\rfloor \lfloor\frac{m}{kT}\rfloor</script><p>然后整除分块即可。<br>关于整除分块，其实就是将$\frac{n}{kT}\frac{m}{KT}$相同的一起处理<br/><br>比如当$T\in(L,R)$时$\frac{n}{kT}\frac{m}{KT}$相同，则这一部分答案为$\frac{n}{kT}\frac{m}{KT}\sum_{i=L}^{R}\mu(i)$，预处理一下莫比乌斯函数的前缀和就好。</p><p>代码如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N],mu[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N];</span><br><span class="line"><span class="keyword">bool</span> f[N];</span><br><span class="line"><span class="keyword">int</span> a,b,c,d,k;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>,f[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="number">5e4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            prime[++prime[<span class="number">0</span>]]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=prime[<span class="number">0</span>]&amp;&amp;i*prime[j]&lt;=maxn;++j)&#123;</span><br><span class="line">            f[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            mu[i*prime[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;++i)</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+mu[i];</span><br><span class="line">&#125;<span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    n/=k,m/=k;</span><br><span class="line">    <span class="keyword">int</span> maxn=min(n,m);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;l&lt;=maxn;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=min(n/(n/l),m/(m/l));</span><br><span class="line">        ans+=(sum[r]-sum[l<span class="number">-1</span>])*(n/l)*(m/l);</span><br><span class="line">    &#125;<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,F(b,d,k)-F(b,c<span class="number">-1</span>,k)-F(a<span class="number">-1</span>,d,k)+F(a<span class="number">-1</span>,c<span class="number">-1</span>,k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;莫比乌斯反演入门题，让刚学莫比乌斯反演的我有了继续学下去的欲望。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="莫比乌斯反演" scheme="https://wjr-z.com/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>莫比乌斯反演学习</title>
    <link href="https://wjr-z.com/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%AD%A6%E4%B9%A0/"/>
    <id>https://wjr-z.com/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-01-22T07:06:26.000Z</published>
    <updated>2021-01-27T14:41:10.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来没打算现在就学这个神(yin)仙(jian)东西的，结果这几天来了好几题莫比乌斯反演题…<br><a id="more"></a></p><p>我是在这篇<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcGVuZy15bS9wLzg2NDc4NTYuaHRtbA==">博客<i class="fa fa-external-link-alt"></i></span>学的，讲的不错，博客也是真的相当好看，相比之下我的博客就…<br>（也许以后会把我博客搞的也很漂亮吧，立个flag</p><h2 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h2><ul><li>首先，我们可以先明确一点，莫比乌斯函数并不是什么很高大上的东西，它其实只是一个由容斥系数所构成的函数。$\mu(d)$的定义是：</li></ul><ol><li>当 $d=1$ 时，$\mu(d)=1$.</li><li>当 $d=\Pi_{i=1}^{k}p_i$ 且 $p_i$为互异素数时，$\mu(d)=(-1)^k$.（即 d 的所有质因数幂次均不大于1时）</li><li>当 $d$ 的任意质因数幂次大于等于 2 ，$\mu(d)=0$.</li></ol><ul><li>当然，莫比乌斯函数也有很多有趣的性质：</li></ul><ol><li>对于任意正整数 n ，$\sum_{d|n}\mu(d)=[n=1]$（这个性质非常重要，后面给出证明）</li><li>对于任意正整数 n , $\sum_{d|n}{\frac{\mu(d)}{d}}=\frac{\phi(n)}{n}$（这个性质也很重要）</li></ol><h3 id="关于性质-1-的证明："><a href="#关于性质-1-的证明：" class="headerlink" title="关于性质 1 的证明："></a>关于性质 1 的证明：</h3><p>假设 $n=\Pi_{i=1}^{k}p_{i}^{k_i}$，因为质因数幂次大于等于 2 的莫比乌斯函数值为 0 ，因此只用考虑幂次为 0/1<br>当 n 不为 1 时，假设 d 中有 i 个互异素数，则有<br>$\sum_{d|n}\mu(d)=\sum_{i=0}^{k}(-1)^{k}*C(k,i)$，这个式子显然为 0 。<br>当 n = 1 时，没有质因数，且根据定义该性质依然成立。<br>证毕。</p><h3 id="求解莫比乌斯函数"><a href="#求解莫比乌斯函数" class="headerlink" title="求解莫比乌斯函数"></a>求解莫比乌斯函数</h3><p>可以在线性筛的基础上进行改造，如果没学过线性筛，可以来<a href="/线性筛详解/">这里</a>看看。</p><ul><li>当 d 为 1 时，$\mu(d)=1$</li><li>当 d 为素数时，很显然 $\mu(d)=-1$</li><li>当 d 为非素数时，因为线性筛的特殊性质，prime[j] 必定是 i*prime[j] 的最小质因数，如果 i % prime[ j ] ! = 0 ，则根据莫比乌斯的第二个定义， $\mu(i*prime[j])=-\mu(i)$即可，如果 i % prime[ j ] == 0 ，则根据第三个定义，$\mu(i*primep[j])=0$</li></ul><p>代码如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mu[maxn],pri[maxn];<span class="comment">//prime简写</span></span><br><span class="line"><span class="keyword">bool</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            pri[++pri[<span class="number">0</span>]]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=pri[<span class="number">0</span>]&amp;&amp;i*pri[j]&lt;=n;++j)&#123;</span><br><span class="line">            f[i*pri[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            mu[i*pri[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>那么，莫比乌斯函数就这么告一段落了。</li></ul><h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><ul><li>解决完莫比乌斯函数的问题后，我们便迎来了重头戏<strong>莫比乌斯反演</strong></li><li>定理：F(n)和f(n)是定义在非负整数集合上的两个函数，并且满足条件：<script type="math/tex; mode=display">F(n)=\sum_{d|n} f(d)</script>那么存在一个结论：<script type="math/tex; mode=display">f(n)=\sum_{d|n}\mu(d)F(\frac{n}{d})</script>这个定理就称作莫比<strong>乌斯反演定理</strong>。</li></ul><p><li>莫比乌斯反演的证明主要有两种方式，其中一种就是通过定义来证明；另外一种，我则是会在<strong><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcGVuZy15bS9wLzk0NDY1NTUuaHRtbA==">杜教筛<i class="fa fa-external-link-alt"></i></span></strong>中提到( 利用<em><strong>狄利克雷卷积</strong></em> )。那么我先来说一说第一种证明方法：</li></p><script type="math/tex; mode=display">\begin{aligned}\sum{\mu(d)F(\frac{n}{d})} &= \sum{\mu(d)\sum_{i|\frac{n}{d}}f(i)} \\&=\sum_{i|n}f(i)\sum_{d|\frac{n}{i}}{\mu(d)} \\&=f(n)\end{aligned}</script><p>其中第二步即将外层枚举 d 改为枚举 i 即可得到，最后一步即性质1。</p><ul><li>当然，莫比乌斯反演有另外的一种形式，当F(n)和f(n)满足：<script type="math/tex; mode=display">F(n)=\sum_{n|d}f(d)</script>可以推出<script type="math/tex; mode=display">f(n)=\sum_{n|d}\mu(\frac{d}{n})F(d)</script></li><li>感觉这个式子，可能在莫比乌斯反演中更加好用。</li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>1.<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI1MjI=">HNOI2011 Problem b<i class="fa fa-external-link-alt"></i></span><br><a href="/HNOI2011-Problem-b/">我的题解</a><br>2.<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIyNTc=">YY的GCD<i class="fa fa-external-link-alt"></i></span><br><a href="/YY的GCD/">我的题解</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本来没打算现在就学这个神(yin)仙(jian)东西的，结果这几天来了好几题莫比乌斯反演题…&lt;br&gt;</summary>
    
    
    
    
    <category term="莫比乌斯反演" scheme="https://wjr-z.com/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
    <category term="数论" scheme="https://wjr-z.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>线性筛详解</title>
    <link href="https://wjr-z.com/%E7%BA%BF%E6%80%A7%E7%AD%9B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://wjr-z.com/%E7%BA%BF%E6%80%A7%E7%AD%9B%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-01-22T05:53:57.000Z</published>
    <updated>2021-01-27T05:21:45.827Z</updated>
    
    <content type="html"><![CDATA[<p>最简单的，最容易想到的筛素数的应该就是直接从小到大，将每个素数的2以上的倍数筛掉了，这个方法复杂度约为 O(N ln ln N)。</p><a id="more"></a><p>举个栗子：<br>初始：&emsp;&emsp; &emsp; &nbsp;&nbsp;&nbsp; 1 2 3 4 5 6 7 8 9 10 11 12<br>第一次（2）：&nbsp;&nbsp; 1 2 3 5 7 9 11<br>第二次（3）：&nbsp;&nbsp; 1 2 3 5 7 11<br>第三次（5）： &nbsp;&nbsp;1 2 3 5 7 11<br>第四次（7）： &nbsp;&nbsp;1 2 3 5 7 11<br>第五次（11）：1 2 3 5 7 11</p><p>如果每次并非是用素数进行筛，复杂度是O(N lnN)（调和级数），因为只用素数筛去，因此复杂度进一步降低了。</p><p>不过这个方法并不是线性的，下面来重点介绍下线性筛。</p><h2 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h2><p>线性筛本质就是让一个数只被筛去一次，而上述的筛法（Eratosthenes筛法）有很多数其实不止被筛去了一次。<br>我们考虑让每个非素数 x=p*q ，其中 p 是 x 分解质因数的最小质数，我们仅让其能被 q 筛去，这样因为每个数仅有一个最小质因数，所以只会被筛去一次，且每个非素数一定会被筛去，因为我们总是能找到这样的 p 和 q </p><h3 id="那么如何实现呢？"><a href="#那么如何实现呢？" class="headerlink" title="那么如何实现呢？"></a>那么如何实现呢？</h3><p>将 q 分解质因数，则 q 也存在一个最小的质因数，假设为 c ，则当 p 不大于 c 时，即代表可以筛去。<br>不过实际上不用求出 q 的最小质因数。<br>我们假设当前是 i ，且我们用了另一个数组 pri 存下来当前找到的所有素数（从小到大），然后考虑用 i 用上述方法筛去非素数，枚举素数，当 i%pri[j]==0 时停止即可，此时代表 i 存在一个 pri[j]这个素数，当 j 继续增加，i 分解质因数后的最小素数比 pri[j]更小，这样会导致部分数筛去多次，因此需要停止。</p><p>举个栗子：<br>初始：&emsp;&emsp;&emsp;&nbsp;&nbsp;       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16<br>第一次（2）：1 2 3 5 6 7 8 9 10 11 12 13 14 15 16  （pri:2，筛去2*2=4并停止）<br>第二次（3）：1 2 3 5 7 8 10 11 12 13 14 15 16  （pri:2,3，筛去3*2=6，3*3=9并停止）<br>第三次（4）：1 2 3 5 7 10 11 12 13 14 15 16  （pri:2,3，筛去4*2=6并停止）<br>第四次（5）：1 2 3 5 7 11 12 13 14 16 （pri:2,3,5，筛去5*2=10，5*3=15并停止）<br>第五次（6）：1 2 3 5 7 11 13 14 16  （pri:2,3,5，筛去6*2并停止）<br>第六次（7）：1 2 3 5 7 11 13 16  （pri:2,3,5,7，筛去7*2=14并停止）<br>第七次（8）：1 2 3 5 7 11 13 （pri:2,3,5,7，筛去8*2=16并停止）<br>…</p><p>代码如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pri[maxn];</span><br><span class="line"><span class="keyword">bool</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])pri[++pri[<span class="number">0</span>]]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=pri[<span class="number">0</span>]&amp;&amp;i*pri[j]&lt;=n;++j)&#123;</span><br><span class="line">            f[i*pri[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>线性筛也可以用于求欧拉函数、莫比乌斯函数，因此弄懂线性筛的原理很重要！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最简单的，最容易想到的筛素数的应该就是直接从小到大，将每个素数的2以上的倍数筛掉了，这个方法复杂度约为 O(N ln ln N)。&lt;/p&gt;</summary>
    
    
    
    
    <category term="线性筛" scheme="https://wjr-z.com/tags/%E7%BA%BF%E6%80%A7%E7%AD%9B/"/>
    
  </entry>
  
  <entry>
    <title>SCOI2005最大子矩阵</title>
    <link href="https://wjr-z.com/SCOI2005%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/"/>
    <id>https://wjr-z.com/SCOI2005%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/</id>
    <published>2021-01-21T04:43:56.000Z</published>
    <updated>2021-01-31T11:56:32.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>这里有一个n*m的矩阵，请你选出其中k个子矩阵，使得这个k个子矩阵分值之和最大。<br>注意：选出的k个子矩阵 不能相互重叠。</p></blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL3Byb2JsZW0vMjAyNDI=">题目链接<i class="fa fa-external-link-alt"></i></span><br><a id="more"></a></p><p>题解：<br>题目范围很重要，$m\leq 2$，当m为1时即简单的数组中取k段连续和的最大值，令dp[i][j]表示前i个取j个子矩阵的最大值即可。<br>当m=2时，即将上述的二维dp改为三维dp即可，令dp[i][j][k]表示第一列前i个，第二列前j个中取k个子矩阵的最大值。<br>dp[i][j][k]初始为max(dp[i-1][j][k],dp[i][j-1][k])，表示不取的转移。<br>1.如果是当前取一个一列的矩阵，则分别在两列进行转移：</p><script type="math/tex; mode=display">\begin{aligned}dp[i][j][k]=max\{dp[p][j][k-1]+s1[i]-s1[p]\}\\dp[i][j][k]=max\{dp[i][p][k-1]+s2[i]-s2[p]\}\end{aligned}</script><p>2.如果是取一个两列的矩阵，则只能在i=j时进行转移：</p><script type="math/tex; mode=display">\begin{aligned}dp[i][i][k]=max\{dp[p][p][k-1]+s1[i]+s2[i]-s1[p]-s2[p]\}\end{aligned}</script><p>其中s1表示第一列前缀和，s2表示第二列前缀和。</p><p>不过后来我发现这样做还是有些问题的，如果m=1并且第一列全为负数，这样第二列当做0算，这样取的k个子矩阵可能有第二列的，但这是非法的，因此需要考虑将m=1和m=2分开来做或者是第二列前缀和进行修改。<br>因为数据范围并不大，因此对第二列前缀和修改即可，而且此题貌似数据也很弱，不考虑也能过。</p><details>    <summary>参考代码</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>][<span class="number">12</span>],s[<span class="number">105</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">105</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0xf3</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">            s[i][j]=s[i<span class="number">-1</span>][j]+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;++j)</span><br><span class="line">            dp[i][j][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            s[i][<span class="number">2</span>]=-i*<span class="number">1e7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=k;++p)<span class="comment">//取p个子矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="comment">//第一列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;<span class="comment">//第二列</span></span><br><span class="line">                dp[i][j][p]=max(dp[i<span class="number">-1</span>][j][p],dp[i][j<span class="number">-1</span>][p]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;i;++l)</span><br><span class="line">                    dp[i][j][p]=max(dp[i][j][p],dp[l][j][p<span class="number">-1</span>]+s[i][<span class="number">1</span>]-s[l][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;j;++l)</span><br><span class="line">                    dp[i][j][p]=max(dp[i][j][p],dp[i][l][p<span class="number">-1</span>]+s[j][<span class="number">2</span>]-s[l][<span class="number">2</span>]);</span><br><span class="line">                <span class="keyword">if</span>(i==j)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;i;++l)</span><br><span class="line">                        dp[i][j][p]=max(dp[i][j][p],dp[l][l][p<span class="number">-1</span>]+s[i][<span class="number">1</span>]+s[i][<span class="number">2</span>]-s[l][<span class="number">1</span>]-s[l][<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[n][n][k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这里有一个n*m的矩阵，请你选出其中k个子矩阵，使得这个k个子矩阵分值之和最大。&lt;br&gt;注意：选出的k个子矩阵 不能相互重叠。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/20242&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    
    <category term="DP" scheme="https://wjr-z.com/tags/DP/"/>
    
    <category term="牛客每日一题" scheme="https://wjr-z.com/tags/%E7%89%9B%E5%AE%A2%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P4151最大XOR路径</title>
    <link href="https://wjr-z.com/%E6%B4%9B%E8%B0%B7P4151%E6%9C%80%E5%A4%A7XOR%E8%B7%AF%E5%BE%84/"/>
    <id>https://wjr-z.com/%E6%B4%9B%E8%B0%B7P4151%E6%9C%80%E5%A4%A7XOR%E8%B7%AF%E5%BE%84/</id>
    <published>2021-01-20T12:40:27.000Z</published>
    <updated>2021-01-20T13:25:23.685Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个无向图，让你求从 1 到 n 的路径最大异或和。<br><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQxNTE=">题目链接<i class="fa fa-external-link-alt"></i></span><br><a id="more"></a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一条边如果经过偶数次则这条边对答案无影响，如果经过奇数次则有影响。<br>不难发现任意两条路径异或后其实都是若干个环，证明省略。<br>接下来考虑如何找到所有的环。<br>因为异或的性质，因此我们并非需要真的找到所有的环，实际上要找的环十分有限。<br>我们用dfs，每搜到一个点打上 vis 标记，如果下一个点已经 vis 过了，则这个环的异或和丢进线性基，否则继续深搜。<br>这样为什么是对的呢？<br>事实上这样很多的环套环是搜不到的。<br>当我们找到一个环后，这个环因为其所有点均 vis 过，因此包含此环一部分的其他环无法被找到。<br>不过所有的环其实均为若干个简单环异或而成，此处简单环指不可能与其他若干环异或的到新环，而简单环我们可以证明一定都能被找到，加入存在某简单环未在dfs中找到，则说明必定存在环上P，在找到该环前访问过该环上的某点Q，则P，Q之间必定至少存在一个环，说明该环不是简单环，因此可以证明所有简单环一定是能被找到的。<br>然后所有的环都能由若干个简单环异或而成，用线性基便可以得到所有可能异或出的值。<br>再回到最初说的两条路径异或和都是若干个环，这样的话最优路径和我们随便找的一条路径只相差若干个环，将所有的简单环的异或值丢进线性基，然后随便用一个1 到 n 的路径异或和找到异或最大值即可。</p><details>    <summary>参考代码</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50010</span>,M=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">70</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>(x&amp;(<span class="number">1ll</span>&lt;&lt;i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i])x^=f[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                f[i]=x;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> d[N],nxt[M&lt;&lt;<span class="number">1</span>],to[M&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> cost[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">long</span> <span class="keyword">long</span> c)</span></span>&#123;</span><br><span class="line">    to[++tot]=b;</span><br><span class="line">    nxt[tot]=d[a];</span><br><span class="line">    d[a]=tot;</span><br><span class="line">    cost[tot]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">long</span> <span class="keyword">long</span> v)</span></span>&#123;</span><br><span class="line">    dis[x]=v;vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=d[x];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> u=to[i];</span><br><span class="line">        <span class="keyword">if</span>(!vis[u])dfs(u,v^cost[i]);</span><br><span class="line">        <span class="keyword">else</span> insert(v^dis[u]^cost[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Max</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>((ans^f[i])&gt;ans)ans^=f[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        ins(u,v,w);</span><br><span class="line">        ins(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,Max(dis[n]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个无向图，让你求从 1 到 n 的路径最大异或和。&lt;br&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P4151&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    
    <category term="线性基" scheme="https://wjr-z.com/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
  </entry>
  
  <entry>
    <title>牛客挑战赛47E.路径</title>
    <link href="https://wjr-z.com/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B47E-%E8%B7%AF%E5%BE%84/"/>
    <id>https://wjr-z.com/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B47E-%E8%B7%AF%E5%BE%84/</id>
    <published>2021-01-19T12:22:49.000Z</published>
    <updated>2021-01-19T12:41:44.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵树，求所有经过点数大于等于2的无向路径中长度第k小的。</p><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA3NDMvRQ==">题目链接<i class="fa fa-external-link-alt"></i></span></p><a id="more"></a><p>用点分治先预处理出长度为 i 的路径数 ans[i] 。<br>假设当前层重心是 x ，设 a[i] 表示当前已经处理的所有子树到 x 路径长度为 i 的路径数，b[i] 表示正在处理的子树到 x 路径长度为 i 的路径数，则有</p><script type="math/tex; mode=display">ans[i]=\sum_{j=0}^{i}a[j]*b[i-j]</script><p>然后将当前处理子树合并到已处理子树上，两数组相加即可。<br>关于求这个卷积，如果暴力求，很可能会TLE，如果没有TLE说明数据比较水，反正复杂度肯定是不行的。<br>可以用FFT或者NTT来求这个卷积。<br>不过就算这样了其实还是很可能会TLE。<br>假设当前根有 n-1 棵子树，每颗子树仅一个点，且第一个子树和当前根节点连的边为 100000 ，这样的话会被卡到 $O(n* z)$。<br/><br>因此需要将当前根节点的所有子树按照其最长路径从小到大排序后再依次合并，类似于启发式合并，复杂度会降低到$O(z\,logz\,logn)$<br/><br>算上点分治复杂度，总复杂度为 $O(z\,logz\,logn+n\,logn)$<br/><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Complex(<span class="keyword">double</span> a = <span class="number">0</span>, <span class="keyword">double</span> b = <span class="number">0</span>) &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>+(Complex a, Complex b) &#123; <span class="keyword">return</span> Complex(a.x + b.x, a.y + b.y); &#125;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(Complex a, Complex b) &#123; <span class="keyword">return</span> Complex(a.x - b.x, a.y - b.y); &#125;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>*(Complex a, Complex b) &#123; <span class="keyword">return</span> Complex(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">18</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> rev[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_rev</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span> &lt;&lt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (s - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i])</span><br><span class="line">            swap(a[i], a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, mid = <span class="number">1</span>; i &lt;= n; i &lt;&lt;= <span class="number">1</span>, mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">Complex <span class="title">wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span> * PI / i), p * <span class="built_in">sin</span>(<span class="number">2</span> * PI / i))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += i) &#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; j + mid; ++k) &#123;</span><br><span class="line">                Complex x = a[k], y = w * a[k + mid];</span><br><span class="line">                a[k] = x + y, a[k + mid] = x - y;</span><br><span class="line">                w = w * wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            a[i].x /= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5e4</span> + <span class="number">10</span>, H = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[H];</span><br><span class="line">Complex F[N], G[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = n + m, bit = <span class="number">0</span>, s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (s &lt;= len)++bit, s &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; ++i)</span><br><span class="line">        F[i].x = a[i], G[i].x = b[i], F[i].y = G[i].y = <span class="number">0</span>;</span><br><span class="line">    get_rev(bit);</span><br><span class="line">    FFT(F, s, <span class="number">1</span>), FFT(G, s, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; ++i)</span><br><span class="line">        F[i] = F[i] * G[i];</span><br><span class="line">    FFT(F, s, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; ++i)</span><br><span class="line">        ans[i] += (<span class="keyword">int</span>)(F[i].x + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[M], siz[M], d[M], nxt[M &lt;&lt; <span class="number">1</span>], to[M &lt;&lt; <span class="number">1</span>], cost[M &lt;&lt; <span class="number">1</span>], tot;</span><br><span class="line"><span class="keyword">bool</span> vis[M];</span><br><span class="line"><span class="keyword">int</span> Siz, rot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    to[++tot] = b;</span><br><span class="line">    nxt[tot] = d[a];</span><br><span class="line">    d[a] = tot;</span><br><span class="line">    cost[tot] = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_rt</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    siz[x] = <span class="number">1</span>; dp[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (u == f || vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        get_rt(u, x);</span><br><span class="line">        siz[x] += siz[u];</span><br><span class="line">        dp[x] = max(dp[x], siz[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[x] = max(dp[x], Siz - siz[x]);</span><br><span class="line">    <span class="keyword">if</span> (dp[x] &lt; dp[rot])rot = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> al, bl;</span><br><span class="line"><span class="keyword">int</span> stk[M], top;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    ++b[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (u == f || vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        dfs(u, x, v + cost[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Max;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, max_dep, cost;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; other)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> max_dep &lt; other.max_dep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;st[M];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_dep</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = dep;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (u == f || vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        c = max(c, get_dep(u, x, dep + cost[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>; al = <span class="number">0</span>;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">        st[cnt].x = u, st[cnt].max_dep = get_dep(u, x, cost[i]);</span><br><span class="line">        st[cnt].cost = cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(st + <span class="number">1</span>, st + <span class="number">1</span> + cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = st[i].x;</span><br><span class="line">        bl = st[i].max_dep;</span><br><span class="line">        dfs(u, x, st[i].cost);</span><br><span class="line">        Merge(a, b, al, bl);</span><br><span class="line">        Max = max(Max, al + bl);</span><br><span class="line">        al = max(al, bl);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= al; ++j)</span><br><span class="line">            a[j] += b[j], b[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= al; ++i)</span><br><span class="line">        a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    rot = <span class="number">0</span>; Siz = s;</span><br><span class="line">    get_rt(x, <span class="number">0</span>);</span><br><span class="line">    x = rot;</span><br><span class="line">    vis[x] = <span class="number">1</span>; calc(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = d[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = to[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        solve(u, siz[u] &lt; siz[x] ? siz[u] : s - siz[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    dp[<span class="number">0</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        ins(u, v, w);</span><br><span class="line">        ins(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    solve(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Max; ++i)</span><br><span class="line">        ans[i] += ans[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> k;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;k);</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = Max, Ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = L + R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans[mid] &lt; k)L = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> R = mid - <span class="number">1</span>, Ans = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一棵树，求所有经过点数大于等于2的无向路径中长度第k小的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/10743/E&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="FFT" scheme="https://wjr-z.com/tags/FFT/"/>
    
    <category term="点分治" scheme="https://wjr-z.com/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>FFT详解</title>
    <link href="https://wjr-z.com/FFT%E8%AF%A6%E8%A7%A3/"/>
    <id>https://wjr-z.com/FFT%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-01-18T04:44:14.000Z</published>
    <updated>2021-01-26T12:27:14.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FFT定义"><a href="#FFT定义" class="headerlink" title="FFT定义"></a>FFT定义</h2><blockquote><p>FFT（Fast Fourier Transformation）是离散傅氏变换（DFT）的快速算法。即为快速傅氏变换。它是根据离散傅氏变换的奇、偶、虚、实等特性，对离散傅立叶变换的算法进行改进获得的。<br>(yysy这个定义看着乐呵就好)<br><a id="more"></a></p></blockquote><h2 id="FFT的用处"><a href="#FFT的用处" class="headerlink" title="FFT的用处"></a>FFT的用处</h2><p>在算法竞赛中会碰到卷积形式的计数，或者说多项式乘法，但是常规的计算复杂度是$O(n^2)$的，当 n 比较大的时候，很显然不能满足我们的要求。<br>而FFT将这个过程的复杂度降低到了$O(nlog n)$。</p><h2 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h2><h3 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h3><p>简单来说，形如$a_0+a_1 x+a_2 x^{2}…+a_n a^{n}$的代数表达式叫做多项式，可以记做$f(x)=a_0+a_1 x+a_2 x^{2}…+a_n a^{n}$</p><h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>复数形如$a+bi$，其中$i=\sqrt{-1},i*i=-1$<br/><br>a 叫做复数的实部， b 叫做复数的虚部。<br>复数相乘：</p><script type="math/tex; mode=display">(a1+b1i)*(a2+b2i)=(a1*a2-b1*b2)+(a1*b2+a2*b1)i</script><p>复数$c+di$可以用这种方式表示出来：<br><img data-src="https://tu.sunpma.com/imgs/2021/01/f7bce41a38b84035.png" alt=""><br>复数乘法的在复平面中表现为<strong>辐角相加，模长相乘</strong></p><h3 id="单位根"><a href="#单位根" class="headerlink" title="单位根"></a>单位根</h3><p>复数 w 满足$w^n=1$，则称 w 是 n 次单位根，下图包含了所有的 8 次方根 （下图中圆的半径是1）<br><img data-src="https://tu.sunpma.com/imgs/2021/01/427fa960f8864b4c.png" alt=""></p><p>n 次单位根用 $w_n$ 表示<br/><br>关于单位根有如下性质：<br>1.$w_{2n}^{2}=w_{n}$，因此有$w_{2n}^{2m}=w_{n}^{m}$<br/><br>2.$w_{n}^{\frac{n}{2}}=-1$，因此有$w_{2n}^{m}=-w_{2n}^{m+\frac{n}{2}}$<br/><br>这两个很有用，一定要记住。</p><h3 id="多项式的系数表示法"><a href="#多项式的系数表示法" class="headerlink" title="多项式的系数表示法"></a>多项式的系数表示法</h3><p>这是我们常用的表示方法，即$f(x)=a_0+a_1 x+a_2 x^{2}…+a_n a^{n}$的形式，称$A(X)$是多项式$f(x)$的系数表示法。<br/><br>这样多项式乘法是$O(n^2)$</p><h3 id="多项式的点值表示法"><a href="#多项式的点值表示法" class="headerlink" title="多项式的点值表示法"></a>多项式的点值表示法</h3><p>即用 n+1 个点表示多项式，可以证明 n+1 个不同的点可以唯一确定一个 n 次多项式。<br>其实就是相当于有 n+1 个方程求 n+1 个未知数（ n 次多项式最高此项是n，最多是 n+1 项）<br>也可以将其理解为解系数矩阵。<br>这样多项式乘法是$O(n)$，因为我们只需要两个多项式分别求出$O(n)$个点，然后相乘即可确定两个多项式相乘后的多项式。<br/></p><h2 id="FFT的具体过程"><a href="#FFT的具体过程" class="headerlink" title="FFT的具体过程"></a>FFT的具体过程</h2><p>我们可以看到点值表示法多项式相乘是$O(n)$的，不过要转化为点值相乘却要$O(n^2)$，因此我们要想办法降低这些点值的复杂度。<br/><br>所以FFT即将系数表示法转化为点值表示法再转化回来，其中第一个过程叫 <strong>求值(DFT)</strong>，第二个过程叫 <strong>插值(IDFT)</strong>。</p><h3 id="求值"><a href="#求值" class="headerlink" title="求值"></a>求值</h3><p>还记得我们之前提到的单位根吗？回顾一下：</p><script type="math/tex; mode=display">\begin{aligned}&w_{2n}^{2m}=w_{n}^{m}\\&w_{n}^{m}=-w_{n}^{m+\frac{n}{2}}\\\end{aligned}</script><p>设$A_0(X)$为$A(X)$（这里设其为n次多项式，共n+1项，n+1为偶数）偶数项的和，设$A_1(X)$为$A(X)$奇数项的和，即</p><script type="math/tex; mode=display">\begin{aligned}&A_0(X)=a_0+a_2X+...+a_{n-1}X^{\frac{n}{2}}\\&A_1(X)=a_1+a_3X+...+a_{n}X^{\frac{n}{2}}\\\end{aligned}</script><p>因为$A(w_{n}^{m})=a_0w_{n}^{0}+a_1w_n^{m}+a_2w_n^{2m}+…+a_{n}w_{n}^{nm}$<br/><br>将此多项式偶数项和奇数项分别提出来可以得到</p><script type="math/tex; mode=display">\begin{aligned}&a_0w_n^0+a_2w_n^{2m}+a_4w_n^{4m}+...+a_{n-1}w_n^{(n-1)m}\\&a_1w_n^m+a_3w_n^{3m}+a_5w_n^{5m}+...+a_{n}w_n^{nm}\\\end{aligned}</script><p>根据之前的性质可以得出</p><script type="math/tex; mode=display">\begin{aligned}&A_0(w_{\frac{n}{2}}^{m})=A_0({w_n^{2m}})=a_0w_n^0+a_2w_n^{2m}+a_4w_n^{4m}+...+a_{n-1}w_n^{(n-1)m} \\&A_1(w_{\frac{n}{2}}^{m})=A_1({w_n^{2m}})=a_1w_n^0+a_3w_n^{2m}+a_5w_n^{4m}+...+a_{n}w_n^{(n-1)m}\\\end{aligned}</script><p>因此有$A(w_n^m)=A_0(w_{\frac{n}{2}}^m)+w_n^m*A_1(w_{\frac{n}{2}}^m)$<br/></p><p>且有$A(w_n^{m+\frac{n}{2}})=A_0(w_{\frac{n}{2}}^{m+\frac{n}{2}})+w_{n}^{m+\frac{n}{2}}*A_1(w_{\frac{n}{2}}^{m+\frac{n}{2}})$<br/></p><p>$\because w_{\frac{n}{2}}^{m+\frac{n}{2}}=w_{\frac{n}{2}}^{m}，w_{n}^{m+\frac{n}{2}}=-w_{n}^{m}$<br/></p><p>$\therefore A(w_n^{m+\frac{n}{2}})=A_0(w_{\frac{n}{2}}^{m})-w_{n}^{m}*A_1(w_{\frac{n}{2}}^{m})$<br/></p><p>这样的话，只要知道了$A_0(X)$和$A_1(X)$的点值表示，就可以$O(n)$求出$A(X)$的点值表示。<br/><br>我们将 $2^k$ 次单位根看做是第 k 层，这样我们知道了第 k-1 层的点值表示，就可以推出第 k 层。<br/><br>假设$f(2^k)$是求$2^k$多项式的复杂度，则有$f(2^k)=2*f(2^{k-1})+2^k$，因此复杂度是$O(k*2^k)$，令$n=2^k$，即$O(n log n)$。</p><p>因为这个过程一定要求每层都可以分成两大小相等的部分，所以求的点值必须是$2^k(k\in N)$个，则最高次至多为$2^k-1$，项数至多为$2^k$，如果次数不够，可以将高次项设置为0。</p><p>于是我们就有了递归写法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex* a,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    Complex* a0=<span class="keyword">new</span> Complex[len/<span class="number">2</span>];</span><br><span class="line">    Complex* a1=<span class="keyword">new</span> Complex[len/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        a0[i/<span class="number">2</span>]=a[i];</span><br><span class="line">        a1[i/<span class="number">2</span>]=a[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(a0,len/<span class="number">2</span>);FFT(a1,len/<span class="number">2</span>);</span><br><span class="line">    <span class="function">Complex <span class="title">wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span>*Pi/len),<span class="built_in">sin</span>(<span class="number">2</span>*Pi/len))</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(len/<span class="number">2</span>);i++)&#123;</span><br><span class="line">        a[i]=a0[i]+w*a1[i];</span><br><span class="line">        a[i+len/<span class="number">2</span>]=a0[i]-w*a1[i];</span><br><span class="line">        w=w*wn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但递归版的FFT常数巨大，实现起来比较复杂，于是又有了迭代的写法</p><p>重新考虑下递归FFT的过程，在第 i 次求解中，我们将所有元素二进制 i 位为 0 的放在了左面，i 位为 1 的放在了右面，事实上，每个元素最终到的是他二进制颠倒过来的位置<br>例如：</p><div class="table-container"><table><thead><tr><th>000</th><th>001</th><th>010</th><th>011</th><th>100</th><th>101</th><th>110</th><th>111</th></tr></thead><tbody><tr><td>000</td><td>010</td><td>100</td><td>110</td><td>001</td><td>011</td><td>101</td><td>111</td></tr><tr><td>000</td><td>100</td><td>001</td><td>101</td><td>010</td><td>110</td><td>011</td><td>111</td></tr><tr><td>000</td><td>001</td><td>010</td><td>011</td><td>100</td><td>101</td><td>110</td><td>111</td></tr></tbody></table></div><p>这样子我们将原数组顺序替换成最下面之后就不用再像递归一样每次把原数组的偶数项放左边，奇数项放右边了。<br>关于如何将二进制反转，其实也不难。<br>假设有个数 x ，我们知道了 x&gt;&gt;1 反转后的数，那么 x 反转后的数和 x&gt;&gt;1 反转后的数就差最高位，而这个最高位是 x 的最低位反转后的，然后就很简单了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_rev</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">1</span>&lt;&lt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(s<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后我们再看看非递归版该怎么向上合并。<br>我们对应要求的$x$的值列出来</p><div class="table-container"><table><thead><tr><th>$w_8^0$</th><th>$w_8^1$</th><th>$w_8^2$</th><th>$w_8^3$</th><th>$w_8^4$</th><th>$w_8^5$</th><th>$w_8^6$</th><th>$w_8^7$</th></tr></thead><tbody><tr><td>$w_4^0$</td><td>$w_4^1$</td><td>$w_4^2$</td><td>$w_4^3$</td><td>$w_4^0$</td><td>$w_4^1$</td><td>$w_4^2$</td><td>$w_4^3$</td></tr><tr><td>$w_2^0$</td><td>$w_2^1$</td><td>$w_2^0$</td><td>$w_2^1$</td><td>$w_2^0$</td><td>$w_2^1$</td><td>$w_2^0$</td><td>$w_2^1$</td></tr><tr><td>$w_1^0$</td><td>$w_1^0$</td><td>$w_1^0$</td><td>$w_1^0$</td><td>$w_1^0$</td><td>$w_1^0$</td><td>$w_1^0$</td><td>$w_1^0$</td></tr></tbody></table></div><p>首先最下面一层，只用求一个点，这个点只用求$x=w_{1}^{0}=1$的值即可，所以交换后的数组即为最下面一层的初始值。<br>然后从最下面一层慢慢往上推就行了，可以通过手动模拟画图来找到递推的规律。<br>迭代写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DFT</span><span class="params">(Complex*a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i])<span class="comment">//没这个条件的话，交换两次就会恢复原状</span></span><br><span class="line">            swap(a[i],a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,mid=<span class="number">1</span>;i&lt;=n;i&lt;&lt;=<span class="number">1</span>,mid&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function">Complex <span class="title">wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span>*PI/i),<span class="built_in">sin</span>(<span class="number">2</span>*PI/i))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j+=i)&#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;j+mid;++k)&#123;</span><br><span class="line">                Complex x=a[k],y=w*a[k+mid];</span><br><span class="line">                a[k]=x+y,a[k+mid]=x-y;</span><br><span class="line">                w=w*wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><p>刚刚计算的是 $\vec y = DFT_n(\vec a)$，可以将多项式转化成点值表示，现在为了将点值表示转化成系数表示，需要计算 IDFT（Inverse Discrete Fourier Transform），它是 DFT 的逆</p><p>这个问题实际上相当于是一个解线性方程组的问题，也就是给出了 $n$ 个线性方程 \(\begin{equation*} \left\{ \begin{array}{ccccccccc} a_0(\omega_n^0)^{0}&amp;+&amp;\cdots&amp;+&amp;a_{n-2}(\omega_n^0)^{n-2}&amp;+&amp;+a_{n-1}(\omega_n^0)^{n-1}&amp;=&amp;A(\omega_n^0) \\ a_0(\omega_n^1)^{0}&amp;+&amp;\cdots&amp;+&amp;a_{n-2}(\omega_n^1)^{n-2}&amp;+&amp;+a_{n-1}(\omega_n^1)^{n-1}&amp;=&amp;A(\omega_n^1) \\ \vdots &amp; &amp; \vdots &amp; &amp;\vdots&amp; &amp; \vdots &amp; &amp; \vdots\\ a_0(\omega_n^{n-1})^{0}&amp;+&amp;\cdots&amp;+&amp;a_{n-2}(\omega_n^{n-1})^{n-2}&amp;+&amp;+a_{n-1}(\omega_n^{n-1})^{n-1}&amp;=&amp;A(\omega_n^{n-1}) \end{array} \right. \end{equation*}\)</p><p>写成矩阵方程的形式就是</p><p>\begin{equation} \label{IDFT-equation} \begin{bmatrix} (\omega_n^0)^0 &amp; (\omega_n^0)^1 &amp; \cdots &amp; (\omega_n^0)^{n-1} \\ (\omega_n^1)^0 &amp; (\omega_n^1)^1 &amp; \cdots &amp; (\omega_n^1)^{n-1} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ (\omega_n^{n-1})^0 &amp; (\omega_n^{n-1})^1 &amp; \cdots &amp; (\omega_n^{n-1})^{n-1} \end{bmatrix} \begin{bmatrix} a_0 \\ a_1 \\ \vdots \\ a_{n-1} \end{bmatrix} = \begin{bmatrix} A(\omega_n^0) \\ A(\omega_n^1) \\ \vdots \\ A(\omega_n^{n-1}) \end{bmatrix} \end{equation}</p><p>记上面的系数矩阵为 $\mathbf V$ 现在考虑下面这个矩阵 $d_{ij}=\omega_n^{-ij}$ </p><p>\begin{equation} \mathbf D = \begin{bmatrix} (\omega_n^{-0})^0 &amp; (\omega_n^{-0})^1 &amp; \cdots &amp; (\omega_n^{-0})^{n-1} \\ (\omega_n^{-1})^0 &amp; (\omega_n^{-1})^1 &amp; \cdots &amp; (\omega_n^{-1})^{n-1} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ (\omega_n^{-(n-1)})^0 &amp; (\omega_n^{-(n-1)})^1 &amp; \cdots &amp; (\omega_n^{-(n-1)})^{n-1} \end{bmatrix} \end{equation}</p><p>设它们相乘后的结果是 $\mathbf E=\mathbf D \cdot \mathbf V$</p><p>\begin{eqnarray} e_{ij} &amp;=&amp; \sum_{k=0}^{n-1} d_{ik} v_{kj} \\ &amp;=&amp; \sum_{k=0}^{n-1} \omega_n^{-ik}\omega_n^{kj} \\ &amp;=&amp; \sum_{k=0}^{n-1} \omega_n^{k(j-i)} \end{eqnarray}</p><p>当 $i=j$ 时，$e_{ij}=n$</p><p>当 $i\neq j$ 时，</p><p>\begin{eqnarray} e_{ij} &amp;=&amp; \sum_{k=0}^{n-1} (\omega_n^{j-i})^k \\ &amp;=&amp; \frac{1-(\omega_n^{j-i})^n}{1-\omega_n^{j-i}}\\ &amp;=&amp; 0 \end{eqnarray}</p><p>因此可以知道 $\mathbf I_n=\frac{1}{n}\mathbf E$，所以 $\frac{1}{n}\mathbf D = \mathbf V^{-1}$</p><p>将 $\frac{1}{n}\mathbf D$ 在 $\ref{IDFT-equation}$ 左乘就会得到</p><p>\begin{equation} \begin{bmatrix} a_0 \\ a_1 \\ \vdots \\ a_{n-1} \end{bmatrix} = \frac{1}{n} \begin{bmatrix} (\omega_n^{-0})^0 &amp; (\omega_n^{-0})^1 &amp; \cdots &amp; (\omega_n^{-0})^{n-1} \\ (\omega_n^{-1})^0 &amp; (\omega_n^{-1})^1 &amp; \cdots &amp; (\omega_n^{-1})^{n-1} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ (\omega_n^{-(n-1)})^0 &amp; (\omega_n^{-(n-1)})^1 &amp; \cdots &amp; (\omega_n^{-(n-1)})^{n-1} \end{bmatrix} \begin{bmatrix} A(\omega_n^0) \\ A(\omega_n^1) \\ \vdots \\ A(\omega_n^{n-1}) \end{bmatrix} \end{equation}</p><p>这样，IDFT 就相当于把 DFT 过程中的 $\omega_n^i$ 换成 $\omega_n^{-i}$，然后做一次 DFT，之后结果除以 $n$ 就可以了。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="洛谷P3803-多项式乘法模板题"><a href="#洛谷P3803-多项式乘法模板题" class="headerlink" title="洛谷P3803 多项式乘法模板题"></a>洛谷P3803 多项式乘法模板题</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM4MDM=">多项式乘法模板<i class="fa fa-external-link-alt"></i></span><br>多项式乘法还是有些细节需要注意：<br>1.自带的complex速度不如手写一个Complex，推荐手写一个Complex，并重载运算符。<br>2.注意数组开的大小。<br>3.此题相乘后是最高次是 n+m 次，因此需要至少 n+m+1 个点值。<br>4.因为精度可能出问题，因此最后需要四舍五入。</p><p>下面上代码</p><details>    <summary>参考代码</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;<span class="comment">//实部和虚部</span></span><br><span class="line">    Complex(<span class="keyword">double</span> a=<span class="number">0</span>,<span class="keyword">double</span> b=<span class="number">0</span>)&#123;</span><br><span class="line">        x=a;</span><br><span class="line">        y=b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>+(Complex a,Complex b)&#123;<span class="keyword">return</span> Complex(a.x+b.x,a.y+b.y);&#125;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(Complex a,Complex b)&#123;<span class="keyword">return</span> Complex(a.x-b.x,a.y-b.y);&#125;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>*(Complex a,Complex b)&#123;<span class="keyword">return</span> Complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1</span>&lt;&lt;<span class="number">21</span>|<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> rev[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_rev</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">1</span>&lt;&lt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(s<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex*a,<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;<span class="comment">//p为1即DFT，p为-1即为IDFT</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">            swap(a[i],a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,mid=<span class="number">1</span>;i&lt;=n;i&lt;&lt;=<span class="number">1</span>,mid&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function">Complex <span class="title">wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span>*PI/i),p*<span class="built_in">sin</span>(<span class="number">2</span>*PI/i))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j+=i)&#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;j+mid;++k)&#123;</span><br><span class="line">                Complex x=a[k],y=w*a[k+mid];</span><br><span class="line">                a[k]=x+y,a[k+mid]=x-y;</span><br><span class="line">                w=w*wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)a[i].x/=n;</span><br><span class="line">&#125;<span class="keyword">int</span> n,m;</span><br><span class="line">Complex a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i].x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;b[i].x);</span><br><span class="line">    <span class="keyword">int</span> len=n+m+<span class="number">1</span>,s=<span class="number">1</span>,bit=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s&lt;len)++bit,s&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    get_rev(bit);</span><br><span class="line">    FFT(a,s,<span class="number">1</span>),FFT(b,s,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;++i)a[i]=a[i]*b[i];</span><br><span class="line">    FFT(a,s,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="keyword">int</span>(a[i].x+<span class="number">0.5</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="牛客挑战赛47-E-路径"><a href="#牛客挑战赛47-E-路径" class="headerlink" title="牛客挑战赛47 E.路径"></a>牛客挑战赛47 E.路径</h3><p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA3NDMvRQ==">点分治+FFT<i class="fa fa-external-link-alt"></i></span><br><a href="/牛客挑战赛47E-路径/">题解</a></p><blockquote><p>参考文章<br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dBRHVhbjIvYXJ0aWNsZS9kZXRhaWxzLzc5NTI5OTAw">FFT算法讲解<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jsb2cubWlza2Nvby5jb20vMjAxNS8wNC9wb2x5bm9taWFsLW11bHRpcGxpY2F0aW9uLWFuZC1mYXN0LWZvdXJpZXItdHJhbnNmb3JtI21qeC1lcW4tSURGVC1lcXVhdGlvbg==">从多项式乘法到快速傅里叶变换<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>第一篇讲的是针不戳，就是有些细节有点问题，本文已经处理过了（<del>不保证修bug一定不出新bug qwq</del>）</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;FFT定义&quot;&gt;&lt;a href=&quot;#FFT定义&quot; class=&quot;headerlink&quot; title=&quot;FFT定义&quot;&gt;&lt;/a&gt;FFT定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;FFT（Fast Fourier Transformation）是离散傅氏变换（DFT）的快速算法。即为快速傅氏变换。它是根据离散傅氏变换的奇、偶、虚、实等特性，对离散傅立叶变换的算法进行改进获得的。&lt;br&gt;(yysy这个定义看着乐呵就好)&lt;br&gt;</summary>
    
    
    
    
    <category term="FFT" scheme="https://wjr-z.com/tags/FFT/"/>
    
  </entry>
  
  <entry>
    <title>寒假学习计划</title>
    <link href="https://wjr-z.com/%E5%AF%92%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>https://wjr-z.com/%E5%AF%92%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</id>
    <published>2021-01-18T04:30:17.000Z</published>
    <updated>2021-01-19T03:29:56.282Z</updated>
    
    <content type="html"><![CDATA[<p>知识点：<br><a id="more"></a><br>1.线性基<br>2.最小斯坦纳树<br>3.bitset<br>4.点分治<br>5.边分治<br>6.莫比乌斯反演<br>7.杜教筛<br>8.DP<br>9.SAM<br>10.序列自动机<br>11.splay<br>12.替罪羊树<br>13.LCT<br>14.treap及可持久化<br>15.主席树<br>16.线段树合并<br>17.启发式合并<br>18.可撤销并查集<br>19.整体二分<br>20.2-SAT<br>21.欧拉回路<br>22.哈密顿回路<br>23.哈夫曼树<br>24.最大流最小割<br>25.次小生成树<br>26.k小生成树<br>27.差分约束<br>28.中国剩余定理<br>29.欧拉函数<br>30.欧几里得定理<br>31.扩展欧几里得<br>32.容斥原理<br>33.Ploya<br>34.Burnside<br>35.斯特林数<br>36.Min-25筛<br>37.凸包<br>38.半平面交<br>39.FFT<br>40.NTT<br>未完待续…</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;知识点：&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>牛客挑战赛76D.魔物消灭计划</title>
    <link href="https://wjr-z.com/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B76D-%E9%AD%94%E7%89%A9%E6%B6%88%E7%81%AD%E8%AE%A1%E5%88%92/"/>
    <id>https://wjr-z.com/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B76D-%E9%AD%94%E7%89%A9%E6%B6%88%E7%81%AD%E8%AE%A1%E5%88%92/</id>
    <published>2021-01-17T10:43:50.000Z</published>
    <updated>2021-01-17T11:22:27.796Z</updated>
    
    <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9hYy5ub3djb2Rlci5jb20vYWNtL2NvbnRlc3QvMTA4NDUvRA==">题目链接<i class="fa fa-external-link-alt"></i></span></p><a id="more"></a><p>这题其实就是最小斯坦纳树的模板题…<br>真的，只要会最小斯坦纳树，这题基本秒解。<br>将所有相同宝石当做一个点，然后将x,y也算作必选即可。<br>之后就是套最小斯坦纳树模板了。<br>不过其实也可以不用这样啦，直接将所有相同宝石的点连一个对应宝石的新增点，边权为0，然后初始化的时候，第i个点如果宝石种类是p，令f[i][1&lt;&lt;(p-1)]=0即可。</p><details>    <summary>参考代码</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">120</span>,M=<span class="number">1</span>&lt;&lt;<span class="number">10</span>,inf=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> d[N],nxt[M+<span class="number">2</span>*N],to[M+<span class="number">2</span>*N],cost[M+<span class="number">2</span>*N],tot;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> x,y,cnt;</span><br><span class="line"><span class="keyword">int</span> f[N][M],dis[N];</span><br><span class="line"><span class="keyword">bool</span> in[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    to[++tot]=b;</span><br><span class="line">    nxt[tot]=d[a];</span><br><span class="line">    d[a]=tot;</span><br><span class="line">    cost[tot]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        dis[i]=f[i][S];</span><br><span class="line">        <span class="keyword">if</span>(dis[i]&lt;inf)q.push(i),in[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        in[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=d[x];i;i=nxt[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> u=to[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[u]&gt;dis[x]+cost[i])&#123;</span><br><span class="line">                dis[u]=dis[x]+cost[i];</span><br><span class="line">                <span class="keyword">if</span>(!in[u])in[u]=<span class="number">1</span>,q.push(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)f[i][S]=dis[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Stenier</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt=<span class="number">1</span>&lt;&lt;(k+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)f[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S=<span class="number">0</span>;S&lt;cnt;++S)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> T=S&amp;(S<span class="number">-1</span>);T;T=(T<span class="number">-1</span>)&amp;S)</span><br><span class="line">                f[i][S]=min(f[i][S],f[i][T]+f[i][S^T]);</span><br><span class="line">        spfa(S);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k,&amp;x,&amp;y);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p);</span><br><span class="line">        <span class="keyword">if</span>(i==x)f[i][<span class="number">1</span>&lt;&lt;k]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==y)f[i][<span class="number">1</span>&lt;&lt;(k+<span class="number">1</span>)]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!p)<span class="keyword">continue</span>;</span><br><span class="line">            f[i][<span class="number">1</span>&lt;&lt;(p<span class="number">-1</span>)]=<span class="number">0</span>;</span><br><span class="line">            ins(i,n+p,<span class="number">0</span>);</span><br><span class="line">            ins(n+p,i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;n+=k;</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        <span class="keyword">if</span>(u==v)<span class="keyword">continue</span>;</span><br><span class="line">        ins(u,v,w),ins(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    Stenier();</span><br><span class="line">    <span class="keyword">int</span> ans=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)ans=min(ans,f[i][cnt<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>感觉这样子的话如果去掉相同宝石可以传送，然后去掉建额外边，好像也是可以的？<br>因为其实求最小斯坦纳树除了初始化之外，之后与那k个点无关了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/10845/D&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="最小斯坦纳树" scheme="https://wjr-z.com/tags/%E6%9C%80%E5%B0%8F%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>牛客挑战赛76E.牛牛数数</title>
    <link href="https://wjr-z.com/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B76E-%E7%89%9B%E7%89%9B%E6%95%B0%E6%95%B0/"/>
    <id>https://wjr-z.com/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B76E-%E7%89%9B%E7%89%9B%E6%95%B0%E6%95%B0/</id>
    <published>2021-01-17T10:43:30.000Z</published>
    <updated>2021-01-26T12:25:43.188Z</updated>
    
    <content type="html"><![CDATA[<p>这题如果你会线性基的话，非常简单！</p><p>如果你还没学过线性基可以来看下我的这篇博客：</p><p><a href="/线形基/">线性基详解</a></p><a id="more"></a><p>这题啊，直接异或第k小+二分即可。</p><p>因为能异或出的数的个数知道，找到大于K的最小的数是第几小即可知道大于K的数有多少了。</p><p>不过呢，这题数据较弱，有些细节不考虑都能过，例如可以异或出0时有部分代码会出bug。</p><blockquote><p>hack数据：<br>2 12<br>13 2</p></blockquote><details>    <summary>参考代码</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">62</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[N],p[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> K;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&amp;(<span class="number">1ll</span>&lt;&lt;i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i])x^=d[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                d[i]=x;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">60</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            <span class="keyword">if</span>(d[i]&amp;(<span class="number">1ll</span>&lt;&lt;j))d[i]^=d[j];</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">60</span>;++i)</span><br><span class="line">        <span class="keyword">if</span>(d[i])p[cnt++]=d[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> S;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">kth</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>&amp;&amp;cnt&lt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;n)--k;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=cnt<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span>(k&amp;(<span class="number">1ll</span>&lt;&lt;i))ans^=p[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">        add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    work();</span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;n)S=<span class="number">1ll</span>&lt;&lt;cnt;</span><br><span class="line">    <span class="keyword">else</span> S=(<span class="number">1ll</span>&lt;&lt;cnt)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> L=<span class="number">1</span>,R=S,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(L&lt;=R)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span>  mid=L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(kth(mid)&lt;=K)L=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> R=mid<span class="number">-1</span>,ans=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,S-ans+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
    <summary type="html">&lt;p&gt;这题如果你会线性基的话，非常简单！&lt;/p&gt;
&lt;p&gt;如果你还没学过线性基可以来看下我的这篇博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/线形基/&quot;&gt;线性基详解&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="线性基" scheme="https://wjr-z.com/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
  </entry>
  
</feed>
